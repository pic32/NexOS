Disassembly Listing for NexOS
Generated From:
C:/Users/ben.danametrics/Desktop/NexOS/Project/dist/Debug/debug/Project.debug.elf
Aug 6, 2019 10:09:40 AM

---  c:/users/ben.danametrics/desktop/nexos/project/task.c  ---------------------------------------------
1:                   #include <string.h>
2:                   
3:                   #include "Task.h"
4:                   #include "Lists.h"
5:                   #include "Kernel.h"
6:                   #include "CriticalSections.h"
7:                   #include "Memory.h"
8:                   
9:                   extern TASK * volatile gCurrentTask;
10:                  extern DOUBLE_LINKED_LIST_HEAD gCPU_Scheduler[];
11:                  
12:                  #if (USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1)
13:                  	extern DOUBLE_LINKED_LIST_HEAD gSuspendedQueueHead;
14:                  #endif // end of USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1
15:                  
16:                  #if (USING_TASK_HIBERNATION == 1)
17:                  	extern DOUBLE_LINKED_LIST_HEAD gHibernationQueueHead;
18:                  #endif // end of #if (USING_TASK_HIBERNATION == 1)
19:                  
20:                  #if (USING_TASK_SIGNAL == 1)
21:                  	extern DOUBLE_LINKED_LIST_HEAD gSignalWaitTaskList;
22:                  #endif // end of #if (USING_TASK_SIGNAL == 1)
23:                  
24:                  #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
25:                  	static BOOL OS_SuspendTask(TASK *Task)
26:                  	{
27:                  		// first check to see if the task can be suspended, if not, return
28:                  		if (Task->Suspendable == FALSE || Task->TaskState != READY)
29:                  		{
30:                  			return FALSE;
31:                  		}
32:                  
33:                  		OS_PlaceTaskOnBlockedList(Task, &gSuspendedQueueHead, &Task->TaskNodeArray[PRIMARY_TASK_NODE], SUSPENDED, TRUE);
34:                  
35:                  		return TRUE;
36:                  	}
37:                  #endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
38:                  
39:                  static TASK *OS_CreateTask(TASK_ENTRY_POINT StartingAddress,
40:                  							UINT32 StackSizeInWords,
41:                  							BYTE Priority,
42:                  
43:                  							#if(USING_RESTART_TASK == 1)
44:                  								BOOL RestartTask,
45:                  							#endif // end of #if(USING_RESTART_TASK == 1)
46:                  
47:                  							#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
48:                  								TASK_STATE StartingTaskState,
49:                  							#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
50:                  							
51:                  							#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
52:                  								BOOL Suspendable,
53:                  							#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
54:                  
55:                  							#if (USING_TASK_NAMES == 1)
56:                  								BYTE *TaskName,
57:                  							#endif // end of #if (USING_TASK_NAMES == 1)
58:                  
59:                  						   void *Args,
60:                  
61:                  						   #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
62:                  							   TASK_EXIT_CALLBACK TaskExit,
63:                  						   #endif // end of #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
64:                  
65:                  						   TASK *PreAllocatedTask)
66:                  {
9D0015F8  27BDFFE0   ADDIU SP, SP, -32
9D0015FC  AFBF001C   SW RA, 28(SP)
9D001600  AFBE0018   SW FP, 24(SP)
9D001604  03A0F021   ADDU FP, SP, ZERO
9D001608  AFC40020   SW A0, 32(FP)
9D00160C  AFC50024   SW A1, 36(FP)
9D001610  00C01021   ADDU V0, A2, ZERO
9D001614  AFC7002C   SW A3, 44(FP)
9D001618  A3C20028   SB V0, 40(FP)
67:                  	UINT32 i;
68:                  	TASK *NewTask = PreAllocatedTask;
9D00161C  8FC20030   LW V0, 48(FP)
9D001620  AFC20014   SW V0, 20(FP)
69:                  
70:                  	if(NewTask == (TASK*)NULL)
9D001624  8FC20014   LW V0, 20(FP)
9D001628  1440000B   BNE V0, ZERO, 0x9D001658
9D00162C  00000000   NOP
71:                  	{
72:                  		NewTask = (TASK*)AllocateMemory(sizeof(TASK));
9D001630  2404003C   ADDIU A0, ZERO, 60
9D001634  0F400478   JAL AllocateMemory
9D001638  00000000   NOP
9D00163C  AFC20014   SW V0, 20(FP)
73:                  
74:                  		if (NewTask == (TASK*)NULL)
9D001640  8FC20014   LW V0, 20(FP)
9D001644  14400004   BNE V0, ZERO, 0x9D001658
9D001648  00000000   NOP
75:                  		{
76:                  			return (TASK*)NULL;
9D00164C  00001021   ADDU V0, ZERO, ZERO
9D001650  0B4005CC   J 0x9D001730
9D001654  00000000   NOP
77:                  		}
78:                  	}
79:                  	
80:                  	// intialize the task stack and args
81:                  	NewTask->TaskStackPointer = OS_InitializeTaskStack(NewTask, StartingAddress, Args, StackSizeInWords);
9D001658  8FC40014   LW A0, 20(FP)
9D00165C  8FC50020   LW A1, 32(FP)
9D001660  8FC6002C   LW A2, 44(FP)
9D001664  8FC70024   LW A3, 36(FP)
9D001668  0F40019D   JAL OS_InitializeTaskStack
9D00166C  00000000   NOP
9D001670  00401821   ADDU V1, V0, ZERO
9D001674  8FC20014   LW V0, 20(FP)
9D001678  AC430020   SW V1, 32(V0)
82:                  
83:                  	if(NewTask->TaskStackPointer == (OS_WORD*)NULL)
9D00167C  8FC20014   LW V0, 20(FP)
9D001680  8C420020   LW V0, 32(V0)
9D001684  1440000A   BNE V0, ZERO, 0x9D0016B0
9D001688  00000000   NOP
84:                  	{
85:                  		// Only release the TASK if the user didn't supply one
86:                  		if(PreAllocatedTask == (TASK*)NULL)
9D00168C  8FC20030   LW V0, 48(FP)
9D001690  14400004   BNE V0, ZERO, 0x9D0016A4
9D001694  00000000   NOP
87:                  			ReleaseMemory((void*)NewTask);
9D001698  8FC40014   LW A0, 20(FP)
9D00169C  0F40048C   JAL ReleaseMemory
9D0016A0  00000000   NOP
88:                  
89:                  		return (TASK*)NULL;
9D0016A4  00001021   ADDU V0, ZERO, ZERO
9D0016A8  0B4005CC   J 0x9D001730
9D0016AC  00000000   NOP
90:                  	}
91:                  
92:                  	#ifdef WINDOWS_ENVIRONMENT_TESTING
93:                  		NewTask->WindowsThreadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StartingAddress, (LPVOID)Args, CREATE_SUSPENDED, NULL);
94:                  
95:                  		SetThreadPriority(NewTask->WindowsThreadHandle, THREAD_PRIORITY_LOWEST);
96:                  	#endif // end of #ifdef WINDOWS_ENVIRONMENT_TESTING
97:                  
98:                  	#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
99:                  		NewTask->TaskState = StartingTaskState;
100:                 	#else
101:                 		NewTask->TaskState = READY;
9D0016B0  8FC20014   LW V0, 20(FP)
9D0016B4  AC400024   SW ZERO, 36(V0)
102:                 	#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
103:                 
104:                 	NewTask->TaskPriority = Priority;
9D0016B8  8FC20014   LW V0, 20(FP)
9D0016BC  93C30028   LBU V1, 40(FP)
9D0016C0  A0430028   SB V1, 40(V0)
105:                 
106:                 	for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
9D0016C4  AFC00010   SW ZERO, 16(FP)
9D0016C8  0B4005BF   J 0x9D0016FC
9D0016CC  00000000   NOP
9D0016F0  8FC20010   LW V0, 16(FP)
9D0016F4  24420001   ADDIU V0, V0, 1
9D0016F8  AFC20010   SW V0, 16(FP)
9D0016FC  8FC20010   LW V0, 16(FP)
9D001700  2C420002   SLTIU V0, V0, 2
9D001704  1440FFF2   BNE V0, ZERO, 0x9D0016D0
9D001708  00000000   NOP
107:                 		OS_InitializeTaskNode(&NewTask->TaskNodeArray[i], (void*)NewTask);
9D0016D0  8FC30014   LW V1, 20(FP)
9D0016D4  8FC20010   LW V0, 16(FP)
9D0016D8  00021100   SLL V0, V0, 4
9D0016DC  00621021   ADDU V0, V1, V0
9D0016E0  00402021   ADDU A0, V0, ZERO
9D0016E4  8FC50014   LW A1, 20(FP)
9D0016E8  0F4002AD   JAL OS_InitializeTaskNode
9D0016EC  00000000   NOP
108:                 
109:                 	NewTask->CriticalCount = 0;
9D00170C  8FC20014   LW V0, 20(FP)
9D001710  AC40002C   SW ZERO, 44(V0)
110:                 
111:                 	#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
112:                 		NewTask->Suspendable = Suspendable;
113:                 	#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
114:                 
115:                 	#if (USING_TASK_DELAY_TICKS_METHOD == 1)
116:                 		NewTask->DelayInTicks = 0;
9D001714  8FC20014   LW V0, 20(FP)
9D001718  AC400030   SW ZERO, 48(V0)
117:                 	#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
118:                 
119:                 	#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
120:                 		NewTask->TaskExitMethod = TaskExit;
121:                 	#endif // end of USING_TASK_EXIT_METHOD_CALLBACK
122:                 
123:                 	#if (USING_TASK_NAMES == 1)
124:                 		if (TaskName != (char*)NULL)
125:                 		{
126:                 			// if it's too big, truncate it
127:                 			if (strlen(TaskName) > TASK_NAME_LENGTH_IN_BYTES)
128:                 				TaskName[TASK_NAME_LENGTH_IN_BYTES] = 0;
129:                 
130:                 			strcpy((char*)(NewTask->TaskName), (char*)TaskName);
131:                 		}
132:                 	#endif // end of USING_TASK_NAMES
133:                 
134:                 	#if(USING_RESTART_TASK == 1)
135:                  		if(RestartTask == TRUE)
136:                 		{
137:                 			// the user wants us to setup the task for restart
138:                 			if((NewTask->RestartInfo = (TASK_RESTART_INFO*)AllocateMemory(sizeof(TASK_RESTART_INFO))) == NULL)
139:                 			{
140:                 				// if we failed to allocate the structre, abandon the operation.
141:                 				// free up the stack space
142:                 				ReleaseMemory((void*)NewTask->StartOfTaskStackPointer);
143:                 				
144:                 				// if the user didn't pass in a TASK, then we allocated it, so free it
145:                 				if(PreAllocatedTask == (TASK*)NULL)
146:                 					ReleaseMemory((void*)NewTask);
147:                 
148:                         		return (TASK*)NULL;	
149:                 			}
150:                 			else
151:                 			{
152:                 				// assign all needed data for restarting a TASK
153:                 				NewTask->RestartInfo->StartingAddress = StartingAddress;
154:                 				NewTask->RestartInfo->TaskPriority = Priority;
155:                 
156:                 				#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
157:                 					NewTask->RestartInfo->TaskState = StartingTaskState;
158:                 				#else
159:                 					NewTask->RestartInfo->TaskState = READY;
160:                 				#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
161:                 
162:                 				NewTask->RestartInfo->StartingTaskSize = StackSizeInWords;
163:                 			}
164:                 		}
165:                 		else
166:                 		{
167:                 			NewTask->RestartInfo = (TASK_RESTART_INFO*)NULL;
168:                 		}	
169:                 	#endif // end of (USING_RESTART_TASK == 1)
170:                 
171:                 	#if(USING_TASK_CHECK_IN == 1)
172:                 		NewTask->TaskCheckIn = (TASK_CHECK_IN*)NULL;
173:                 	#endif // end of USING_TASK_CHECK_IN
174:                 
175:                 	#if (USING_TASK_SIGNAL == 1)
176:                 		NewTask->TaskSignal.OS_Signals.Word = 0;
9D00171C  8FC20014   LW V0, 20(FP)
9D001720  AC400038   SW ZERO, 56(V0)
177:                 		NewTask->TaskSignal.UserSignals.Word = 0;
9D001724  8FC20014   LW V0, 20(FP)
9D001728  AC400034   SW ZERO, 52(V0)
178:                 	#endif // end of #if (USING_TASK_SIGNAL == 1)
179:                 
180:                 	return NewTask;
9D00172C  8FC20014   LW V0, 20(FP)
181:                 }
9D001730  03C0E821   ADDU SP, FP, ZERO
9D001734  8FBF001C   LW RA, 28(SP)
9D001738  8FBE0018   LW FP, 24(SP)
9D00173C  27BD0020   ADDIU SP, SP, 32
9D001740  03E00008   JR RA
9D001744  00000000   NOP
182:                 
183:                 TASK *CreateTask(TASK_ENTRY_POINT StartingAddress,
184:                 				UINT32 StackSizeInWords,
185:                 				BYTE Priority,
186:                 				void *Args,
187:                 
188:                 				#if (USING_RESTART_TASK == 1)
189:                 					BOOL RestartTask,
190:                 				#endif // end of #if (USING_RESTART_TASK == 1)
191:                 
192:                 				#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
193:                 					TASK_STATE StartingTaskState,
194:                 				#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
195:                 				
196:                 				#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
197:                 					BOOL Suspendable,
198:                 				#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
199:                 
200:                 				#if(USING_TASK_NAMES == 1)
201:                 					BYTE *TaskName,
202:                 				#endif // end of #if(USING_TASK_NAMES == 1)
203:                 
204:                 				#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
205:                 					TASK_EXIT_CALLBACK TaskExit,
206:                 				#endif // end of #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
207:                 
208:                 				TASK *PreAllocatedTask)
209:                 {
9D001748  27BDFFD8   ADDIU SP, SP, -40
9D00174C  AFBF0024   SW RA, 36(SP)
9D001750  AFBE0020   SW FP, 32(SP)
9D001754  03A0F021   ADDU FP, SP, ZERO
9D001758  AFC40028   SW A0, 40(FP)
9D00175C  AFC5002C   SW A1, 44(FP)
9D001760  00C01021   ADDU V0, A2, ZERO
9D001764  AFC70034   SW A3, 52(FP)
9D001768  A3C20030   SB V0, 48(FP)
210:                 	TASK *Task;
211:                 
212:                 	if(PreAllocatedTask != (TASK*)NULL)
9D00176C  8FC20038   LW V0, 56(FP)
9D001770  1040000A   BEQ V0, ZERO, 0x9D00179C
9D001774  00000000   NOP
213:                 		if(RAMAddressValid((OS_WORD)PreAllocatedTask) == FALSE)
9D001778  8FC20038   LW V0, 56(FP)
9D00177C  00402021   ADDU A0, V0, ZERO
9D001780  0F400544   JAL RAMAddressValid
9D001784  00000000   NOP
9D001788  14400004   BNE V0, ZERO, 0x9D00179C
9D00178C  00000000   NOP
214:                 			return (TASK*)NULL;
9D001790  00001021   ADDU V0, ZERO, ZERO
9D001794  0B400619   J 0x9D001864
9D001798  00000000   NOP
215:                 
216:                 	if(ProgramAddressValid((OS_WORD)StartingAddress) == FALSE)
9D00179C  8FC20028   LW V0, 40(FP)
9D0017A0  00402021   ADDU A0, V0, ZERO
9D0017A4  0F400527   JAL ProgramAddressValid
9D0017A8  00000000   NOP
9D0017AC  14400004   BNE V0, ZERO, 0x9D0017C0
9D0017B0  00000000   NOP
217:                 		return (TASK*)NULL;
9D0017B4  00001021   ADDU V0, ZERO, ZERO
9D0017B8  0B400619   J 0x9D001864
9D0017BC  00000000   NOP
218:                 
219:                 	#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
220:                 		if(TaskExit != (TASK_EXIT_CALLBACK)NULL)
221:                 		{
222:                 			if(ProgramAddressValid((OS_WORD)TaskExit) == FALSE)
223:                 				return (TASK*)NULL;
224:                 		}
225:                 	#endif // end of #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
226:                 
227:                 	#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
228:                 		if (StartingTaskState == BLOCKED || StartingTaskState == RESTARTING || StartingTaskState == DELETING || StartingTaskState >= NUMBER_OF_TASK_STATES)
229:                 			return (TASK*)NULL;
230:                 	#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
231:                 
232:                 	#if(USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
233:                 		// they cannot have a SUSPENDED state and if they are not suspendable.
234:                 		if (Suspendable == FALSE && StartingTaskState == SUSPENDED)
235:                 			return (TASK*)NULL;
236:                 	#endif // end of #if(USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
237:                 
238:                 	if (Priority > HIGHEST_USER_TASK_PRIORITY)
9D0017C0  93C20030   LBU V0, 48(FP)
9D0017C4  2C420008   SLTIU V0, V0, 8
9D0017C8  14400004   BNE V0, ZERO, 0x9D0017DC
9D0017CC  00000000   NOP
239:                 		return (TASK*)NULL;
9D0017D0  00001021   ADDU V0, ZERO, ZERO
9D0017D4  0B400619   J 0x9D001864
9D0017D8  00000000   NOP
240:                 
241:                 	if(StackSizeInWords < MINIMUM_STACK_SIZE)
9D0017DC  8FC2002C   LW V0, 44(FP)
9D0017E0  2C420032   SLTIU V0, V0, 50
9D0017E4  10400004   BEQ V0, ZERO, 0x9D0017F8
9D0017E8  00000000   NOP
242:                 		return (TASK*)NULL;
9D0017EC  00001021   ADDU V0, ZERO, ZERO
9D0017F0  0B400619   J 0x9D001864
9D0017F4  00000000   NOP
243:                 
244:                 	#if(USING_TASK_NAMES == 1)
245:                 		if(TaskName != (BYTE*)NULL)
246:                 		{
247:                 			if(RAMAddressValid((OS_WORD)TaskName) == FALSE && ProgramAddressValid((OS_WORD)TaskName) == FALSE)
248:                 				return (TASK*)NULL;
249:                 		}
250:                 	#endif // end of USING_TASK_NAMES
251:                 
252:                 	EnterCritical();
9D0017F8  0F400F82   JAL EnterCritical
9D0017FC  00000000   NOP
253:                 
254:                 	Task = OS_CreateTask(	StartingAddress,
9D001800  93C20030   LBU V0, 48(FP)
9D001804  8FC30038   LW V1, 56(FP)
9D001808  AFA30010   SW V1, 16(SP)
9D00180C  8FC40028   LW A0, 40(FP)
9D001810  8FC5002C   LW A1, 44(FP)
9D001814  00403021   ADDU A2, V0, ZERO
9D001818  8FC70034   LW A3, 52(FP)
9D00181C  0F40057E   JAL OS_CreateTask
9D001820  00000000   NOP
9D001824  AFC20018   SW V0, 24(FP)
255:                 							StackSizeInWords,
256:                 							Priority,
257:                 
258:                 							#if (USING_RESTART_TASK == 1)
259:                 								RestartTask,
260:                 							#endif // end of #if (USING_RESTART_TASK == 1)
261:                 
262:                 							#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
263:                 								StartingTaskState,
264:                 							#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
265:                 
266:                 							#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
267:                 								Suspendable,
268:                 							#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
269:                 
270:                 							#if(USING_TASK_NAMES == 1)
271:                 								TaskName,
272:                 							#endif // end of #if(USING_TASK_NAMES == 1)
273:                 
274:                 							Args,
275:                 
276:                 							#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
277:                 								TaskExit,
278:                 							#endif // end of #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
279:                 
280:                 							PreAllocatedTask);
281:                 
282:                 	// if we got a valid TASK back, we can add it to whatever list it should be on.
283:                 	if(Task != (TASK*)NULL)
9D001828  8FC20018   LW V0, 24(FP)
9D00182C  1040000A   BEQ V0, ZERO, 0x9D001858
9D001830  00000000   NOP
284:                 	{
285:                 		#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
286:                 			switch (StartingTaskState)
287:                 			{
288:                 				case READY:
289:                 				{
290:                 					if (OS_AddTaskToReadyQueue(Task) == TRUE)
291:                 						SurrenderCPU();
292:                 
293:                 					break;
294:                 				}
295:                 
296:                 				#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
297:                 					case SUSPENDED:
298:                 					{
299:                 						OS_PlaceTaskOnBlockedList(Task, &gSuspendedQueueHead, &Task->TaskNodeArray[PRIMARY_TASK_NODE], SUSPENDED, FALSE);
300:                 
301:                 						break;
302:                 					}
303:                 				#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
304:                 
305:                 				#if (USING_TASK_HIBERNATION == 1)
306:                 					case HIBERNATING:
307:                 					{
308:                 						OS_PlaceTaskOnBlockedList(Task, &gHibernationQueueHead, &Task->TaskNodeArray[PRIMARY_TASK_NODE], HIBERNATING, FALSE);
309:                 
310:                 						break;
311:                 					}
312:                 				#endif // end of #if (USING_TASK_HIBERNATION == 1)
313:                 
314:                 				default:
315:                 				{
316:                 					// something has gone horrifically wrong.
317:                 
318:                 					// clean up any memory allocated to the TASK
319:                 					ReleaseMemory((void*)Task->TaskStackPointer);
320:                 
321:                 					#if (USING_RESTART_TASK == 1)
322:                 						if (Task->RestartInfo != (TASK_RESTART_INFO*)NULL)
323:                 							ReleaseMemory((void*)Task->RestartInfo);
324:                 					#endif // end of #if (USING_RESTART_TASK == 1)
325:                 
326:                 					// now we can release the TASK if they did not supply one
327:                 					if (PreAllocatedTask == (TASK*)NULL)
328:                 						ReleaseMemory((void*)Task);
329:                 
330:                 					Task = (TASK*)NULL;
331:                 
332:                 					break;
333:                 				}
334:                 			}
335:                 		#else
336:                 			if (OS_AddTaskToReadyQueue(Task) == TRUE)
9D001834  8FC40018   LW A0, 24(FP)
9D001838  0F4001F8   JAL OS_AddTaskToReadyQueue
9D00183C  00000000   NOP
9D001840  00401821   ADDU V1, V0, ZERO
9D001844  24020001   ADDIU V0, ZERO, 1
9D001848  14620003   BNE V1, V0, 0x9D001858
9D00184C  00000000   NOP
337:                 				SurrenderCPU();
9D001850  0F400C2D   JAL SurrenderCPU
9D001854  00000000   NOP
338:                 		#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
339:                 	}
340:                 
341:                 	ExitCritical();
9D001858  0F400F95   JAL ExitCritical
9D00185C  00000000   NOP
342:                 
343:                 	return (TASK*)Task;
9D001860  8FC20018   LW V0, 24(FP)
344:                 }
9D001864  03C0E821   ADDU SP, FP, ZERO
9D001868  8FBF0024   LW RA, 36(SP)
9D00186C  8FBE0020   LW FP, 32(SP)
9D001870  27BD0028   ADDIU SP, SP, 40
9D001874  03E00008   JR RA
9D001878  00000000   NOP
345:                 
346:                 #if (USING_SUSPEND_TASK_METHOD == 1)
347:                 	OS_RESULT SuspendTask(TASK *Task)
348:                 	{
349:                 		if(Task != (TASK*)NULL)
350:                 		{
351:                 			if(RAMAddressValid((OS_WORD)Task) == FALSE)
352:                 				return OS_INVALID_ARGUMENT_ADDRESS;
353:                 		}
354:                 
355:                 		EnterCritical();
356:                 
357:                 		if (Task == (TASK*)NULL)
358:                 		{
359:                 			// the TASK is NULL, so make it the current task
360:                 			Task = gCurrentTask;
361:                 		}
362:                 
363:                 		if (OS_SuspendTask(Task) == FALSE)
364:                 		{
365:                 			ExitCritical();
366:                 
367:                 			return OS_INVALID_OBJECT_USED;
368:                 		}
369:                 		
370:                 		// If TaskToSuspend is the currently executing Task or if NULL was passed in, we will Suspend ourselves.
371:                 		if(Task == gCurrentTask)
372:                 			SurrenderCPU();
373:                 	
374:                 	    ExitCritical();
375:                 	    
376:                 		return OS_SUCCESS;
377:                 	}
378:                 #endif // end of USING_SUSPENDED_QUEUE_METHOD
379:                 
380:                 #if (USING_SUSPEND_ALL_TASKS_METHOD == 1)
381:                 	static void OS_SuspendTaskList(DOUBLE_LINKED_LIST_HEAD *TaskList)
382:                 	{
383:                 		DOUBLE_LINKED_LIST_NODE *TaskNode;
384:                 		TASK *TempTask;
385:                 		BOOL TaskSuspended = FALSE;
386:                 
387:                 		do
388:                 		{
389:                 			// if the list is NULL, just return
390:                 			if (TaskList->Beginning == (DOUBLE_LINKED_LIST_NODE*)NULL)
391:                 				return;
392:                 
393:                 			TaskNode = TaskList->Beginning;
394:                 
395:                 			TempTask = (TASK*)TaskNode->Data;
396:                 
397:                 			do
398:                 			{
399:                 				if (TempTask->Suspendable)
400:                 				{
401:                 					OS_SuspendTask(TempTask);
402:                 
403:                 					TaskNode = TaskList->Beginning;
404:                 
405:                 					TaskSuspended = TRUE;
406:                 
407:                 					break;
408:                 				}
409:                 
410:                 				// iterate to the next Task
411:                 				TaskNode = TaskNode->NextNode;
412:                 
413:                 				TempTask = (TASK*)TaskNode->Data;
414:                 			} 
415:                 			while (TaskNode != TaskList->Beginning);
416:                 
417:                 			if (TaskSuspended == FALSE)
418:                 				return;
419:                 
420:                 			TaskSuspended = FALSE;
421:                 		} 
422:                 		while (1);
423:                 	}
424:                 
425:                 	void SuspendAllTasks(BOOL SuspendCurrentTask)
426:                 	{
427:                 		BYTE i;
428:                 		BOOL PriorSuspendProperty;
429:                 
430:                 	    EnterCritical();
431:                 
432:                 		// get this for use later on
433:                 		PriorSuspendProperty = gCurrentTask->Suspendable;
434:                 
435:                 		if (SuspendCurrentTask == FALSE)
436:                 			gCurrentTask->Suspendable = FALSE;
437:                 
438:                 		// go one priority to the next and disable each task if possible
439:                 		for (i = 0; i < HIGHEST_USER_TASK_PRIORITY; i++)
440:                 			OS_SuspendTaskList(&gCPU_Scheduler[i]);
441:                 
442:                 		// now unconditionally set the suspendable property back
443:                 		gCurrentTask->Suspendable = PriorSuspendProperty;
444:                 
445:                 		// give control back to the scheduler to run the next potential task.
446:                 		// worst case is the same task runs and this was uneeded, but oh well.
447:                 		SurrenderCPU();
448:                 
449:                 	    ExitCritical();
450:                 	}
451:                 #endif // end of USING_SUSPEND_ALL_TASKS_METHOD
452:                 
453:                 #if (USING_RESUME_TASK_METHOD == 1)
454:                 	OS_RESULT ResumeTask(TASK *TaskToResume)
455:                 	{
456:                 		OS_RESULT ReturnValue;
457:                 
458:                 		if(RAMAddressValid((OS_WORD)TaskToResume) == FALSE)
459:                 			return OS_INVALID_ARGUMENT_ADDRESS;
460:                 
461:                 	    EnterCritical();
462:                 	
463:                 		// If the Tasks state is SUSPENDED continue along, otherwise its either already READY, or BLOCKED, so just exit.
464:                 		if(TaskToResume->TaskState == SUSPENDED)
465:                 		{
466:                 			OS_RemoveTaskFromList(&TaskToResume->TaskNodeArray[PRIMARY_TASK_NODE]);
467:                 
468:                 			// Add the specified Task to the Ready Queue.
469:                 			if (OS_AddTaskToReadyQueue(TaskToResume))
470:                 			{
471:                 				// the task we added has a higher priority than us
472:                 				SurrenderCPU();
473:                 			}
474:                 			
475:                 			ReturnValue = OS_SUCCESS;
476:                 		}
477:                 		else
478:                 		{
479:                 			ReturnValue = OS_INVALID_TASK_STATE;
480:                 		}
481:                 
482:                 	    ExitCritical();
483:                 	
484:                 		return ReturnValue;
485:                 	}
486:                 #endif // end of USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1
487:                 
488:                 #if (USING_RESUME_ALL_TASKS_METHOD == 1)
489:                 	void ResumeAllTasks(void)
490:                 	{
491:                 		EnterCritical();
492:                 		
493:                 		if (OS_AddTaskListToReadyQueue(&gSuspendedQueueHead))
494:                 			SurrenderCPU();
495:                 		
496:                 		ExitCritical();
497:                 	}
498:                 #endif // end of USING_RESUME_ALL_TASKS_METHOD
499:                 
500:                 #if (USING_DELETE_TASK == 1)
501:                 	OS_RESULT DeleteTask(TASK *Task)
502:                 	{
503:                 		OS_RESULT ReturnValue;
504:                 
505:                 		if(Task != (TASK*)NULL)
506:                 		{
507:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
508:                 			{
509:                 				return OS_INVALID_ARGUMENT_ADDRESS;
510:                 			}
511:                 		}
512:                 		else
513:                 		{
514:                 			Task = gCurrentTask;
515:                 		}
516:                 
517:                 		EnterCritical();
518:                 
519:                 		if(OS_DeleteTask(Task) == TRUE)
520:                 		{
521:                 			if(Task == gCurrentTask)
522:                 				SurrenderCPU();
523:                 	
524:                 			ReturnValue = OS_SUCCESS;
525:                 		}
526:                 		else
527:                 		{
528:                 			ReturnValue = OS_INVALID_OBJECT_USED;
529:                 		}
530:                 
531:                 		ExitCritical();
532:                 
533:                 		return ReturnValue;
534:                 	}
535:                 #endif // end of USING_DELETE_TASK
536:                 
537:                 #if (USING_TASK_DELAY_TICKS_METHOD == 1)
538:                 	OS_RESULT TaskDelayTicks(UINT32 TicksToDelay)
539:                 	{
9D00187C  27BDFFE8   ADDIU SP, SP, -24
9D001880  AFBF0014   SW RA, 20(SP)
9D001884  AFBE0010   SW FP, 16(SP)
9D001888  03A0F021   ADDU FP, SP, ZERO
9D00188C  AFC40018   SW A0, 24(FP)
540:                 		if (TicksToDelay == 0 || TicksToDelay >= INVALID_TIMEOUT_TICKS_VALUE)
9D001890  8FC20018   LW V0, 24(FP)
9D001894  10400005   BEQ V0, ZERO, 0x9D0018AC
9D001898  00000000   NOP
9D00189C  8FC20018   LW V0, 24(FP)
9D0018A0  2C42FFFE   SLTIU V0, V0, -2
9D0018A4  14400004   BNE V0, ZERO, 0x9D0018B8
9D0018A8  00000000   NOP
541:                 			return OS_INVALID_ARGUMENT;
9D0018AC  2402000A   ADDIU V0, ZERO, 10
9D0018B0  0B40063F   J 0x9D0018FC
9D0018B4  00000000   NOP
542:                 
543:                 		EnterCritical();
9D0018B8  0F400F82   JAL EnterCritical
9D0018BC  00000000   NOP
544:                 
545:                 		OS_AddTaskToDelayQueue(gCurrentTask, &gCurrentTask->TaskNodeArray[PRIMARY_TASK_NODE], TicksToDelay, TRUE);
9D0018C0  8F83803C   LW V1, -32708(GP)
9D0018C4  8F82803C   LW V0, -32708(GP)
9D0018C8  00602021   ADDU A0, V1, ZERO
9D0018CC  00402821   ADDU A1, V0, ZERO
9D0018D0  8FC60018   LW A2, 24(FP)
9D0018D4  24070001   ADDIU A3, ZERO, 1
9D0018D8  0F4001DF   JAL OS_AddTaskToDelayQueue
9D0018DC  00000000   NOP
546:                 
547:                 		SurrenderCPU();
9D0018E0  0F400C2D   JAL SurrenderCPU
9D0018E4  00000000   NOP
548:                 
549:                 		// clear out the tick counter before leaving
550:                 		gCurrentTask->DelayInTicks = 0;
9D0018E8  8F82803C   LW V0, -32708(GP)
9D0018EC  AC400030   SW ZERO, 48(V0)
551:                 
552:                 		ExitCritical();
9D0018F0  0F400F95   JAL ExitCritical
9D0018F4  00000000   NOP
553:                 
554:                 		return OS_SUCCESS;
9D0018F8  00001021   ADDU V0, ZERO, ZERO
555:                 	}
9D0018FC  03C0E821   ADDU SP, FP, ZERO
9D001900  8FBF0014   LW RA, 20(SP)
9D001904  8FBE0010   LW FP, 16(SP)
9D001908  27BD0018   ADDIU SP, SP, 24
9D00190C  03E00008   JR RA
9D001910  00000000   NOP
556:                 #endif // end of USING_TASK_DELAY_TICKS_METHOD
557:                 	
558:                 #if (USING_TASK_DELAY_MILLISECONDS_METHOD == 1)
559:                 	OS_RESULT TaskDelayMilliseconds(UINT32 MillisecondsToDelay)
560:                 	{
561:                 		if (MillisecondsToDelay == 0 || MillisecondsToDelay >= INVALID_TIMEOUT_TICKS_VALUE)
562:                 			return OS_INVALID_ARGUMENT;
563:                 
564:                 		EnterCritical();
565:                 
566:                 		OS_AddTaskToDelayQueue(gCurrentTask, &gCurrentTask->TaskNodeArray[PRIMARY_TASK_NODE], (UINT32)GetNumberOfTicksPerMillisecond() * MillisecondsToDelay, TRUE);
567:                 
568:                 		SurrenderCPU();
569:                 
570:                 		#if (USING_TASK_DELAY_TICKS_METHOD == 1)
571:                 			// clear out the tick counter before leaving
572:                 			gCurrentTask->DelayInTicks = 0;
573:                 		#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
574:                 
575:                 		ExitCritical();
576:                 
577:                 		return OS_SUCCESS;
578:                 	}
579:                 #endif // end of USING_TASK_DELAY_MILLISECONDS_METHOD
580:                 
581:                 /*
582:                 -----------------------------------------------------------------------------------------------------------------------------------------------------
583:                 	Nothing below this line has been tested as of yet!!! February 16, 2018.
584:                 -----------------------------------------------------------------------------------------------------------------------------------------------------
585:                 */
586:                 
587:                 #if (USING_TASK_CHECK_IN == 1)
588:                 	extern DOUBLE_LINKED_LIST_HEAD gTaskCheckInList;
589:                 
590:                 	OS_RESULT SetupTaskCheckIn(UINT32 TaskCheckInPeriodicityInTicks)
591:                 	{
592:                 		if (TaskCheckInPeriodicityInTicks <= 1)
593:                 			return OS_INVALID_ARGUMENT;
594:                 	
595:                 		EnterCritical();
596:                 
597:                 		if (gCurrentTask->TaskCheckIn != (TASK_CHECK_IN*)NULL)
598:                 		{
599:                 			ExitCritical();
600:                 
601:                 			return OS_INVALID_OBJECT_USED;
602:                 		}
603:                 
604:                 		gCurrentTask->TaskCheckIn = (TASK_CHECK_IN*)AllocateMemory(sizeof(TASK_CHECK_IN));
605:                 	
606:                 		if(gCurrentTask->TaskCheckIn == (TASK_CHECK_IN*)NULL)
607:                 		{
608:                 			ExitCritical();
609:                 
610:                 			return OS_ALLOCATE_MEMORY_FAILED;
611:                 		}
612:                 	
613:                 		gCurrentTask->TaskCheckIn->Timeout = TaskCheckInPeriodicityInTicks;
614:                 		gCurrentTask->TaskCheckIn->CurrentCount = 0;
615:                 
616:                 		OS_InitializeTaskNode(&(gCurrentTask->TaskCheckIn->TaskCheckInNode), (void*)gCurrentTask);
617:                 		
618:                 		// now add it to the check in list
619:                 		OS_AddTaskToList(&gTaskCheckInList, &(gCurrentTask->TaskCheckIn->TaskCheckInNode));
620:                 
621:                 		ExitCritical();
622:                 	
623:                 		return OS_SUCCESS;
624:                 	}
625:                 
626:                 	OS_RESULT TaskCheckIn(void)
627:                 	{
628:                 		EnterCritical();
629:                 
630:                 		if (gCurrentTask->TaskCheckIn == (TASK_CHECK_IN*)NULL)
631:                 		{
632:                 			ExitCritical();
633:                 
634:                 			return OS_INVALID_OBJECT_USED;
635:                 		}
636:                 
637:                 		gCurrentTask->TaskCheckIn->CurrentCount = 0;
638:                 
639:                 		ExitCritical();
640:                 
641:                 		return OS_SUCCESS;
642:                 	}
643:                 #endif // end of USING_TASK_CHECK_IN
644:                 
645:                 #if (USING_TASK_HIBERNATION == 1)
646:                 	OS_RESULT HibernateTask(TASK *Task)
647:                 	{
648:                 		if (Task != (TASK*)NULL)
649:                 		{
650:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
651:                 				return OS_INVALID_ARGUMENT_ADDRESS;
652:                 		}
653:                 		else
654:                 		{
655:                 			Task = gCurrentTask;
656:                 		}
657:                 
658:                 		EnterCritical();
659:                 
660:                 		if (Task->TaskState != READY)
661:                 		{
662:                 			ExitCritical();
663:                 
664:                 			return OS_INVALID_TASK_STATE;
665:                 		}
666:                 
667:                 		OS_PlaceTaskOnBlockedList(Task, &gHibernationQueueHead, &Task->TaskNodeArray[PRIMARY_TASK_NODE], HIBERNATING, TRUE);
668:                 
669:                 		ExitCritical();
670:                 
671:                 		return OS_SUCCESS;
672:                 	}
673:                 
674:                 	OS_RESULT WakeTask(TASK *Task)
675:                 	{
676:                 		if (RAMAddressValid((OS_WORD)Task) == FALSE)
677:                 			return OS_INVALID_ARGUMENT_ADDRESS;
678:                 
679:                 		EnterCritical();
680:                 
681:                 		if (Task->TaskState != HIBERNATING)
682:                 		{
683:                 			ExitCritical();
684:                 
685:                 			return OS_INVALID_TASK_STATE;
686:                 		}
687:                 
688:                 		// remove the task from the hibernation list
689:                 		OS_RemoveTaskFromList(&Task->TaskNodeArray[PRIMARY_TASK_NODE]);
690:                 
691:                 		// Remove the Task from the Suspended List.
692:                 		if (OS_AddTaskToReadyQueue(Task))
693:                 			SurrenderCPU();
694:                 
695:                 		ExitCritical();
696:                 
697:                 		return OS_SUCCESS;
698:                 	}
699:                 #endif // end of USING_TASK_HIBERNATION
700:                 
701:                 #if (USING_TASK_NAMES == 1)
702:                 	BYTE *GetTaskName(TASK *Task)
703:                 	{
704:                 		if (Task != (TASK*)NULL)
705:                 		{
706:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
707:                 				return (BYTE*)NULL;
708:                 		}
709:                 		else
710:                 		{
711:                 			Task = gCurrentTask;
712:                 		}
713:                 
714:                 		return Task->TaskName;
715:                 	}
716:                 #endif // end of USING_TASK_NAMES
717:                 
718:                 #if (USING_CHANGE_TASK_PRIORITY_METHOD == 1)
719:                 	OS_RESULT ChangeTaskPriority(TASK *Task, BYTE Priority)
720:                 	{
721:                 		if (Priority > HIGHEST_USER_TASK_PRIORITY)
722:                 			return OS_INVALID_ARGUMENT;
723:                 
724:                 		if (Task != (TASK*)NULL)
725:                 		{
726:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
727:                 			{
728:                 				return OS_INVALID_ARGUMENT_ADDRESS;
729:                 			}
730:                 		}
731:                 		else
732:                 		{
733:                 			Task = gCurrentTask;
734:                 		}
735:                 
736:                 		EnterCritical();
737:                 
738:                 		if (OS_ChangeTaskPriority(Task, Priority) == TRUE)
739:                 			SurrenderCPU();
740:                 
741:                 		ExitCritical();
742:                 
743:                 		return OS_SUCCESS;
744:                 	}
745:                 #endif // end of USING_CHANGE_TASK_PRIORITY_METHOD
746:                 
747:                 #if (USING_RESTART_TASK == 1)
748:                 	OS_RESULT RestartTask(TASK *Task)
749:                 	{
750:                 		OS_RESULT ReturnValue;
751:                 
752:                 		if (Task != (TASK*)NULL)
753:                 		{
754:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
755:                 				return OS_INVALID_ARGUMENT_ADDRESS;
756:                 		}
757:                 		else
758:                 		{
759:                 			Task = gCurrentTask;
760:                 		}
761:                 
762:                 		EnterCritical();
763:                 
764:                 		if (RAMAddressValid((OS_WORD)(Task->RestartInfo)) == FALSE)
765:                 		{
766:                 			ReturnValue = OS_INVALID_OBJECT_USED;
767:                 		}
768:                 		else
769:                 		{
770:                 			if (OS_RestartTask(Task) == TRUE)
771:                 			{
772:                 				if (Task == gCurrentTask)
773:                 					SurrenderCPU();
774:                 
775:                 				ReturnValue = OS_SUCCESS;
776:                 			}
777:                 			else
778:                 			{
779:                 				ReturnValue = OS_INVALID_OBJECT_USED;
780:                 			}
781:                 		}
782:                 
783:                 		ExitCritical();
784:                 
785:                 		return ReturnValue;
786:                 	}
787:                 #endif // end of USING_RESTART_TASK
788:                 
789:                 #if (USING_GET_TASK_PRIORITY_METHOD == 1)
790:                 	BYTE GetTaskPriority(TASK *Task)
791:                 	{
792:                 		BYTE TaskPriority;
793:                 
794:                 		if (Task != (TASK*)NULL)
795:                 		{
796:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
797:                 				return INVALID_TASK_PRIORITY;
798:                 		}
799:                 
800:                 		EnterCritical();
801:                 
802:                 		if (Task == (TASK*)NULL)
803:                 			Task = gCurrentTask;
804:                 
805:                 		TaskPriority = Task->TaskPriority;
806:                 
807:                 		ExitCritical();
808:                 
809:                 		return TaskPriority;
810:                 	}
811:                 #endif // end of USING_GET_TASK_PRIORITY_METHOD
812:                 
813:                 #if (USING_TASK_SIGNAL == 1)
814:                 	void OS_WaitOnSignals(SIGNALS *TaskSignals, UINT16 SignalsToWaitOn)
815:                 	{
9D001914  27BDFFF8   ADDIU SP, SP, -8
9D001918  AFBE0004   SW FP, 4(SP)
9D00191C  03A0F021   ADDU FP, SP, ZERO
9D001920  AFC40008   SW A0, 8(FP)
9D001924  00A01021   ADDU V0, A1, ZERO
9D001928  A7C2000C   SH V0, 12(FP)
816:                 		TaskSignals->SignalFlags.WaitOnSignals = SignalsToWaitOn;
9D00192C  8FC20008   LW V0, 8(FP)
9D001930  97C3000C   LHU V1, 12(FP)
9D001934  A4430000   SH V1, 0(V0)
817:                 
818:                 		TaskSignals->SignalFlags.CurrentlySetSignals = 0;
9D001938  8FC20008   LW V0, 8(FP)
9D00193C  A4400002   SH ZERO, 2(V0)
819:                 	}
9D001940  03C0E821   ADDU SP, FP, ZERO
9D001944  8FBE0004   LW FP, 4(SP)
9D001948  27BD0008   ADDIU SP, SP, 8
9D00194C  03E00008   JR RA
9D001950  00000000   NOP
820:                 
821:                 	void OS_BlockOnSignals(TASK *Task, BYTE TaskNodeIndex, BOOL RemoveFromReadyQueue)
822:                 	{
9D001954  27BDFFE0   ADDIU SP, SP, -32
9D001958  AFBF001C   SW RA, 28(SP)
9D00195C  AFBE0018   SW FP, 24(SP)
9D001960  03A0F021   ADDU FP, SP, ZERO
9D001964  AFC40020   SW A0, 32(FP)
9D001968  00A01021   ADDU V0, A1, ZERO
9D00196C  AFC60028   SW A2, 40(FP)
9D001970  A3C20024   SB V0, 36(FP)
823:                 		OS_PlaceTaskOnBlockedList(Task, &gSignalWaitTaskList, &Task->TaskNodeArray[TaskNodeIndex], BLOCKED, RemoveFromReadyQueue);
9D001974  8FC30020   LW V1, 32(FP)
9D001978  93C20024   LBU V0, 36(FP)
9D00197C  00021100   SLL V0, V0, 4
9D001980  00621021   ADDU V0, V1, V0
9D001984  8FC30028   LW V1, 40(FP)
9D001988  AFA30010   SW V1, 16(SP)
9D00198C  8FC40020   LW A0, 32(FP)
9D001990  27858034   ADDIU A1, GP, -32716
9D001994  00403021   ADDU A2, V0, ZERO
9D001998  24070001   ADDIU A3, ZERO, 1
9D00199C  0F40028E   JAL OS_PlaceTaskOnBlockedList
9D0019A0  00000000   NOP
824:                 	}
9D0019A4  03C0E821   ADDU SP, FP, ZERO
9D0019A8  8FBF001C   LW RA, 28(SP)
9D0019AC  8FBE0018   LW FP, 24(SP)
9D0019B0  27BD0020   ADDIU SP, SP, 32
9D0019B4  03E00008   JR RA
9D0019B8  00000000   NOP
825:                 
826:                 	BOOL OS_SetTaskSignals(TASK *Task, SIGNALS *TaskSignals, UINT16 SignalsToSet)
827:                 	{
9D0019BC  27BDFFE0   ADDIU SP, SP, -32
9D0019C0  AFBF001C   SW RA, 28(SP)
9D0019C4  AFBE0018   SW FP, 24(SP)
9D0019C8  03A0F021   ADDU FP, SP, ZERO
9D0019CC  AFC40020   SW A0, 32(FP)
9D0019D0  AFC50024   SW A1, 36(FP)
9D0019D4  00C01021   ADDU V0, A2, ZERO
9D0019D8  A7C20028   SH V0, 40(FP)
828:                 		// It is possible that the TASK was set to the READY state if a timeout occurred.
829:                 		// So we must check that it is in the BLOCKED state prior to mucking with the signal bits.
830:                 		if (Task->TaskState == BLOCKED)
9D0019DC  8FC20020   LW V0, 32(FP)
9D0019E0  8C430024   LW V1, 36(V0)
9D0019E4  24020001   ADDIU V0, ZERO, 1
9D0019E8  1462002A   BNE V1, V0, 0x9D001A94
9D0019EC  00000000   NOP
831:                 		{
832:                 			// set the new signals
833:                 			TaskSignals->SignalFlags.CurrentlySetSignals |= SignalsToSet;
9D0019F0  8FC20024   LW V0, 36(FP)
9D0019F4  94430002   LHU V1, 2(V0)
9D0019F8  97C20028   LHU V0, 40(FP)
9D0019FC  00621025   OR V0, V1, V0
9D001A00  3043FFFF   ANDI V1, V0, -1
9D001A04  8FC20024   LW V0, 36(FP)
9D001A08  A4430002   SH V1, 2(V0)
834:                 
835:                 			// if they all match, wake the TASK and leave
836:                 			if ((TaskSignals->SignalFlags.WaitOnSignals & TaskSignals->SignalFlags.CurrentlySetSignals) == TaskSignals->SignalFlags.WaitOnSignals)
9D001A0C  8FC20024   LW V0, 36(FP)
9D001A10  94430000   LHU V1, 0(V0)
9D001A14  8FC20024   LW V0, 36(FP)
9D001A18  94420002   LHU V0, 2(V0)
9D001A1C  00621024   AND V0, V1, V0
9D001A20  3043FFFF   ANDI V1, V0, -1
9D001A24  8FC20024   LW V0, 36(FP)
9D001A28  94420000   LHU V0, 0(V0)
9D001A2C  14620019   BNE V1, V0, 0x9D001A94
9D001A30  00000000   NOP
837:                 			{
838:                 				UINT32 i;
839:                 
840:                 				// remove all the nodes from any lists they were on
841:                 				for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
9D001A34  AFC00010   SW ZERO, 16(FP)
9D001A38  0B40069A   J 0x9D001A68
9D001A3C  00000000   NOP
9D001A5C  8FC20010   LW V0, 16(FP)
9D001A60  24420001   ADDIU V0, V0, 1
9D001A64  AFC20010   SW V0, 16(FP)
9D001A68  8FC20010   LW V0, 16(FP)
9D001A6C  2C420002   SLTIU V0, V0, 2
9D001A70  1440FFF3   BNE V0, ZERO, 0x9D001A40
9D001A74  00000000   NOP
842:                 					OS_RemoveTaskFromList(&Task->TaskNodeArray[i]);
9D001A40  8FC30020   LW V1, 32(FP)
9D001A44  8FC20010   LW V0, 16(FP)
9D001A48  00021100   SLL V0, V0, 4
9D001A4C  00621021   ADDU V0, V1, V0
9D001A50  00402021   ADDU A0, V0, ZERO
9D001A54  0F4002D6   JAL OS_RemoveTaskFromList
9D001A58  00000000   NOP
843:                 
844:                 				// clear out the wait on signals to clear the resource
845:                 				TaskSignals->SignalFlags.WaitOnSignals = 0;
9D001A78  8FC20024   LW V0, 36(FP)
9D001A7C  A4400000   SH ZERO, 0(V0)
846:                 
847:                 				return OS_AddTaskToReadyQueue(Task);
9D001A80  8FC40020   LW A0, 32(FP)
9D001A84  0F4001F8   JAL OS_AddTaskToReadyQueue
9D001A88  00000000   NOP
9D001A8C  0B4006A6   J 0x9D001A98
9D001A90  00000000   NOP
848:                 			}
849:                 		}
850:                 
851:                 		return FALSE;
9D001A94  00001021   ADDU V0, ZERO, ZERO
852:                 	}
9D001A98  03C0E821   ADDU SP, FP, ZERO
9D001A9C  8FBF001C   LW RA, 28(SP)
9D001AA0  8FBE0018   LW FP, 24(SP)
9D001AA4  27BD0020   ADDIU SP, SP, 32
9D001AA8  03E00008   JR RA
9D001AAC  00000000   NOP
853:                 
854:                 	OS_RESULT TaskWaitOnSignals(UINT16 SignalsToWaitOn
855:                 
856:                 								#if (USING_TASK_DELAY_TICKS_METHOD == 1)
857:                 									, UINT32 TicksToDelay
858:                 								#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
859:                 		
860:                 								)
861:                 	{
9D001AB0  27BDFFE0   ADDIU SP, SP, -32
9D001AB4  AFBF001C   SW RA, 28(SP)
9D001AB8  AFBE0018   SW FP, 24(SP)
9D001ABC  03A0F021   ADDU FP, SP, ZERO
9D001AC0  00801021   ADDU V0, A0, ZERO
9D001AC4  AFC50024   SW A1, 36(FP)
9D001AC8  A7C20020   SH V0, 32(FP)
862:                 		OS_RESULT Result = OS_SUCCESS;
9D001ACC  AFC00010   SW ZERO, 16(FP)
863:                 
864:                 		if (SignalsToWaitOn == 0)
9D001AD0  97C20020   LHU V0, 32(FP)
9D001AD4  14400004   BNE V0, ZERO, 0x9D001AE8
9D001AD8  00000000   NOP
865:                 			return OS_INVALID_ARGUMENT;
9D001ADC  2402000A   ADDIU V0, ZERO, 10
9D001AE0  0B4006E5   J 0x9D001B94
9D001AE4  00000000   NOP
866:                 
867:                 		EnterCritical();
9D001AE8  0F400F82   JAL EnterCritical
9D001AEC  00000000   NOP
868:                 
869:                 		// set the signals bits
870:                 		OS_WaitOnSignals(&gCurrentTask->TaskSignal.UserSignals, SignalsToWaitOn);
9D001AF0  8F82803C   LW V0, -32708(GP)
9D001AF4  24430034   ADDIU V1, V0, 52
9D001AF8  97C20020   LHU V0, 32(FP)
9D001AFC  00602021   ADDU A0, V1, ZERO
9D001B00  00402821   ADDU A1, V0, ZERO
9D001B04  0F400645   JAL OS_WaitOnSignals
9D001B08  00000000   NOP
871:                 
872:                 		// now go to blocked state and wait for them to be set
873:                 		OS_BlockOnSignals(gCurrentTask, PRIMARY_TASK_NODE, TRUE);
9D001B0C  8F82803C   LW V0, -32708(GP)
9D001B10  00402021   ADDU A0, V0, ZERO
9D001B14  00002821   ADDU A1, ZERO, ZERO
9D001B18  24060001   ADDIU A2, ZERO, 1
9D001B1C  0F400655   JAL OS_BlockOnSignals
9D001B20  00000000   NOP
874:                 
875:                 		#if (USING_TASK_DELAY_TICKS_METHOD == 1)
876:                 			if (TicksToDelay > 0)
9D001B24  8FC20024   LW V0, 36(FP)
9D001B28  1040000A   BEQ V0, ZERO, 0x9D001B54
9D001B2C  00000000   NOP
877:                 				OS_AddTaskToDelayQueue(gCurrentTask, &gCurrentTask->TaskNodeArray[SECONDARY_TASK_NODE], TicksToDelay, FALSE);
9D001B30  8F83803C   LW V1, -32708(GP)
9D001B34  8F82803C   LW V0, -32708(GP)
9D001B38  24420010   ADDIU V0, V0, 16
9D001B3C  00602021   ADDU A0, V1, ZERO
9D001B40  00402821   ADDU A1, V0, ZERO
9D001B44  8FC60024   LW A2, 36(FP)
9D001B48  00003821   ADDU A3, ZERO, ZERO
9D001B4C  0F4001DF   JAL OS_AddTaskToDelayQueue
9D001B50  00000000   NOP
878:                 		#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
879:                 
880:                 		SurrenderCPU();
9D001B54  0F400C2D   JAL SurrenderCPU
9D001B58  00000000   NOP
881:                 
882:                 		#if (USING_TASK_DELAY_TICKS_METHOD == 1)
883:                 			// we must clear the wait signals since we could have been awoken by the 
884:                 			// timeout expiring and not our signals being set.
885:                 			gCurrentTask->TaskSignal.UserSignals.SignalFlags.WaitOnSignals = 0;
9D001B5C  8F82803C   LW V0, -32708(GP)
9D001B60  A4400034   SH ZERO, 52(V0)
886:                 
887:                 			// check to see if we timed out before all the signals were set
888:                 			if (gCurrentTask->DelayInTicks == TASK_TIMEOUT_DONE_VALUE)
9D001B64  8F82803C   LW V0, -32708(GP)
9D001B68  8C430030   LW V1, 48(V0)
9D001B6C  2402FFFF   ADDIU V0, ZERO, -1
9D001B70  14620003   BNE V1, V0, 0x9D001B80
9D001B74  00000000   NOP
889:                 			{
890:                 				// we timed out
891:                 				Result = OS_TASK_TIMEOUT;
9D001B78  2402000C   ADDIU V0, ZERO, 12
9D001B7C  AFC20010   SW V0, 16(FP)
892:                 			}
893:                 
894:                 			// clear out the tick counter before leaving
895:                 			gCurrentTask->DelayInTicks = 0;
9D001B80  8F82803C   LW V0, -32708(GP)
9D001B84  AC400030   SW ZERO, 48(V0)
896:                 		#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
897:                 
898:                 		ExitCritical();
9D001B88  0F400F95   JAL ExitCritical
9D001B8C  00000000   NOP
899:                 
900:                 		return Result;
9D001B90  8FC20010   LW V0, 16(FP)
901:                 	}
9D001B94  03C0E821   ADDU SP, FP, ZERO
9D001B98  8FBF001C   LW RA, 28(SP)
9D001B9C  8FBE0018   LW FP, 24(SP)
9D001BA0  27BD0020   ADDIU SP, SP, 32
9D001BA4  03E00008   JR RA
9D001BA8  00000000   NOP
902:                 
903:                 	OS_RESULT TaskGetSetSignals(TASK *Task, UINT16 *SignalsSet)
904:                 	{
9D001BAC  27BDFFE8   ADDIU SP, SP, -24
9D001BB0  AFBF0014   SW RA, 20(SP)
9D001BB4  AFBE0010   SW FP, 16(SP)
9D001BB8  03A0F021   ADDU FP, SP, ZERO
9D001BBC  AFC40018   SW A0, 24(FP)
9D001BC0  AFC5001C   SW A1, 28(FP)
905:                 		if (Task != (TASK*)NULL)
9D001BC4  8FC20018   LW V0, 24(FP)
9D001BC8  1040000A   BEQ V0, ZERO, 0x9D001BF4
9D001BCC  00000000   NOP
906:                 		{
907:                 			if (RAMAddressValid((OS_WORD)Task) == FALSE)
9D001BD0  8FC20018   LW V0, 24(FP)
9D001BD4  00402021   ADDU A0, V0, ZERO
9D001BD8  0F400544   JAL RAMAddressValid
9D001BDC  00000000   NOP
9D001BE0  14400004   BNE V0, ZERO, 0x9D001BF4
9D001BE4  00000000   NOP
908:                 				return OS_INVALID_ARGUMENT_ADDRESS;
9D001BE8  24020009   ADDIU V0, ZERO, 9
9D001BEC  0B400714   J 0x9D001C50
9D001BF0  00000000   NOP
909:                 		}
910:                 
911:                 		if (RAMAddressValid((OS_WORD)SignalsSet) == FALSE)
9D001BF4  8FC2001C   LW V0, 28(FP)
9D001BF8  00402021   ADDU A0, V0, ZERO
9D001BFC  0F400544   JAL RAMAddressValid
9D001C00  00000000   NOP
9D001C04  14400004   BNE V0, ZERO, 0x9D001C18
9D001C08  00000000   NOP
912:                 			return OS_INVALID_ARGUMENT_ADDRESS;
9D001C0C  24020009   ADDIU V0, ZERO, 9
9D001C10  0B400714   J 0x9D001C50
9D001C14  00000000   NOP
913:                 
914:                 		EnterCritical();
9D001C18  0F400F82   JAL EnterCritical
9D001C1C  00000000   NOP
915:                 
916:                 		if (Task == (TASK*)NULL)
9D001C20  8FC20018   LW V0, 24(FP)
9D001C24  14400003   BNE V0, ZERO, 0x9D001C34
9D001C28  00000000   NOP
917:                 			Task = gCurrentTask;
9D001C2C  8F82803C   LW V0, -32708(GP)
9D001C30  AFC20018   SW V0, 24(FP)
918:                 
919:                 		*SignalsSet = Task->TaskSignal.UserSignals.SignalFlags.CurrentlySetSignals;
9D001C34  8FC20018   LW V0, 24(FP)
9D001C38  94430036   LHU V1, 54(V0)
9D001C3C  8FC2001C   LW V0, 28(FP)
9D001C40  A4430000   SH V1, 0(V0)
920:                 
921:                 		ExitCritical();
9D001C44  0F400F95   JAL ExitCritical
9D001C48  00000000   NOP
922:                 
923:                 		return OS_SUCCESS;
9D001C4C  00001021   ADDU V0, ZERO, ZERO
924:                 	}
9D001C50  03C0E821   ADDU SP, FP, ZERO
9D001C54  8FBF0014   LW RA, 20(SP)
9D001C58  8FBE0010   LW FP, 16(SP)
9D001C5C  27BD0018   ADDIU SP, SP, 24
9D001C60  03E00008   JR RA
9D001C64  00000000   NOP
925:                 
926:                 	OS_RESULT SignalTask(TASK *Task, UINT16 SignalsToSet)
927:                 	{
9D001C68  27BDFFE0   ADDIU SP, SP, -32
9D001C6C  AFBF001C   SW RA, 28(SP)
9D001C70  AFBE0018   SW FP, 24(SP)
9D001C74  03A0F021   ADDU FP, SP, ZERO
9D001C78  AFC40020   SW A0, 32(FP)
9D001C7C  00A01021   ADDU V0, A1, ZERO
9D001C80  A7C20024   SH V0, 36(FP)
928:                 		OS_RESULT Result;
929:                 
930:                 		if (RAMAddressValid((OS_WORD)Task) == FALSE)
9D001C84  8FC20020   LW V0, 32(FP)
9D001C88  00402021   ADDU A0, V0, ZERO
9D001C8C  0F400544   JAL RAMAddressValid
9D001C90  00000000   NOP
9D001C94  14400004   BNE V0, ZERO, 0x9D001CA8
9D001C98  00000000   NOP
931:                 			return OS_INVALID_ARGUMENT_ADDRESS;
9D001C9C  24020009   ADDIU V0, ZERO, 9
9D001CA0  0B400753   J 0x9D001D4C
9D001CA4  00000000   NOP
932:                 
933:                 		EnterCritical();
9D001CA8  0F400F82   JAL EnterCritical
9D001CAC  00000000   NOP
934:                 
935:                 		// if the OS is using signals, the user signals will be ignored
936:                 		if (Task->TaskSignal.OS_Signals.SignalFlags.WaitOnSignals == 0)
9D001CB0  8FC20020   LW V0, 32(FP)
9D001CB4  94420038   LHU V0, 56(V0)
9D001CB8  1440001F   BNE V0, ZERO, 0x9D001D38
9D001CBC  00000000   NOP
937:                 		{
938:                 			if (Task->TaskSignal.UserSignals.SignalFlags.WaitOnSignals == 0 || Task->TaskState != BLOCKED)
9D001CC0  8FC20020   LW V0, 32(FP)
9D001CC4  94420034   LHU V0, 52(V0)
9D001CC8  10400006   BEQ V0, ZERO, 0x9D001CE4
9D001CCC  00000000   NOP
9D001CD0  8FC20020   LW V0, 32(FP)
9D001CD4  8C430024   LW V1, 36(V0)
9D001CD8  24020001   ADDIU V0, ZERO, 1
9D001CDC  10620005   BEQ V1, V0, 0x9D001CF4
9D001CE0  00000000   NOP
939:                 			{
940:                 				// the TASK is not currently waiting for any signals, do not set them
941:                 				Result = OS_INVALID_TASK_STATE;
9D001CE4  2402000F   ADDIU V0, ZERO, 15
9D001CE8  AFC20010   SW V0, 16(FP)
9D001CEC  0B400750   J 0x9D001D40
9D001CF0  00000000   NOP
942:                 			}
943:                 			else
944:                 			{
945:                 				// proceed to set the requested signals
946:                 				if (OS_SetTaskSignals(Task, &Task->TaskSignal.UserSignals, SignalsToSet) == TRUE)
9D001CF4  8FC20020   LW V0, 32(FP)
9D001CF8  24430034   ADDIU V1, V0, 52
9D001CFC  97C20024   LHU V0, 36(FP)
9D001D00  8FC40020   LW A0, 32(FP)
9D001D04  00602821   ADDU A1, V1, ZERO
9D001D08  00403021   ADDU A2, V0, ZERO
9D001D0C  0F40066F   JAL OS_SetTaskSignals
9D001D10  00000000   NOP
9D001D14  00401821   ADDU V1, V0, ZERO
9D001D18  24020001   ADDIU V0, ZERO, 1
9D001D1C  14620003   BNE V1, V0, 0x9D001D2C
9D001D20  00000000   NOP
947:                 					SurrenderCPU();
9D001D24  0F400C2D   JAL SurrenderCPU
9D001D28  00000000   NOP
948:                 
949:                 				Result = OS_SUCCESS;
9D001D2C  AFC00010   SW ZERO, 16(FP)
9D001D30  0B400750   J 0x9D001D40
9D001D34  00000000   NOP
950:                 			}
951:                 		}
952:                 		else
953:                 		{
954:                 			// the OS was using signals
955:                 			Result = OS_RESOURCE_IN_USE;
9D001D38  24020005   ADDIU V0, ZERO, 5
9D001D3C  AFC20010   SW V0, 16(FP)
956:                 		}
957:                 
958:                 		ExitCritical();
9D001D40  0F400F95   JAL ExitCritical
9D001D44  00000000   NOP
959:                 
960:                 		return Result;
9D001D48  8FC20010   LW V0, 16(FP)
961:                 	}
9D001D4C  03C0E821   ADDU SP, FP, ZERO
9D001D50  8FBF001C   LW RA, 28(SP)
9D001D54  8FBE0018   LW FP, 24(SP)
9D001D58  27BD0020   ADDIU SP, SP, 32
9D001D5C  03E00008   JR RA
9D001D60  00000000   NOP
962:                 #endif // end of #if (USING_TASK_SIGNAL == 1)
963:                 
964:                 #if (USING_TASK_GET_STATE_METHOD == 1)
965:                 	OS_RESULT TaskGetState(TASK *Task, TASK_STATE *TaskState)
966:                 	{
9D001D64  27BDFFE8   ADDIU SP, SP, -24
9D001D68  AFBF0014   SW RA, 20(SP)
9D001D6C  AFBE0010   SW FP, 16(SP)
9D001D70  03A0F021   ADDU FP, SP, ZERO
9D001D74  AFC40018   SW A0, 24(FP)
9D001D78  AFC5001C   SW A1, 28(FP)
967:                 		if (RAMAddressValid((OS_WORD)Task) == FALSE)
9D001D7C  8FC20018   LW V0, 24(FP)
9D001D80  00402021   ADDU A0, V0, ZERO
9D001D84  0F400544   JAL RAMAddressValid
9D001D88  00000000   NOP
9D001D8C  14400004   BNE V0, ZERO, 0x9D001DA0
9D001D90  00000000   NOP
968:                 			return OS_INVALID_ARGUMENT_ADDRESS;
9D001D94  24020009   ADDIU V0, ZERO, 9
9D001D98  0B40077A   J 0x9D001DE8
9D001D9C  00000000   NOP
969:                 
970:                 		if (RAMAddressValid((OS_WORD)TaskState) == FALSE)
9D001DA0  8FC2001C   LW V0, 28(FP)
9D001DA4  00402021   ADDU A0, V0, ZERO
9D001DA8  0F400544   JAL RAMAddressValid
9D001DAC  00000000   NOP
9D001DB0  14400004   BNE V0, ZERO, 0x9D001DC4
9D001DB4  00000000   NOP
971:                 			return OS_INVALID_ARGUMENT_ADDRESS;
9D001DB8  24020009   ADDIU V0, ZERO, 9
9D001DBC  0B40077A   J 0x9D001DE8
9D001DC0  00000000   NOP
972:                 
973:                 		EnterCritical();
9D001DC4  0F400F82   JAL EnterCritical
9D001DC8  00000000   NOP
974:                 
975:                 		*TaskState = Task->TaskState;
9D001DCC  8FC20018   LW V0, 24(FP)
9D001DD0  8C430024   LW V1, 36(V0)
9D001DD4  8FC2001C   LW V0, 28(FP)
9D001DD8  AC430000   SW V1, 0(V0)
976:                 
977:                 		ExitCritical();
9D001DDC  0F400F95   JAL ExitCritical
9D001DE0  00000000   NOP
978:                 
979:                 		return OS_SUCCESS;
9D001DE4  00001021   ADDU V0, ZERO, ZERO
980:                 	}
9D001DE8  03C0E821   ADDU SP, FP, ZERO
981:                 #endif // end of #if (USING_TASK_GET_STATE_METHOD == 1)
---  c:/users/ben.danametrics/desktop/nexos/project/port.c  ---------------------------------------------
1:                   /*
2:                    * Port.c
3:                    *
4:                    *  Created on: Feb 5, 2018
5:                    *      Author: Ben
6:                    */
7:                   //#include <plib.h>
8:                   
9:                   #include <GenericTypeDefs.h>
10:                  
11:                  #include "HardwareProfile.h"
12:                  #include "Port.h"
13:                  
14:                  void __attribute__((interrupt(ipl1), vector(_CORE_TIMER_VECTOR))) ContextSwitch(void);
15:                  
16:                  void __attribute__((interrupt(ipl2), vector(_CORE_SOFTWARE_0_VECTOR))) ContextSwitch(void);
17:                  
18:                  void PortStartOSScheduler(void)
19:                  {
9D002E30  27BDFFE8   ADDIU SP, SP, -24
9D002E34  AFBF0014   SW RA, 20(SP)
9D002E38  AFBE0010   SW FP, 16(SP)
9D002E3C  03A0F021   ADDU FP, SP, ZERO
20:                      // configure the core software interrupt, this is used for SurrenderCPU()
21:                      INTSetVectorPriority(INT_CORE_SOFTWARE_0_VECTOR, INT_PRIORITY_LEVEL_2);
9D002E40  24040001   ADDIU A0, ZERO, 1
9D002E44  24050002   ADDIU A1, ZERO, 2
9D002E48  0F400FF2   JAL INTSetVectorPriority
9D002E4C  00000000   NOP
22:                      INTSetVectorSubPriority(INT_CORE_SOFTWARE_0_VECTOR, INT_SUB_PRIORITY_LEVEL_0);
9D002E50  24040001   ADDIU A0, ZERO, 1
9D002E54  00002821   ADDU A1, ZERO, ZERO
9D002E58  0F401000   JAL INTSetVectorSubPriority
9D002E5C  00000000   NOP
23:                  
24:                      INTClearFlag(INT_CS0);
9D002E60  24040001   ADDIU A0, ZERO, 1
9D002E64  0F40103F   JAL INTClearFlag
9D002E68  00000000   NOP
25:                      INTEnable(INT_CS0, INT_ENABLED);
9D002E6C  24040001   ADDIU A0, ZERO, 1
9D002E70  24050001   ADDIU A1, ZERO, 1
9D002E74  0F400FA8   JAL INTEnable
9D002E78  00000000   NOP
26:                  
27:                      // configure up the core timer interrupt, this is the RTOS Tick
28:                      INTSetVectorPriority(INT_CORE_TIMER_VECTOR, INT_PRIORITY_LEVEL_1);
9D002E7C  00002021   ADDU A0, ZERO, ZERO
9D002E80  24050001   ADDIU A1, ZERO, 1
9D002E84  0F400FF2   JAL INTSetVectorPriority
9D002E88  00000000   NOP
29:                      INTSetVectorSubPriority(INT_CORE_TIMER_VECTOR, INT_SUB_PRIORITY_LEVEL_0);
9D002E8C  00002021   ADDU A0, ZERO, ZERO
9D002E90  00002821   ADDU A1, ZERO, ZERO
9D002E94  0F401000   JAL INTSetVectorSubPriority
9D002E98  00000000   NOP
30:                  
31:                      OpenCoreTimer(GetInstructionClock() / 2 / OS_TICK_RATE_IN_HZ);
9D002E9C  34049C40   ORI A0, ZERO, -25536
9D002EA0  0F401096   JAL OpenCoreTimer
9D002EA4  00000000   NOP
32:                  
33:                      INTClearFlag(INT_CT);
9D002EA8  00002021   ADDU A0, ZERO, ZERO
9D002EAC  0F40103F   JAL INTClearFlag
9D002EB0  00000000   NOP
34:                      INTEnable(INT_CT, INT_ENABLED);
9D002EB4  00002021   ADDU A0, ZERO, ZERO
9D002EB8  24050001   ADDIU A1, ZERO, 1
9D002EBC  0F400FA8   JAL INTEnable
9D002EC0  00000000   NOP
35:                  
36:                      INTEnableSystemMultiVectoredInt();
9D002EC4  0F40101C   JAL INTEnableSystemMultiVectoredInt
9D002EC8  00000000   NOP
37:                      INTEnableInterrupts();
9D002ECC  0F401099   JAL INTEnableInterrupts
9D002ED0  00000000   NOP
38:                  }
9D002ED4  03C0E821   ADDU SP, FP, ZERO
9D002ED8  8FBF0014   LW RA, 20(SP)
9D002EDC  8FBE0010   LW FP, 16(SP)
9D002EE0  27BD0018   ADDIU SP, SP, 24
9D002EE4  03E00008   JR RA
9D002EE8  00000000   NOP
39:                  
40:                  OS_WORD *PortInitializeTaskStack(OS_WORD *Stack, UINT32 StackSizeInWords, TASK_ENTRY_POINT StartingAddress, void *Args)
41:                  {
9D002EEC  27BDFFE0   ADDIU SP, SP, -32
9D002EF0  AFBF001C   SW RA, 28(SP)
9D002EF4  AFBE0018   SW FP, 24(SP)
9D002EF8  03A0F021   ADDU FP, SP, ZERO
9D002EFC  AFC40020   SW A0, 32(FP)
9D002F00  AFC50024   SW A1, 36(FP)
9D002F04  AFC60028   SW A2, 40(FP)
9D002F08  AFC7002C   SW A3, 44(FP)
42:                      // Get the Stack pointer to point to the end of the allocated area
43:                      //Stack += (StackSizeInWords - 2); // this is known to work (assumingly)
44:                      //Stack = (OS_WORD*)((OS_WORD)Stack & (OS_WORD)~7);
45:                  
46:                      //The below code is untested, but allegedly you need the stack aligned to the nearest 8 byte boundary...
47:                  
48:                      // point to the end of the stack
49:                      Stack += StackSizeInWords - 1;
9D002F0C  8FC20024   LW V0, 36(FP)
9D002F10  2442FFFF   ADDIU V0, V0, -1
9D002F14  00021080   SLL V0, V0, 2
9D002F18  8FC30020   LW V1, 32(FP)
9D002F1C  00621021   ADDU V0, V1, V0
9D002F20  AFC20020   SW V0, 32(FP)
50:                  
51:                      // now make it 8 byte aligned
52:                      Stack = (OS_WORD*)((OS_WORD)Stack & (OS_WORD)~7);
9D002F24  8FC30020   LW V1, 32(FP)
9D002F28  2402FFF8   ADDIU V0, ZERO, -8
9D002F2C  00621024   AND V0, V1, V0
9D002F30  AFC20020   SW V0, 32(FP)
53:                  
54:                      int i;
55:                  
56:                      for(i = 0; i < 30; i++)
9D002F34  AFC00010   SW ZERO, 16(FP)
9D002F38  0B400BF3   J 0x9D002FCC
9D002F3C  00000000   NOP
9D002FC0  8FC20010   LW V0, 16(FP)
9D002FC4  24420001   ADDIU V0, V0, 1
9D002FC8  AFC20010   SW V0, 16(FP)
9D002FCC  8FC20010   LW V0, 16(FP)
9D002FD0  2842001E   SLTI V0, V0, 30
9D002FD4  1440FFDA   BNE V0, ZERO, 0x9D002F40
9D002FD8  00000000   NOP
57:                      {
58:                          if(i == 27)
9D002F40  8FC30010   LW V1, 16(FP)
9D002F44  2402001B   ADDIU V0, ZERO, 27
9D002F48  1462000B   BNE V1, V0, 0x9D002F78
9D002F4C  00000000   NOP
59:                          {
60:                              *Stack-- =  (OS_WORD)GetGP();// This is the Global pointer value. (OS_WORD)GetGP();
9D002F50  0F400D74   JAL GetGP
9D002F54  00000000   NOP
9D002F58  00401821   ADDU V1, V0, ZERO
9D002F5C  8FC20020   LW V0, 32(FP)
9D002F60  AC430000   SW V1, 0(V0)
9D002F64  8FC20020   LW V0, 32(FP)
9D002F68  2442FFFC   ADDIU V0, V0, -4
9D002F6C  AFC20020   SW V0, 32(FP)
9D002F70  0B400BF0   J 0x9D002FC0
9D002F74  00000000   NOP
61:                          }
62:                          else
63:                          {
64:                              if(i == 3)
9D002F78  8FC30010   LW V1, 16(FP)
9D002F7C  24020003   ADDIU V0, ZERO, 3
9D002F80  14620009   BNE V1, V0, 0x9D002FA8
9D002F84  00000000   NOP
65:                              {
66:                                  *Stack-- = (OS_WORD)Args;
9D002F88  8FC3002C   LW V1, 44(FP)
9D002F8C  8FC20020   LW V0, 32(FP)
9D002F90  AC430000   SW V1, 0(V0)
9D002F94  8FC20020   LW V0, 32(FP)
9D002F98  2442FFFC   ADDIU V0, V0, -4
9D002F9C  AFC20020   SW V0, 32(FP)
9D002FA0  0B400BF0   J 0x9D002FC0
9D002FA4  00000000   NOP
67:                              }
68:                              else
69:                              {
70:                                  *Stack-- = i;
9D002FA8  8FC30010   LW V1, 16(FP)
9D002FAC  8FC20020   LW V0, 32(FP)
9D002FB0  AC430000   SW V1, 0(V0)
9D002FB4  8FC20020   LW V0, 32(FP)
9D002FB8  2442FFFC   ADDIU V0, V0, -4
9D002FBC  AFC20020   SW V0, 32(FP)
71:                              }
72:                          }
73:                      }
74:                  
75:                      *Stack-- = (OS_WORD)StartingAddress;
9D002FDC  8FC30028   LW V1, 40(FP)
9D002FE0  8FC20020   LW V0, 32(FP)
9D002FE4  AC430000   SW V1, 0(V0)
9D002FE8  8FC20020   LW V0, 32(FP)
9D002FEC  2442FFFC   ADDIU V0, V0, -4
9D002FF0  AFC20020   SW V0, 32(FP)
76:                  
77:                      // Starting SR value for a Task
78:                      *Stack-- = 0x00000003;
9D002FF4  8FC20020   LW V0, 32(FP)
9D002FF8  24030003   ADDIU V1, ZERO, 3
9D002FFC  AC430000   SW V1, 0(V0)
9D003000  8FC20020   LW V0, 32(FP)
9D003004  2442FFFC   ADDIU V0, V0, -4
9D003008  AFC20020   SW V0, 32(FP)
79:                  
80:                      // The high and lo registers.
81:                      *Stack-- = 0;
9D00300C  8FC20020   LW V0, 32(FP)
9D003010  AC400000   SW ZERO, 0(V0)
9D003014  8FC20020   LW V0, 32(FP)
9D003018  2442FFFC   ADDIU V0, V0, -4
9D00301C  AFC20020   SW V0, 32(FP)
82:                      *Stack-- = 0;
9D003020  8FC20020   LW V0, 32(FP)
9D003024  AC400000   SW ZERO, 0(V0)
9D003028  8FC20020   LW V0, 32(FP)
9D00302C  2442FFFC   ADDIU V0, V0, -4
9D003030  AFC20020   SW V0, 32(FP)
83:                  
84:                      return Stack;
9D003034  8FC20020   LW V0, 32(FP)
85:                  }
9D003038  03C0E821   ADDU SP, FP, ZERO
9D00303C  8FBF001C   LW RA, 28(SP)
9D003040  8FBE0018   LW FP, 24(SP)
9D003044  27BD0020   ADDIU SP, SP, 32
9D003048  03E00008   JR RA
9D00304C  00000000   NOP
86:                  
87:                  void PortSetInterruptPriority(BYTE NewInterruptPriority)
88:                  {
9D003050  27BDFFF0   ADDIU SP, SP, -16
9D003054  AFBE000C   SW FP, 12(SP)
9D003058  03A0F021   ADDU FP, SP, ZERO
9D00305C  00801021   ADDU V0, A0, ZERO
9D003060  A3C20010   SB V0, 16(FP)
89:                      OS_WORD NewStatus;
90:                  
91:                      NewStatus = _CP0_GET_STATUS();
9D003064  40026000   MFC0 V0, Status
9D003068  AFC20000   SW V0, 0(FP)
92:                  
93:                      NewStatus &= ~(0x3F << 10);
9D00306C  8FC30000   LW V1, 0(FP)
9D003070  3C02FFFF   LUI V0, -1
9D003074  344203FF   ORI V0, V0, 1023
9D003078  00621024   AND V0, V1, V0
9D00307C  AFC20000   SW V0, 0(FP)
94:                  
95:                      NewStatus |= (NewInterruptPriority << 10);
9D003080  93C20010   LBU V0, 16(FP)
9D003084  00021280   SLL V0, V0, 10
9D003088  8FC30000   LW V1, 0(FP)
9D00308C  00621025   OR V0, V1, V0
9D003090  AFC20000   SW V0, 0(FP)
96:                  
97:                      _CP0_SET_STATUS(NewStatus);
9D003094  8FC20000   LW V0, 0(FP)
9D003098  40826000   MTC0 V0, Status
9D00309C  000000C0   EHB
98:                  }
9D0030A0  03C0E821   ADDU SP, FP, ZERO
9D0030A4  8FBE000C   LW FP, 12(SP)
9D0030A8  27BD0010   ADDIU SP, SP, 16
9D0030AC  03E00008   JR RA
9D0030B0  00000000   NOP
99:                  
100:                 void SurrenderCPU(void)
101:                 {
9D0030B4  27BDFFE8   ADDIU SP, SP, -24
9D0030B8  AFBF0014   SW RA, 20(SP)
9D0030BC  AFBE0010   SW FP, 16(SP)
9D0030C0  03A0F021   ADDU FP, SP, ZERO
102:                     CoreSetSoftwareInterrupt0();			
9D0030C4  0F40108F   JAL CoreSetSoftwareInterrupt0
9D0030C8  00000000   NOP
103:                 
104:                     Nop();									
9D0030CC  00000040   SSNOP
105:                     Nop();									
9D0030D0  00000040   SSNOP
106:                     Nop();									
9D0030D4  00000040   SSNOP
107:                     Nop();
9D0030D8  00000040   SSNOP
108:                 }
9D0030DC  03C0E821   ADDU SP, FP, ZERO
---  c:/users/ben.danametrics/desktop/nexos/project/memory.c  -------------------------------------------
1:                   #include <stdlib.h>
2:                   
3:                   #include "Memory.h"
4:                   #include "CriticalSections.h"
5:                   #include "RTOSConfig.h"
6:                   #include "Kernel.h"
7:                   #include "Callbacks.h"
8:                   
9:                   #if (USING_MEMORY_WARNING_CLEAR_EVENT == 1 || USING_MEMORY_WARNING_EVENT == 1)
10:                  	#include "Events.h"
11:                  #endif // end of 
12:                  
13:                  #if (OS_HEAP_SIZE_IN_BYTES < (OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES + OS_WORD_SIZE_IN_BYTES))
14:                  	#error "OS_HEAP_SIZE_IN_BYTES must be defined and be larger than 8 or 12 bytes!"
15:                  #endif // end of OS_HEAP_SIZE_IN_BYTES < sizeof(OS_MEMORY_BLOCK_HEADER) + sizeof(WORD)
16:                  
17:                  #if (OS_HEAP_SIZE_IN_BYTES % OS_WORD_SIZE_IN_BYTES)
18:                  	#error "OS_HEAP_SIZE_IN_BYTES must be word aligned!"
19:                  #endif // end of OS_HEAP_SIZE_IN_BYTES % sizeof(WORD)
20:                  
21:                  #if (OS_HEAP_SIZE_IN_BYTES > 2147483648)
22:                  	#error "OS_HEAP_SIZE_IN_BYTES too big.  It cannot exceed 2,147,483,648!"
23:                  #endif // end of OS_HEAP_SIZE_IN_BYTES % sizeof(WORD)
24:                  
25:                  #if (USING_MEMORY_WARNING_EVENT == 1 || USING_MEMORY_WARNING_USER_CALLBACK == 1)
26:                  	BOOL gMemoryWarning = FALSE;
27:                  #endif // end of USING_MEMORY_WARNING_EVENT == 1 || USING_MEMORY_WARNING_USER_CALLBACK == 1
28:                  
29:                  static OS_WORD gKernelManagedMemory[((OS_HEAP_SIZE_IN_BYTES + OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES) / OS_WORD_SIZE_IN_BYTES)];
30:                  static UINT32 gHeapUsedInBytes = 0;
31:                  
32:                  static OS_MEMORY_BLOCK_HEADER *OS_IterateMemoryBlockHeader(OS_MEMORY_BLOCK_HEADER *MemoryBlock)
33:                  {
9D000BD0  27BDFFF8   ADDIU SP, SP, -8
9D000BD4  AFBE0004   SW FP, 4(SP)
9D000BD8  03A0F021   ADDU FP, SP, ZERO
9D000BDC  AFC40008   SW A0, 8(FP)
34:                  	// Iterate to the next memory block
35:                  	MemoryBlock += ((MemoryBlock->SizeInWords * 4) / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES + 1);
9D000BE0  8FC20008   LW V0, 8(FP)
9D000BE4  8C420000   LW V0, 0(V0)
9D000BE8  7C42F000   EXT V0, V0, 0, 31
9D000BEC  00021080   SLL V0, V0, 2
9D000BF0  24430003   ADDIU V1, V0, 3
9D000BF4  28440000   SLTI A0, V0, 0
9D000BF8  0064100B   MOVN V0, V1, A0
9D000BFC  00021083   SRA V0, V0, 2
9D000C00  24420001   ADDIU V0, V0, 1
9D000C04  00021080   SLL V0, V0, 2
9D000C08  8FC30008   LW V1, 8(FP)
9D000C0C  00621021   ADDU V0, V1, V0
9D000C10  AFC20008   SW V0, 8(FP)
36:                  
37:                  	// check to see if we have reached the end of the heap, if so return (void*)NULL
38:                  	if (MemoryBlock >= (OS_MEMORY_BLOCK_HEADER*)&(gKernelManagedMemory[(OS_HEAP_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES)]))
9D000C14  3C02A000   LUI V0, -24576
9D000C18  24430280   ADDIU V1, V0, 640
9D000C1C  3402C350   ORI V0, ZERO, -15536
9D000C20  00621021   ADDU V0, V1, V0
9D000C24  8FC30008   LW V1, 8(FP)
9D000C28  0062102B   SLTU V0, V1, V0
9D000C2C  14400004   BNE V0, ZERO, 0x9D000C40
9D000C30  00000000   NOP
39:                  	{
40:                  		return (OS_MEMORY_BLOCK_HEADER*)NULL;
9D000C34  00001021   ADDU V0, ZERO, ZERO
9D000C38  0B400311   J 0x9D000C44
9D000C3C  00000000   NOP
41:                  	}
42:                  
43:                  	return MemoryBlock;
9D000C40  8FC20008   LW V0, 8(FP)
44:                  }
9D000C44  03C0E821   ADDU SP, FP, ZERO
9D000C48  8FBE0004   LW FP, 4(SP)
9D000C4C  27BD0008   ADDIU SP, SP, 8
9D000C50  03E00008   JR RA
9D000C54  00000000   NOP
45:                  
46:                  BOOL OS_InitializeHeap(void)
47:                  {
9D000C58  27BDFFE0   ADDIU SP, SP, -32
9D000C5C  AFBF001C   SW RA, 28(SP)
9D000C60  AFBE0018   SW FP, 24(SP)
9D000C64  03A0F021   ADDU FP, SP, ZERO
48:                  	OS_MEMORY_BLOCK_HEADER *MemoryBlockIterator = (OS_MEMORY_BLOCK_HEADER*)gKernelManagedMemory;
9D000C68  3C02A000   LUI V0, -24576
9D000C6C  24420280   ADDIU V0, V0, 640
9D000C70  AFC20010   SW V0, 16(FP)
49:                  
50:                  	// make the first block not allocated
51:                  	MemoryBlockIterator->Allocated = 0;
9D000C74  8FC30010   LW V1, 16(FP)
9D000C78  8C620000   LW V0, 0(V1)
9D000C7C  7C02FFC4   INS V0, ZERO, 31, 1
9D000C80  AC620000   SW V0, 0(V1)
52:                  
53:                  	MemoryBlockIterator->SizeInWords = (OS_HEAP_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES);
9D000C84  8FC30010   LW V1, 16(FP)
9D000C88  8C620000   LW V0, 0(V1)
9D000C8C  240430D4   ADDIU A0, ZERO, 12500
9D000C90  7C82F004   INS V0, A0, 0, 31
9D000C94  AC620000   SW V0, 0(V1)
54:                  
55:                  	#if(CLEAR_HEAP_AT_START_UP == 1)
56:                  		memset(&gKernelManagedMemory[1], HEAP_INITIALIZATION_VALUE, (OS_HEAP_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES));
9D000C98  3C02A000   LUI V0, -24576
9D000C9C  24420284   ADDIU V0, V0, 644
9D000CA0  00402021   ADDU A0, V0, ZERO
9D000CA4  00002821   ADDU A1, ZERO, ZERO
9D000CA8  240630D4   ADDIU A2, ZERO, 12500
9D000CAC  0F400F30   JAL memset
9D000CB0  00000000   NOP
57:                  	#endif // end of #if(CLEAR_HEAP_AT_START_UP == 1)
58:                  
59:                  	return TRUE;
9D000CB4  24020001   ADDIU V0, ZERO, 1
60:                  }
9D000CB8  03C0E821   ADDU SP, FP, ZERO
9D000CBC  8FBF001C   LW RA, 28(SP)
9D000CC0  8FBE0018   LW FP, 24(SP)
9D000CC4  27BD0020   ADDIU SP, SP, 32
9D000CC8  03E00008   JR RA
9D000CCC  00000000   NOP
61:                  
62:                  void *OS_AllocateMemory(UINT32 SizeInBytes)
63:                  {
9D000CD0  27BDFFD8   ADDIU SP, SP, -40
9D000CD4  AFBF0024   SW RA, 36(SP)
9D000CD8  AFBE0020   SW FP, 32(SP)
9D000CDC  03A0F021   ADDU FP, SP, ZERO
9D000CE0  AFC40028   SW A0, 40(FP)
64:                  	UINT32 RequestedSizeInWords;
65:                  	void *StartingMemoryAddress;
66:                  	OS_MEMORY_BLOCK_HEADER *MemoryBlockIterator;
67:                  
68:                  	if (SizeInBytes == 0)
9D000CE4  8FC20028   LW V0, 40(FP)
9D000CE8  14400004   BNE V0, ZERO, 0x9D000CFC
9D000CEC  00000000   NOP
69:                  		return (void*)NULL;
9D000CF0  00001021   ADDU V0, ZERO, ZERO
9D000CF4  0B4003BB   J 0x9D000EEC
9D000CF8  00000000   NOP
70:                  
71:                  	StartingMemoryAddress = (void*)NULL;
9D000CFC  AFC00010   SW ZERO, 16(FP)
72:                  	MemoryBlockIterator = (OS_MEMORY_BLOCK_HEADER*)gKernelManagedMemory;
9D000D00  3C02A000   LUI V0, -24576
9D000D04  24420280   ADDIU V0, V0, 640
9D000D08  AFC20014   SW V0, 20(FP)
73:                  
74:                  	// the request has to be at least OS_WORD_SIZE_IN_BYTES large
75:                  	if (SizeInBytes < OS_WORD_SIZE_IN_BYTES)
9D000D0C  8FC20028   LW V0, 40(FP)
9D000D10  2C420004   SLTIU V0, V0, 4
9D000D14  10400003   BEQ V0, ZERO, 0x9D000D24
9D000D18  00000000   NOP
76:                  		SizeInBytes = OS_WORD_SIZE_IN_BYTES;
9D000D1C  24020004   ADDIU V0, ZERO, 4
9D000D20  AFC20028   SW V0, 40(FP)
77:                  
78:                  	// make it evenly divisible by OS_WORD_SIZE_IN_BYTES
79:                  	if ((SizeInBytes % OS_WORD_SIZE_IN_BYTES) != 0)
9D000D24  8FC20028   LW V0, 40(FP)
9D000D28  30420003   ANDI V0, V0, 3
9D000D2C  10400006   BEQ V0, ZERO, 0x9D000D48
9D000D30  00000000   NOP
80:                  		SizeInBytes += (OS_WORD_SIZE_IN_BYTES - (SizeInBytes % OS_WORD_SIZE_IN_BYTES));
9D000D34  8FC30028   LW V1, 40(FP)
9D000D38  2402FFFC   ADDIU V0, ZERO, -4
9D000D3C  00621024   AND V0, V1, V0
9D000D40  24420004   ADDIU V0, V0, 4
9D000D44  AFC20028   SW V0, 40(FP)
81:                  
82:                  	// first normalize the request to words, and make it a value thats word aligned
83:                  	RequestedSizeInWords = SizeInBytes / OS_WORD_SIZE_IN_BYTES;
9D000D48  8FC20028   LW V0, 40(FP)
9D000D4C  00021082   SRL V0, V0, 2
9D000D50  AFC20018   SW V0, 24(FP)
84:                  
85:                  	while (1)
86:                  	{
87:                  		// While the current memory block is allocated keep searching
88:                  		while (MemoryBlockIterator->Allocated)
9D000D54  0B400361   J 0x9D000D84
9D000D58  00000000   NOP
9D000D84  8FC20014   LW V0, 20(FP)
9D000D88  8C430000   LW V1, 0(V0)
9D000D8C  3C028000   LUI V0, -32768
9D000D90  00621024   AND V0, V1, V0
9D000D94  1440FFF1   BNE V0, ZERO, 0x9D000D5C
9D000D98  00000000   NOP
9D000E28  0B400361   J 0x9D000D84
9D000E2C  00000000   NOP
89:                  		{
90:                  			// check to see if we have reached the end of the heap, if so return (void*)NULL
91:                  			if ((MemoryBlockIterator = OS_IterateMemoryBlockHeader(MemoryBlockIterator)) == (OS_MEMORY_BLOCK_HEADER*)NULL)
9D000D5C  8FC40014   LW A0, 20(FP)
9D000D60  0F4002F4   JAL OS_IterateMemoryBlockHeader
9D000D64  00000000   NOP
9D000D68  AFC20014   SW V0, 20(FP)
9D000D6C  8FC20014   LW V0, 20(FP)
9D000D70  14400004   BNE V0, ZERO, 0x9D000D84
9D000D74  00000000   NOP
92:                  			{
93:                  				return (void*)NULL;
9D000D78  00001021   ADDU V0, ZERO, ZERO
9D000D7C  0B4003BB   J 0x9D000EEC
9D000D80  00000000   NOP
94:                  			}
95:                  		}
96:                  
97:                  		// lets see if we found a winner, if so then lets break out of this loop
98:                  		if (MemoryBlockIterator->SizeInWords >= RequestedSizeInWords)
9D000D9C  8FC20014   LW V0, 20(FP)
9D000DA0  8C420000   LW V0, 0(V0)
9D000DA4  7C42F000   EXT V0, V0, 0, 31
9D000DA8  00401821   ADDU V1, V0, ZERO
9D000DAC  8FC20018   LW V0, 24(FP)
9D000DB0  0062102B   SLTU V0, V1, V0
9D000DB4  14400011   BNE V0, ZERO, 0x9D000DFC
9D000DB8  00000000   NOP
99:                  			break;
100:                 
101:                 		// check to see if we have reached the end of the heap, if so return (void*)NULL
102:                 		if ((MemoryBlockIterator = OS_IterateMemoryBlockHeader(MemoryBlockIterator)) == (OS_MEMORY_BLOCK_HEADER*)NULL)
9D000DFC  8FC40014   LW A0, 20(FP)
9D000E00  0F4002F4   JAL OS_IterateMemoryBlockHeader
9D000E04  00000000   NOP
9D000E08  AFC20014   SW V0, 20(FP)
9D000E0C  8FC20014   LW V0, 20(FP)
9D000E10  14400004   BNE V0, ZERO, 0x9D000E24
9D000E14  00000000   NOP
103:                 		{
104:                 			return (void*)NULL;
9D000E18  00001021   ADDU V0, ZERO, ZERO
9D000E1C  0B4003BB   J 0x9D000EEC
9D000E20  00000000   NOP
105:                 		}
106:                 	}
9D000E24  00000000   NOP
107:                 
108:                 	MemoryBlockIterator->Allocated = TRUE;
9D000DBC  8FC30014   LW V1, 20(FP)
9D000DC0  8C620000   LW V0, 0(V1)
9D000DC4  24040001   ADDIU A0, ZERO, 1
9D000DC8  7C82FFC4   INS V0, A0, 31, 1
9D000DCC  AC620000   SW V0, 0(V1)
109:                 
110:                 	// Now check to see if there is enough room in this memory block to make another one, otherwise just add on the
111:                 	// space to the current memory block
112:                 
113:                 	if (MemoryBlockIterator->SizeInWords >= (RequestedSizeInWords + ((OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES) + 1)))
9D000DD0  8FC20014   LW V0, 20(FP)
9D000DD4  8C420000   LW V0, 0(V0)
9D000DD8  7C42F000   EXT V0, V0, 0, 31
9D000DDC  00401821   ADDU V1, V0, ZERO
9D000DE0  8FC20018   LW V0, 24(FP)
9D000DE4  24420002   ADDIU V0, V0, 2
9D000DE8  0062102B   SLTU V0, V1, V0
9D000DEC  10400010   BEQ V0, ZERO, 0x9D000E30
9D000DF0  00000000   NOP
9D000DF4  0B4003B0   J 0x9D000EC0
9D000DF8  00000000   NOP
114:                 	{
115:                 		// Theres enough room in the current memory block to allocate at least the space requested another OS_MEMORY_BLOCK_HEADER
116:                 		// and 1 word
117:                 		// Just need to save this for the time being
118:                 		UINT32 Space = MemoryBlockIterator->SizeInWords;
9D000E30  8FC20014   LW V0, 20(FP)
9D000E34  8C420000   LW V0, 0(V0)
9D000E38  7C42F000   EXT V0, V0, 0, 31
9D000E3C  AFC2001C   SW V0, 28(FP)
119:                 		MemoryBlockIterator->SizeInWords = RequestedSizeInWords;
9D000E40  8FC20018   LW V0, 24(FP)
9D000E44  7C44F000   EXT A0, V0, 0, 31
9D000E48  8FC30014   LW V1, 20(FP)
9D000E4C  8C620000   LW V0, 0(V1)
9D000E50  7C82F004   INS V0, A0, 0, 31
9D000E54  AC620000   SW V0, 0(V1)
120:                 
121:                 		// Iterate to the open space that will be allocated
122:                 		MemoryBlockIterator++;
9D000E58  8FC20014   LW V0, 20(FP)
9D000E5C  24420004   ADDIU V0, V0, 4
9D000E60  AFC20014   SW V0, 20(FP)
123:                 		StartingMemoryAddress = (void*)MemoryBlockIterator;
9D000E64  8FC20014   LW V0, 20(FP)
9D000E68  AFC20010   SW V0, 16(FP)
124:                 
125:                 		// Iterate the MemoryBlockIterator to the end of the newly allocated space
126:                 		MemoryBlockIterator += (SizeInBytes / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES);
9D000E6C  8FC20028   LW V0, 40(FP)
9D000E70  00021082   SRL V0, V0, 2
9D000E74  00021080   SLL V0, V0, 2
9D000E78  8FC30014   LW V1, 20(FP)
9D000E7C  00621021   ADDU V0, V1, V0
9D000E80  AFC20014   SW V0, 20(FP)
127:                 		MemoryBlockIterator->Allocated = FALSE;
9D000E84  8FC30014   LW V1, 20(FP)
9D000E88  8C620000   LW V0, 0(V1)
9D000E8C  7C02FFC4   INS V0, ZERO, 31, 1
9D000E90  AC620000   SW V0, 0(V1)
128:                 		MemoryBlockIterator->SizeInWords = (Space - RequestedSizeInWords - (OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES));
9D000E94  8FC3001C   LW V1, 28(FP)
9D000E98  8FC20018   LW V0, 24(FP)
9D000E9C  00621023   SUBU V0, V1, V0
9D000EA0  2442FFFF   ADDIU V0, V0, -1
9D000EA4  7C44F000   EXT A0, V0, 0, 31
9D000EA8  8FC30014   LW V1, 20(FP)
9D000EAC  8C620000   LW V0, 0(V1)
9D000EB0  7C82F004   INS V0, A0, 0, 31
9D000EB4  AC620000   SW V0, 0(V1)
9D000EB8  0B4003B5   J 0x9D000ED4
9D000EBC  00000000   NOP
129:                 	}
130:                 	else
131:                 	{
132:                 		MemoryBlockIterator++;
9D000EC0  8FC20014   LW V0, 20(FP)
9D000EC4  24420004   ADDIU V0, V0, 4
9D000EC8  AFC20014   SW V0, 20(FP)
133:                 		StartingMemoryAddress = (void*)(MemoryBlockIterator);
9D000ECC  8FC20014   LW V0, 20(FP)
9D000ED0  AFC20010   SW V0, 16(FP)
134:                 	}
135:                 
136:                 	gHeapUsedInBytes += SizeInBytes + sizeof(OS_MEMORY_BLOCK_HEADER);
9D000ED4  8F838028   LW V1, -32728(GP)
9D000ED8  8FC20028   LW V0, 40(FP)
9D000EDC  00621021   ADDU V0, V1, V0
9D000EE0  24420004   ADDIU V0, V0, 4
9D000EE4  AF828028   SW V0, -32728(GP)
137:                 
138:                 	#if (USING_MEMORY_WARNING_EVENT == 1 || USING_MEMORY_WARNING_USER_CALLBACK == 1)
139:                 		if (gMemoryWarning == FALSE)
140:                 		{
141:                 			if (gHeapUsedInBytes > MEMORY_WARNING_LEVEL)
142:                 			{
143:                 				gMemoryWarning = TRUE;
144:                 
145:                 				#if (USING_MEMORY_WARNING_USER_CALLBACK == 1)
146:                 						MemoryWarningUserCallback(gHeapUsedInBytes);
147:                 				#endif // end of USING_MEMORY_WARNING_USER_CALLBACK
148:                 
149:                 				#if (USING_MEMORY_WARNING_EVENT == 1)
150:                 						OS_RaiseEvent(MEMORY_WARNING_EVENT);
151:                 				#endif // end of USING_MEMORY_WARNING_EVENT == 1
152:                 			}
153:                 		}
154:                 	#endif // end of USING_MEMORY_WARNING_EVENT == 1 || USING_MEMORY_WARNING_USER_CALLBACK == 1
155:                 
156:                 	return (void*)StartingMemoryAddress;
9D000EE8  8FC20010   LW V0, 16(FP)
157:                 }
9D000EEC  03C0E821   ADDU SP, FP, ZERO
9D000EF0  8FBF0024   LW RA, 36(SP)
9D000EF4  8FBE0020   LW FP, 32(SP)
9D000EF8  27BD0028   ADDIU SP, SP, 40
9D000EFC  03E00008   JR RA
9D000F00  00000000   NOP
158:                 
159:                 BOOL OS_ReleaseMemory(void *Ptr)
160:                 {
9D000F04  27BDFFD8   ADDIU SP, SP, -40
9D000F08  AFBF0024   SW RA, 36(SP)
9D000F0C  AFBE0020   SW FP, 32(SP)
9D000F10  03A0F021   ADDU FP, SP, ZERO
9D000F14  AFC40028   SW A0, 40(FP)
161:                 	OS_MEMORY_BLOCK_HEADER *MemoryBlockIterator;
162:                 	OS_MEMORY_BLOCK_HEADER *MemoryBlockIterator2;
163:                 
164:                 	if (AddressInHeap((OS_WORD)Ptr) == FALSE)
9D000F18  8FC20028   LW V0, 40(FP)
9D000F1C  00402021   ADDU A0, V0, ZERO
9D000F20  0F40050C   JAL AddressInHeap
9D000F24  00000000   NOP
9D000F28  14400004   BNE V0, ZERO, 0x9D000F3C
9D000F2C  00000000   NOP
165:                 		return FALSE;
9D000F30  00001021   ADDU V0, ZERO, ZERO
9D000F34  0B40044E   J 0x9D001138
9D000F38  00000000   NOP
166:                 
167:                 	MemoryBlockIterator = (OS_MEMORY_BLOCK_HEADER*)Ptr;
9D000F3C  8FC20028   LW V0, 40(FP)
9D000F40  AFC20010   SW V0, 16(FP)
168:                 
169:                 	// Back up to where the memory block resides in memory
170:                 	MemoryBlockIterator--;
9D000F44  8FC20010   LW V0, 16(FP)
9D000F48  2442FFFC   ADDIU V0, V0, -4
9D000F4C  AFC20010   SW V0, 16(FP)
171:                 
172:                 	MemoryBlockIterator2 = MemoryBlockIterator;
9D000F50  8FC20010   LW V0, 16(FP)
9D000F54  AFC20014   SW V0, 20(FP)
173:                 
174:                 	// Record the amount of bytes that were in block and subtract them, we may be able to get rid of the header later on
175:                 	gHeapUsedInBytes -= (MemoryBlockIterator->SizeInWords * 4);
9D000F58  8FC20010   LW V0, 16(FP)
9D000F5C  8C420000   LW V0, 0(V0)
9D000F60  7C42F000   EXT V0, V0, 0, 31
9D000F64  00401821   ADDU V1, V0, ZERO
9D000F68  00001021   ADDU V0, ZERO, ZERO
9D000F6C  00431023   SUBU V0, V0, V1
9D000F70  00021080   SLL V0, V0, 2
9D000F74  00401821   ADDU V1, V0, ZERO
9D000F78  8F828028   LW V0, -32728(GP)
9D000F7C  00621021   ADDU V0, V1, V0
9D000F80  AF828028   SW V0, -32728(GP)
176:                 
177:                 	// Unallocate the memory block
178:                 	MemoryBlockIterator->Allocated = FALSE;
9D000F84  8FC30010   LW V1, 16(FP)
9D000F88  8C620000   LW V0, 0(V1)
9D000F8C  7C02FFC4   INS V0, ZERO, 31, 1
9D000F90  AC620000   SW V0, 0(V1)
179:                 
180:                 	// jump to the potential next memory block
181:                 	MemoryBlockIterator += ((MemoryBlockIterator->SizeInWords * 4) / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES) + 1;
9D000F94  8FC20010   LW V0, 16(FP)
9D000F98  8C420000   LW V0, 0(V0)
9D000F9C  7C42F000   EXT V0, V0, 0, 31
9D000FA0  00021080   SLL V0, V0, 2
9D000FA4  24430003   ADDIU V1, V0, 3
9D000FA8  28440000   SLTI A0, V0, 0
9D000FAC  0064100B   MOVN V0, V1, A0
9D000FB0  00021083   SRA V0, V0, 2
9D000FB4  24420001   ADDIU V0, V0, 1
9D000FB8  00021080   SLL V0, V0, 2
9D000FBC  8FC30010   LW V1, 16(FP)
9D000FC0  00621021   ADDU V0, V1, V0
9D000FC4  AFC20010   SW V0, 16(FP)
182:                 
183:                 	// We must check to see if the block after us is allocated, lets see if we jump out of bounds
184:                 	if (MemoryBlockIterator < (OS_MEMORY_BLOCK_HEADER*)&(gKernelManagedMemory[(OS_HEAP_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES)]))
9D000FC8  3C02A000   LUI V0, -24576
9D000FCC  24430280   ADDIU V1, V0, 640
9D000FD0  3402C350   ORI V0, ZERO, -15536
9D000FD4  00621021   ADDU V0, V1, V0
9D000FD8  8FC30010   LW V1, 16(FP)
9D000FDC  0062102B   SLTU V0, V1, V0
9D000FE0  10400018   BEQ V0, ZERO, 0x9D001044
9D000FE4  00000000   NOP
185:                 	{
186:                 		// If we're in here we haven't jumped out of bounds, and the memory block is valid.  Lets see if its allocated
187:                 		// if so then we're going to merge it.
188:                 		if (!MemoryBlockIterator->Allocated)
9D000FE8  8FC20010   LW V0, 16(FP)
9D000FEC  8C430000   LW V1, 0(V0)
9D000FF0  3C028000   LUI V0, -32768
9D000FF4  00621024   AND V0, V1, V0
9D000FF8  14400012   BNE V0, ZERO, 0x9D001044
9D000FFC  00000000   NOP
189:                 		{
190:                 			// subtract the size of one header from the heap used since we're merging 2 blocks
191:                 			gHeapUsedInBytes -= sizeof(OS_MEMORY_BLOCK_HEADER);
9D001000  8F828028   LW V0, -32728(GP)
9D001004  2442FFFC   ADDIU V0, V0, -4
9D001008  AF828028   SW V0, -32728(GP)
192:                 
193:                 			// We can merge the 2, this ones unallocated
194:                 			MemoryBlockIterator2->SizeInWords += MemoryBlockIterator->SizeInWords + (OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES);
9D00100C  8FC20014   LW V0, 20(FP)
9D001010  8C420000   LW V0, 0(V0)
9D001014  7C42F000   EXT V0, V0, 0, 31
9D001018  00401821   ADDU V1, V0, ZERO
9D00101C  8FC20010   LW V0, 16(FP)
9D001020  8C420000   LW V0, 0(V0)
9D001024  7C42F000   EXT V0, V0, 0, 31
9D001028  24420001   ADDIU V0, V0, 1
9D00102C  00621021   ADDU V0, V1, V0
9D001030  7C44F000   EXT A0, V0, 0, 31
9D001034  8FC30014   LW V1, 20(FP)
9D001038  8C620000   LW V0, 0(V1)
9D00103C  7C82F004   INS V0, A0, 0, 31
9D001040  AC620000   SW V0, 0(V1)
195:                 		}
196:                 	}
197:                 
198:                 	// Lets make sure the memory block wasn't the first one, cause if it was theres nothing before it!
199:                 	if (MemoryBlockIterator2 != (OS_MEMORY_BLOCK_HEADER*)gKernelManagedMemory)
9D001044  3C02A000   LUI V0, -24576
9D001048  24420280   ADDIU V0, V0, 640
9D00104C  8FC30014   LW V1, 20(FP)
9D001050  10620038   BEQ V1, V0, 0x9D001134
9D001054  00000000   NOP
200:                 	{
201:                 		OS_WORD PreviousJumpInWords;
202:                 
203:                 		// Now lets see if the memory block before the first one is allocated or not.
204:                 		MemoryBlockIterator = (OS_MEMORY_BLOCK_HEADER*)gKernelManagedMemory;
9D001058  3C02A000   LUI V0, -24576
9D00105C  24420280   ADDIU V0, V0, 640
9D001060  AFC20010   SW V0, 16(FP)
205:                 
206:                 		do
207:                 		{
208:                 			PreviousJumpInWords = MemoryBlockIterator->SizeInWords;
9D001064  8FC20010   LW V0, 16(FP)
9D001068  8C420000   LW V0, 0(V0)
9D00106C  7C42F000   EXT V0, V0, 0, 31
9D001070  AFC20018   SW V0, 24(FP)
209:                 
210:                 			MemoryBlockIterator += ((MemoryBlockIterator->SizeInWords * 4) / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES + 1);
9D001074  8FC20010   LW V0, 16(FP)
9D001078  8C420000   LW V0, 0(V0)
9D00107C  7C42F000   EXT V0, V0, 0, 31
9D001080  00021080   SLL V0, V0, 2
9D001084  24430003   ADDIU V1, V0, 3
9D001088  28440000   SLTI A0, V0, 0
9D00108C  0064100B   MOVN V0, V1, A0
9D001090  00021083   SRA V0, V0, 2
9D001094  24420001   ADDIU V0, V0, 1
9D001098  00021080   SLL V0, V0, 2
9D00109C  8FC30010   LW V1, 16(FP)
9D0010A0  00621021   ADDU V0, V1, V0
9D0010A4  AFC20010   SW V0, 16(FP)
211:                 		} 
212:                 		while (MemoryBlockIterator != MemoryBlockIterator2);
9D0010A8  8FC30010   LW V1, 16(FP)
9D0010AC  8FC20014   LW V0, 20(FP)
9D0010B0  1462FFEC   BNE V1, V0, 0x9D001064
9D0010B4  00000000   NOP
213:                 
214:                 		// Now that we're at where we we're allocated, we have to go back by one memory block
215:                 		MemoryBlockIterator -= ((PreviousJumpInWords * 4) / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES + 1);
9D0010B8  8FC20018   LW V0, 24(FP)
9D0010BC  00021080   SLL V0, V0, 2
9D0010C0  00021082   SRL V0, V0, 2
9D0010C4  00021027   NOR V0, ZERO, V0
9D0010C8  00021080   SLL V0, V0, 2
9D0010CC  8FC30010   LW V1, 16(FP)
9D0010D0  00621021   ADDU V0, V1, V0
9D0010D4  AFC20010   SW V0, 16(FP)
216:                 
217:                 		if (!MemoryBlockIterator->Allocated)
9D0010D8  8FC20010   LW V0, 16(FP)
9D0010DC  8C430000   LW V1, 0(V0)
9D0010E0  3C028000   LUI V0, -32768
9D0010E4  00621024   AND V0, V1, V0
9D0010E8  14400012   BNE V0, ZERO, 0x9D001134
9D0010EC  00000000   NOP
218:                 		{
219:                 			// subtract the size of one header from the heap used since we're merging 2 blocks
220:                 			gHeapUsedInBytes -= sizeof(OS_MEMORY_BLOCK_HEADER);
9D0010F0  8F828028   LW V0, -32728(GP)
9D0010F4  2442FFFC   ADDIU V0, V0, -4
9D0010F8  AF828028   SW V0, -32728(GP)
221:                 
222:                 			// This memory block isn't allocated, lets merge them
223:                 			MemoryBlockIterator->SizeInWords += (MemoryBlockIterator2->SizeInWords + OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES);
9D0010FC  8FC20010   LW V0, 16(FP)
9D001100  8C420000   LW V0, 0(V0)
9D001104  7C42F000   EXT V0, V0, 0, 31
9D001108  00401821   ADDU V1, V0, ZERO
9D00110C  8FC20014   LW V0, 20(FP)
9D001110  8C420000   LW V0, 0(V0)
9D001114  7C42F000   EXT V0, V0, 0, 31
9D001118  24420001   ADDIU V0, V0, 1
9D00111C  00621021   ADDU V0, V1, V0
9D001120  7C44F000   EXT A0, V0, 0, 31
9D001124  8FC30010   LW V1, 16(FP)
9D001128  8C620000   LW V0, 0(V1)
9D00112C  7C82F004   INS V0, A0, 0, 31
9D001130  AC620000   SW V0, 0(V1)
224:                 		}
225:                 	}
226:                 
227:                 	#if (USING_MEMORY_WARNING_EVENT == 1 || USING_MEMORY_WARNING_USER_CALLBACK == 1)
228:                 		if (gMemoryWarning == TRUE)
229:                 		{
230:                 			if (gHeapUsedInBytes < MEMORY_WARNING_LEVEL)
231:                 			{
232:                 				gMemoryWarning = FALSE;
233:                 
234:                 				#if (USING_MEMORY_WARNING_CLEAR_USER_CALLBACK == 1)
235:                 					MemoryWarningClearUserCallback();
236:                 				#endif // end of USING_MEMORY_WARNING_CLEAR_USER_CALLBACK
237:                 
238:                 				#if (USING_MEMORY_WARNING_CLEAR_EVENT == 1)
239:                 					OS_RaiseEvent(MEMORY_WARNING_CLEAR_EVENT);
240:                 				#endif // end of USING_MEMORY_WARNING_CLEAR_EVENT == 1
241:                 			}
242:                 		}
243:                 	#endif // end of USING_MEMORY_WARNING_EVENT == 1 || USING_MEMORY_WARNING_USER_CALLBACK == 1
244:                 
245:                 	return TRUE;
9D001134  24020001   ADDIU V0, ZERO, 1
246:                 }
9D001138  03C0E821   ADDU SP, FP, ZERO
9D00113C  8FBF0024   LW RA, 36(SP)
9D001140  8FBE0020   LW FP, 32(SP)
9D001144  27BD0028   ADDIU SP, SP, 40
9D001148  03E00008   JR RA
9D00114C  00000000   NOP
247:                 
248:                 UINT32 GetHeapUsedInBytes(void)
249:                 {
9D001150  27BDFFE0   ADDIU SP, SP, -32
9D001154  AFBF001C   SW RA, 28(SP)
9D001158  AFBE0018   SW FP, 24(SP)
9D00115C  03A0F021   ADDU FP, SP, ZERO
250:                 	UINT32 TempHeapUsed;
251:                 
252:                 	EnterCritical();
9D001160  0F400F82   JAL EnterCritical
9D001164  00000000   NOP
253:                 
254:                 	TempHeapUsed = gHeapUsedInBytes;
9D001168  8F828028   LW V0, -32728(GP)
9D00116C  AFC20010   SW V0, 16(FP)
255:                 
256:                 	ExitCritical();
9D001170  0F400F95   JAL ExitCritical
9D001174  00000000   NOP
257:                 
258:                 	return TempHeapUsed;
9D001178  8FC20010   LW V0, 16(FP)
259:                 }
9D00117C  03C0E821   ADDU SP, FP, ZERO
9D001180  8FBF001C   LW RA, 28(SP)
9D001184  8FBE0018   LW FP, 24(SP)
9D001188  27BD0020   ADDIU SP, SP, 32
9D00118C  03E00008   JR RA
9D001190  00000000   NOP
260:                 
261:                 UINT32 GetHeapRemainingBytes(void)
262:                 {
9D001194  27BDFFE0   ADDIU SP, SP, -32
9D001198  AFBF001C   SW RA, 28(SP)
9D00119C  AFBE0018   SW FP, 24(SP)
9D0011A0  03A0F021   ADDU FP, SP, ZERO
263:                 	UINT32 TempHeapRemaining;
264:                 
265:                 	EnterCritical();
9D0011A4  0F400F82   JAL EnterCritical
9D0011A8  00000000   NOP
266:                 
267:                 	TempHeapRemaining = OS_HEAP_SIZE_IN_BYTES - gHeapUsedInBytes;
9D0011AC  8F828028   LW V0, -32728(GP)
9D0011B0  3403C350   ORI V1, ZERO, -15536
9D0011B4  00621023   SUBU V0, V1, V0
9D0011B8  AFC20010   SW V0, 16(FP)
268:                 
269:                 	ExitCritical();
9D0011BC  0F400F95   JAL ExitCritical
9D0011C0  00000000   NOP
270:                 
271:                 	return TempHeapRemaining;
9D0011C4  8FC20010   LW V0, 16(FP)
272:                 }
9D0011C8  03C0E821   ADDU SP, FP, ZERO
9D0011CC  8FBF001C   LW RA, 28(SP)
9D0011D0  8FBE0018   LW FP, 24(SP)
9D0011D4  27BD0020   ADDIU SP, SP, 32
9D0011D8  03E00008   JR RA
9D0011DC  00000000   NOP
273:                 
274:                 void *AllocateMemory(UINT32 SizeInBytes)
275:                 {
9D0011E0  27BDFFE0   ADDIU SP, SP, -32
9D0011E4  AFBF001C   SW RA, 28(SP)
9D0011E8  AFBE0018   SW FP, 24(SP)
9D0011EC  03A0F021   ADDU FP, SP, ZERO
9D0011F0  AFC40020   SW A0, 32(FP)
276:                 	void *AllocatedMemory;
277:                 
278:                 	EnterCritical();
9D0011F4  0F400F82   JAL EnterCritical
9D0011F8  00000000   NOP
279:                 
280:                 	AllocatedMemory = OS_AllocateMemory(SizeInBytes);
9D0011FC  8FC40020   LW A0, 32(FP)
9D001200  0F400334   JAL OS_AllocateMemory
9D001204  00000000   NOP
9D001208  AFC20010   SW V0, 16(FP)
281:                 
282:                 	ExitCritical();
9D00120C  0F400F95   JAL ExitCritical
9D001210  00000000   NOP
283:                 
284:                 	return AllocatedMemory;
9D001214  8FC20010   LW V0, 16(FP)
285:                 }
9D001218  03C0E821   ADDU SP, FP, ZERO
9D00121C  8FBF001C   LW RA, 28(SP)
9D001220  8FBE0018   LW FP, 24(SP)
9D001224  27BD0020   ADDIU SP, SP, 32
9D001228  03E00008   JR RA
9D00122C  00000000   NOP
286:                 
287:                 BOOL ReleaseMemory(void *Ptr)
288:                 {
9D001230  27BDFFE0   ADDIU SP, SP, -32
9D001234  AFBF001C   SW RA, 28(SP)
9D001238  AFBE0018   SW FP, 24(SP)
9D00123C  03A0F021   ADDU FP, SP, ZERO
9D001240  AFC40020   SW A0, 32(FP)
289:                 	BOOL ReleaseSuccessful;
290:                 
291:                 	EnterCritical();
9D001244  0F400F82   JAL EnterCritical
9D001248  00000000   NOP
292:                 
293:                 	ReleaseSuccessful = OS_ReleaseMemory(Ptr);
9D00124C  8FC40020   LW A0, 32(FP)
9D001250  0F4003C1   JAL OS_ReleaseMemory
9D001254  00000000   NOP
9D001258  AFC20010   SW V0, 16(FP)
294:                 
295:                 	ExitCritical();
9D00125C  0F400F95   JAL ExitCritical
9D001260  00000000   NOP
296:                 
297:                 	return ReleaseSuccessful;
9D001264  8FC20010   LW V0, 16(FP)
298:                 }
9D001268  03C0E821   ADDU SP, FP, ZERO
9D00126C  8FBF001C   LW RA, 28(SP)
9D001270  8FBE0018   LW FP, 24(SP)
9D001274  27BD0020   ADDIU SP, SP, 32
9D001278  03E00008   JR RA
9D00127C  00000000   NOP
299:                 
300:                 #if (USING_CALLOC_MEMORY_METHOD == 1)
301:                 	/*
302:                 		This will clear all the memory that the user requests
303:                 	*/
304:                 	void *CallocMemory(UINT32 SizeInBytes)
305:                 	{
9D001280  27BDFFD8   ADDIU SP, SP, -40
9D001284  AFBF0024   SW RA, 36(SP)
9D001288  AFBE0020   SW FP, 32(SP)
9D00128C  03A0F021   ADDU FP, SP, ZERO
9D001290  AFC40028   SW A0, 40(FP)
306:                 		UINT32 RequestedSizeInWords;
307:                 		void *Data;
308:                 
309:                 		if(SizeInBytes == 0)
9D001294  8FC20028   LW V0, 40(FP)
9D001298  14400004   BNE V0, ZERO, 0x9D0012AC
9D00129C  00000000   NOP
310:                 			return (void*)NULL;
9D0012A0  00001021   ADDU V0, ZERO, ZERO
9D0012A4  0B4004D2   J 0x9D001348
9D0012A8  00000000   NOP
311:                 
312:                 		if (SizeInBytes < OS_WORD_SIZE_IN_BYTES)
9D0012AC  8FC20028   LW V0, 40(FP)
9D0012B0  2C420004   SLTIU V0, V0, 4
9D0012B4  10400003   BEQ V0, ZERO, 0x9D0012C4
9D0012B8  00000000   NOP
313:                 			SizeInBytes = OS_WORD_SIZE_IN_BYTES;
9D0012BC  24020004   ADDIU V0, ZERO, 4
9D0012C0  AFC20028   SW V0, 40(FP)
314:                 	
315:                 		RequestedSizeInWords = ((SizeInBytes + (SizeInBytes % OS_WORD_SIZE_IN_BYTES)) / OS_WORD_SIZE_IN_BYTES);
9D0012C4  8FC20028   LW V0, 40(FP)
9D0012C8  30430003   ANDI V1, V0, 3
9D0012CC  8FC20028   LW V0, 40(FP)
9D0012D0  00621021   ADDU V0, V1, V0
9D0012D4  00021082   SRL V0, V0, 2
9D0012D8  AFC20018   SW V0, 24(FP)
316:                 	
317:                 		Data = AllocateMemory(SizeInBytes);
9D0012DC  8FC40028   LW A0, 40(FP)
9D0012E0  0F400478   JAL AllocateMemory
9D0012E4  00000000   NOP
9D0012E8  AFC2001C   SW V0, 28(FP)
318:                 	
319:                 		if(Data != (void*)NULL)
9D0012EC  8FC2001C   LW V0, 28(FP)
9D0012F0  10400014   BEQ V0, ZERO, 0x9D001344
9D0012F4  00000000   NOP
320:                 		{
321:                 			UINT32 i = 0;
9D0012F8  AFC00010   SW ZERO, 16(FP)
322:                 	
323:                 			OS_WORD *Ptr = (OS_WORD*)Data;
9D0012FC  8FC2001C   LW V0, 28(FP)
9D001300  AFC20014   SW V0, 20(FP)
324:                 	
325:                 			for(i = 0; i < RequestedSizeInWords; i++)
9D001304  AFC00010   SW ZERO, 16(FP)
9D001308  0B4004CC   J 0x9D001330
9D00130C  00000000   NOP
9D001324  8FC20010   LW V0, 16(FP)
9D001328  24420001   ADDIU V0, V0, 1
9D00132C  AFC20010   SW V0, 16(FP)
9D001330  8FC30010   LW V1, 16(FP)
9D001334  8FC20018   LW V0, 24(FP)
9D001338  0062102B   SLTU V0, V1, V0
9D00133C  1440FFF4   BNE V0, ZERO, 0x9D001310
9D001340  00000000   NOP
326:                 				*Ptr++ = 0;
9D001310  8FC20014   LW V0, 20(FP)
9D001314  AC400000   SW ZERO, 0(V0)
9D001318  8FC20014   LW V0, 20(FP)
9D00131C  24420004   ADDIU V0, V0, 4
9D001320  AFC20014   SW V0, 20(FP)
327:                 		}
328:                 	
329:                 		return (void*)Data;
9D001344  8FC2001C   LW V0, 28(FP)
330:                 	}
9D001348  03C0E821   ADDU SP, FP, ZERO
9D00134C  8FBF0024   LW RA, 36(SP)
9D001350  8FBE0020   LW FP, 32(SP)
9D001354  27BD0028   ADDIU SP, SP, 40
9D001358  03E00008   JR RA
9D00135C  00000000   NOP
331:                 #endif // end of USING_CALLOC_MEMORY_METHOD
332:                 
333:                 #if (USING_REALLOC_MEMORY_METHOD == 1)
334:                 	#include <string.h>
335:                 	
336:                 	void *ReallocMemory(void *Ptr, UINT32 SizeInBytes)
337:                 	{
9D001360  27BDFFE0   ADDIU SP, SP, -32
9D001364  AFBF001C   SW RA, 28(SP)
9D001368  AFBE0018   SW FP, 24(SP)
9D00136C  03A0F021   ADDU FP, SP, ZERO
9D001370  AFC40020   SW A0, 32(FP)
9D001374  AFC50024   SW A1, 36(FP)
338:                 		void *Data;
339:                 
340:                 		if (Ptr != (void*)NULL)
9D001378  8FC20020   LW V0, 32(FP)
9D00137C  1040000A   BEQ V0, ZERO, 0x9D0013A8
9D001380  00000000   NOP
341:                 			if (AddressInHeap((OS_WORD)Ptr) == FALSE)
9D001384  8FC20020   LW V0, 32(FP)
9D001388  00402021   ADDU A0, V0, ZERO
9D00138C  0F40050C   JAL AddressInHeap
9D001390  00000000   NOP
9D001394  14400004   BNE V0, ZERO, 0x9D0013A8
9D001398  00000000   NOP
342:                 				return (void*)NULL;
9D00139C  00001021   ADDU V0, ZERO, ZERO
9D0013A0  0B400506   J 0x9D001418
9D0013A4  00000000   NOP
343:                 
344:                 		if (SizeInBytes == 0)
9D0013A8  8FC20024   LW V0, 36(FP)
9D0013AC  14400004   BNE V0, ZERO, 0x9D0013C0
9D0013B0  00000000   NOP
345:                 			return (void*)NULL;
9D0013B4  00001021   ADDU V0, ZERO, ZERO
9D0013B8  0B400506   J 0x9D001418
9D0013BC  00000000   NOP
346:                 
347:                 		Data = AllocateMemory(SizeInBytes);
9D0013C0  8FC40024   LW A0, 36(FP)
9D0013C4  0F400478   JAL AllocateMemory
9D0013C8  00000000   NOP
9D0013CC  AFC20010   SW V0, 16(FP)
348:                 
349:                 		if (Data == (void*)NULL)
9D0013D0  8FC20010   LW V0, 16(FP)
9D0013D4  14400004   BNE V0, ZERO, 0x9D0013E8
9D0013D8  00000000   NOP
350:                 			return (void*)NULL;
9D0013DC  00001021   ADDU V0, ZERO, ZERO
9D0013E0  0B400506   J 0x9D001418
9D0013E4  00000000   NOP
351:                 
352:                 		// if they passed in a valid pointer to the heap,
353:                 		// just go ahead and copy the data over and then
354:                 		// free the previous data.
355:                 		if (Ptr != (void*)NULL)
9D0013E8  8FC20020   LW V0, 32(FP)
9D0013EC  10400009   BEQ V0, ZERO, 0x9D001414
9D0013F0  00000000   NOP
356:                 		{
357:                 			memcpy(Data, Ptr, SizeInBytes);
9D0013F4  8FC40010   LW A0, 16(FP)
9D0013F8  8FC50020   LW A1, 32(FP)
9D0013FC  8FC60024   LW A2, 36(FP)
9D001400  0F400E60   JAL memcpy
9D001404  00000000   NOP
358:                 
359:                 			ReleaseMemory(Ptr);
9D001408  8FC40020   LW A0, 32(FP)
9D00140C  0F40048C   JAL ReleaseMemory
9D001410  00000000   NOP
360:                 		}
361:                 	
362:                 		return Data;
9D001414  8FC20010   LW V0, 16(FP)
363:                 	}
9D001418  03C0E821   ADDU SP, FP, ZERO
9D00141C  8FBF001C   LW RA, 28(SP)
9D001420  8FBE0018   LW FP, 24(SP)
9D001424  27BD0020   ADDIU SP, SP, 32
9D001428  03E00008   JR RA
9D00142C  00000000   NOP
364:                 #endif // end of USING_REALLOC_MEMORY_METHOD
365:                 
366:                 BOOL AddressInHeap(OS_WORD Address)
367:                 {
9D001430  27BDFFF8   ADDIU SP, SP, -8
9D001434  AFBE0004   SW FP, 4(SP)
9D001438  03A0F021   ADDU FP, SP, ZERO
9D00143C  AFC40008   SW A0, 8(FP)
368:                 	return (BOOL)(Address >= (OS_WORD)gKernelManagedMemory && Address <= ((OS_WORD)gKernelManagedMemory + sizeof(gKernelManagedMemory)));
9D001440  3C02A000   LUI V0, -24576
9D001444  24420280   ADDIU V0, V0, 640
9D001448  8FC30008   LW V1, 8(FP)
9D00144C  0062102B   SLTU V0, V1, V0
9D001450  1440000C   BNE V0, ZERO, 0x9D001484
9D001454  00000000   NOP
9D001458  3C02A000   LUI V0, -24576
9D00145C  24430280   ADDIU V1, V0, 640
9D001460  3402C354   ORI V0, ZERO, -15532
9D001464  00621021   ADDU V0, V1, V0
9D001468  8FC30008   LW V1, 8(FP)
9D00146C  0043102B   SLTU V0, V0, V1
9D001470  14400004   BNE V0, ZERO, 0x9D001484
9D001474  00000000   NOP
9D001478  24020001   ADDIU V0, ZERO, 1
9D00147C  0B400522   J 0x9D001488
9D001480  00000000   NOP
9D001484  00001021   ADDU V0, ZERO, ZERO
369:                 }
9D001488  03C0E821   ADDU SP, FP, ZERO
9D00148C  8FBE0004   LW FP, 4(SP)
9D001490  27BD0008   ADDIU SP, SP, 8
9D001494  03E00008   JR RA
9D001498  00000000   NOP
370:                 
371:                 BOOL ProgramAddressValid(OS_WORD ProgramAddress)
372:                 {
9D00149C  27BDFFF8   ADDIU SP, SP, -8
9D0014A0  AFBE0004   SW FP, 4(SP)
9D0014A4  03A0F021   ADDU FP, SP, ZERO
9D0014A8  AFC40008   SW A0, 8(FP)
373:                 	if(ProgramAddress < USER_PROGRAM_STARTING_ADDRESS)
9D0014AC  8FC30008   LW V1, 8(FP)
9D0014B0  3C029D00   LUI V0, -25344
9D0014B4  0062102B   SLTU V0, V1, V0
9D0014B8  10400004   BEQ V0, ZERO, 0x9D0014CC
9D0014BC  00000000   NOP
374:                 		return FALSE;
9D0014C0  00001021   ADDU V0, ZERO, ZERO
9D0014C4  0B40053F   J 0x9D0014FC
9D0014C8  00000000   NOP
375:                 
376:                 	if(ProgramAddress > (USER_PROGRAM_STARTING_ADDRESS + GetProgramMemorySizeInBytes()))
9D0014CC  3C02BF88   LUI V0, -16504
9D0014D0  8C432060   LW V1, 8288(V0)
9D0014D4  3C029D00   LUI V0, -25344
9D0014D8  00621821   ADDU V1, V1, V0
9D0014DC  8FC20008   LW V0, 8(FP)
9D0014E0  0062102B   SLTU V0, V1, V0
9D0014E4  10400004   BEQ V0, ZERO, 0x9D0014F8
9D0014E8  00000000   NOP
377:                 		return FALSE;
9D0014EC  00001021   ADDU V0, ZERO, ZERO
9D0014F0  0B40053F   J 0x9D0014FC
9D0014F4  00000000   NOP
378:                 
379:                 	return TRUE;
9D0014F8  24020001   ADDIU V0, ZERO, 1
380:                 }
9D0014FC  03C0E821   ADDU SP, FP, ZERO
9D001500  8FBE0004   LW FP, 4(SP)
9D001504  27BD0008   ADDIU SP, SP, 8
9D001508  03E00008   JR RA
9D00150C  00000000   NOP
381:                 
382:                 BOOL RAMAddressValid(OS_WORD RAMAddress)
383:                 {
9D001510  27BDFFF8   ADDIU SP, SP, -8
9D001514  AFBE0004   SW FP, 4(SP)
9D001518  03A0F021   ADDU FP, SP, ZERO
9D00151C  AFC40008   SW A0, 8(FP)
384:                 	if(RAMAddress < USER_RAM_STARTING_ADDRESS)
9D001520  8FC30008   LW V1, 8(FP)
9D001524  3C02A000   LUI V0, -24576
9D001528  0062102B   SLTU V0, V1, V0
9D00152C  10400004   BEQ V0, ZERO, 0x9D001540
9D001530  00000000   NOP
385:                 		return FALSE;
9D001534  00001021   ADDU V0, ZERO, ZERO
9D001538  0B40055C   J 0x9D001570
9D00153C  00000000   NOP
386:                 
387:                 	if(RAMAddress > (USER_RAM_STARTING_ADDRESS + GetRAMSizeInBytes()))
9D001540  3C02BF88   LUI V0, -16504
9D001544  8C432040   LW V1, 8256(V0)
9D001548  3C02A000   LUI V0, -24576
9D00154C  00621821   ADDU V1, V1, V0
9D001550  8FC20008   LW V0, 8(FP)
9D001554  0062102B   SLTU V0, V1, V0
9D001558  10400004   BEQ V0, ZERO, 0x9D00156C
9D00155C  00000000   NOP
388:                 		return FALSE;
9D001560  00001021   ADDU V0, ZERO, ZERO
9D001564  0B40055C   J 0x9D001570
9D001568  00000000   NOP
389:                 
390:                 	return TRUE;
9D00156C  24020001   ADDIU V0, ZERO, 1
391:                 }
9D001570  03C0E821   ADDU SP, FP, ZERO
9D001574  8FBE0004   LW FP, 4(SP)
9D001578  27BD0008   ADDIU SP, SP, 8
9D00157C  03E00008   JR RA
9D001580  00000000   NOP
392:                 
393:                 BOOL AddressValid(OS_WORD Address)
394:                 {
9D001584  27BDFFE8   ADDIU SP, SP, -24
9D001588  AFBF0014   SW RA, 20(SP)
9D00158C  AFBE0010   SW FP, 16(SP)
9D001590  03A0F021   ADDU FP, SP, ZERO
9D001594  AFC40018   SW A0, 24(FP)
395:                 	return (BOOL)(RAMAddressValid(Address) == TRUE || ProgramAddressValid(Address) == TRUE);
9D001598  8FC40018   LW A0, 24(FP)
9D00159C  0F400544   JAL RAMAddressValid
9D0015A0  00000000   NOP
9D0015A4  00401821   ADDU V1, V0, ZERO
9D0015A8  24020001   ADDIU V0, ZERO, 1
9D0015AC  10620008   BEQ V1, V0, 0x9D0015D0
9D0015B0  00000000   NOP
9D0015B4  8FC40018   LW A0, 24(FP)
9D0015B8  0F400527   JAL ProgramAddressValid
9D0015BC  00000000   NOP
9D0015C0  00401821   ADDU V1, V0, ZERO
9D0015C4  24020001   ADDIU V0, ZERO, 1
9D0015C8  14620004   BNE V1, V0, 0x9D0015DC
9D0015CC  00000000   NOP
9D0015D0  24020001   ADDIU V0, ZERO, 1
9D0015D4  0B400578   J 0x9D0015E0
9D0015D8  00000000   NOP
9D0015DC  00001021   ADDU V0, ZERO, ZERO
396:                 }
9D0015E0  03C0E821   ADDU SP, FP, ZERO
---  c:/users/ben.danametrics/desktop/nexos/project/main.c  ---------------------------------------------
1:                   /* 
2:                    * File:   main.c
3:                    * Author: NexSys Controls
4:                    *
5:                    * Created on May 31, 2015, 8:27 AM
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  
11:                  //#include <plib.h>
12:                  #include "GenericTypeDefs.h"
13:                  
14:                  #include "Kernel.h"
15:                  #include "Memory.h"
16:                  #include "Task.h"
17:                  #include "Exceptions.h"
18:                  #include "HardwareProfile.h"
19:                  
20:                  #if(1)
21:                      #pragma config UPLLEN   = ON        	// USB PLL Enabled
22:                      #pragma config FPLLMUL  = MUL_20        // PLL Multiplier
23:                      #pragma config UPLLIDIV = DIV_2         // USB PLL Input Divider
24:                      #pragma config FPLLIDIV = DIV_2         // PLL Input Divider
25:                      #pragma config FPLLODIV = DIV_1         // PLL Output Divider
26:                      #pragma config FPBDIV   = DIV_1         // Peripheral Clock divisor
27:                      #pragma config FWDTEN   = OFF           // Watchdog Timer
28:                      #pragma config WDTPS    = PS1           // Watchdog Timer Postscale
29:                      #pragma config FCKSM    = CSDCMD        // Clock Switching & Fail Safe Clock Monitor
30:                      #pragma config OSCIOFNC = OFF           // CLKO Enable
31:                      #pragma config POSCMOD  = HS            // Primary Oscillator
32:                      #pragma config IESO     = ON            // Internal/External Switch-over
33:                      #pragma config FSOSCEN  = ON           	// Secondary Oscillator Enable (KLO was off)
34:                      #pragma config FNOSC    = PRIPLL        // Oscillator Selection
35:                      #pragma config CP       = OFF          	// Code Protect
36:                      #pragma config BWP      = OFF	        // Boot Flash Write Protect
37:                      #pragma config PWP      = OFF       	// Program Flash Write Protect
38:                      #pragma config ICESEL   = ICS_PGx2      // ICE/ICD Comm Channel Select
39:                      #pragma config DEBUG    = OFF            // Background Debugger Enable
40:                      #pragma config FVBUSONIO = OFF
41:                      #pragma config FCANIO 	= OFF			// OFF Enables Alternate CAN I/O
42:                  #endif // end of #if(0)
43:                  
44:                  //#define SIMULATION
45:                  //#define RELEASE
46:                  
47:                  BOOL GeneralExceptionHandler(EXCEPTION_CODE ExceptionCode, UINT32 ExceptionAddress)
48:                  {
9D003364  27BDFFF8   ADDIU SP, SP, -8
9D003368  AFBE0004   SW FP, 4(SP)
9D00336C  03A0F021   ADDU FP, SP, ZERO
9D003370  AFC40008   SW A0, 8(FP)
9D003374  AFC5000C   SW A1, 12(FP)
49:                      LATAbits.LATA0 = 1;
9D003378  3C03BF88   LUI V1, -16504
9D00337C  8C626020   LW V0, 24608(V1)
9D003380  24040001   ADDIU A0, ZERO, 1
9D003384  7C820004   INS V0, A0, 0, 1
9D003388  AC626020   SW V0, 24608(V1)
50:                      
51:                  	return FALSE;
9D00338C  00001021   ADDU V0, ZERO, ZERO
52:                  }
9D003390  03C0E821   ADDU SP, FP, ZERO
9D003394  8FBE0004   LW FP, 4(SP)
9D003398  27BD0008   ADDIU SP, SP, 8
9D00339C  03E00008   JR RA
9D0033A0  00000000   NOP
53:                  
54:                  #ifdef RELEASE
55:                  	#include "AsyncSerial.h"
56:                  
57:                  	void _mon_putc (char c)
58:                  	{
59:                  		// Write a byte out the serial port
60:                  		AsyncSerialWriteByte(UART4, c);
61:                  	}
62:                  
63:                  	int _mon_getc(int canblock)
64:                  	{
65:                  		// Write a byte out the serial port
66:                  		if(canblock != 0)
67:                  		{
68:                  			int val = AsyncSerialReadByte(UART4, 2000);
69:                  
70:                  			if(val == 0)
71:                  				return - 1;
72:                  		
73:                  			return val;
74:                  		}
75:                  
76:                  		return (int)AsyncSerialReadByte(UART4, -1);
77:                  	}
78:                  #endif // end of RELEASE
79:                  
80:                  #ifdef SIMULATION							
81:                  	void _mon_putc (char c)
82:                  	{
9D0033A4  27BDFFF8   ADDIU SP, SP, -8
9D0033A8  AFBE0004   SW FP, 4(SP)
9D0033AC  03A0F021   ADDU FP, SP, ZERO
9D0033B0  00801021   ADDU V0, A0, ZERO
9D0033B4  A3C20008   SB V0, 8(FP)
83:                  		// Write a byte out the serial port
84:                  		//AsyncSerialWriteByte(UART_4);
85:                  	}
9D0033B8  03C0E821   ADDU SP, FP, ZERO
9D0033BC  8FBE0004   LW FP, 4(SP)
9D0033C0  27BD0008   ADDIU SP, SP, 8
9D0033C4  03E00008   JR RA
9D0033C8  00000000   NOP
86:                  #endif // end of #ifdef SIMULATION
87:                  
88:                  #if (MEMORY_TEST == 1)
89:                  	BOOL NextMemoryBlockValid(OS_MEMORY_BLOCK_HEADER *MemoryBlock)
90:                  	{
91:                  		OS_MEMORY_BLOCK_HEADER *MemoryBlockIterator = MemoryBlock;
92:                  
93:                  		MemoryBlockIterator += ((MemoryBlockIterator->SizeInWords * 4) / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES + 1);
94:                  
95:                  		if(MemoryBlockIterator >= (OS_MEMORY_BLOCK_HEADER*)&(GetKernelManagedMemory()[(OS_HEAP_SIZE_IN_BYTES / OS_WORD_SIZE_IN_BYTES)]))
96:                  			return FALSE;
97:                  
98:                  		return TRUE;
99:                  	}
100:                 
101:                 	OS_MEMORY_BLOCK_HEADER *GetNextMemoryBlock(OS_MEMORY_BLOCK_HEADER *CurrentMemoryBlock)
102:                 	{
103:                 		CurrentMemoryBlock += ((CurrentMemoryBlock->SizeInWords * 4) / OS_MEMORY_BLOCK_HEADER_SIZE_IN_BYTES + 1);
104:                 
105:                 		return CurrentMemoryBlock;
106:                 	}
107:                 
108:                 	void PrintMemoryBlock(OS_MEMORY_BLOCK_HEADER *MemoryBlock)
109:                 	{
110:                 		if(MemoryBlock->Allocated == 1)
111:                 			printf("ALLOCATED: YES\n\0" );
112:                 		else
113:                 			printf("ALLOCATED: NO\n\0" );
114:                 
115:                 		printf("SPACE: %i bytes\n\n\0", MemoryBlock->SizeInWords * 4);
116:                 	}
117:                 
118:                 	void PrintWalkThroughOSMemory(void)
119:                 	{
120:                 		OS_MEMORY_BLOCK_HEADER *MemoryBlock = GetKernelManagedMemory();
121:                 
122:                 		printf("\nOS HEAP WALKTHROUGH:\n\n\0" );
123:                 
124:                 		PrintMemoryBlock(MemoryBlock);
125:                 
126:                 		while(NextMemoryBlockValid(MemoryBlock) == TRUE)
127:                 		{
128:                 			MemoryBlock = GetNextMemoryBlock(MemoryBlock);
129:                 
130:                 			PrintMemoryBlock(MemoryBlock);
131:                 		}
132:                 
133:                 		printf("\nOS HEAP USED: %i\n\n\0", GetHeapUsedInBytes());
134:                 	}
135:                 #endif // end of #if (MEMORY_TEST == 1)
136:                 
137:                 TASK *TestTask;
138:                 TASK *TestTask2;
139:                 
140:                 UINT32 TaskTaskCode(void *Args)
141:                 {
9D0033CC  27BDFFE8   ADDIU SP, SP, -24
9D0033D0  AFBF0014   SW RA, 20(SP)
9D0033D4  AFBE0010   SW FP, 16(SP)
9D0033D8  03A0F021   ADDU FP, SP, ZERO
9D0033DC  AFC40018   SW A0, 24(FP)
142:                     TRISBbits.TRISB4 = 0;
9D0033E0  3C03BF88   LUI V1, -16504
9D0033E4  8C626040   LW V0, 24640(V1)
9D0033E8  7C022104   INS V0, ZERO, 4, 1
9D0033EC  AC626040   SW V0, 24640(V1)
143:                     LATBbits.LATB4 = (unsigned)Args;
9D0033F0  8FC20018   LW V0, 24(FP)
9D0033F4  304200FF   ANDI V0, V0, 255
9D0033F8  30420001   ANDI V0, V0, 1
9D0033FC  304400FF   ANDI A0, V0, 255
9D003400  3C03BF88   LUI V1, -16504
9D003404  8C626060   LW V0, 24672(V1)
9D003408  7C822104   INS V0, A0, 4, 1
9D00340C  AC626060   SW V0, 24672(V1)
144:                     
145:                     while(1)
146:                     {
147:                         LATBbits.LATB4 ^= 1;
9D003410  3C02BF88   LUI V0, -16504
9D003414  8C426060   LW V0, 24672(V0)
9D003418  7C420100   EXT V0, V0, 4, 1
9D00341C  304200FF   ANDI V0, V0, 255
9D003420  38420001   XORI V0, V0, 1
9D003424  304200FF   ANDI V0, V0, 255
9D003428  30420001   ANDI V0, V0, 1
9D00342C  304400FF   ANDI A0, V0, 255
9D003430  3C03BF88   LUI V1, -16504
9D003434  8C626060   LW V0, 24672(V1)
9D003438  7C822104   INS V0, A0, 4, 1
9D00343C  AC626060   SW V0, 24672(V1)
148:                         
149:                         TaskDelayTicks(5000);
9D003440  24041388   ADDIU A0, ZERO, 5000
9D003444  0F40061F   JAL TaskDelayTicks
9D003448  00000000   NOP
150:                     }
9D00344C  0B400D04   J 0x9D003410
9D003450  00000000   NOP
151:                 }
152:                 
153:                 UINT32 TaskTaskCode2(void *Args)
154:                 {
9D003454  27BDFFF8   ADDIU SP, SP, -8
9D003458  AFBE0004   SW FP, 4(SP)
9D00345C  03A0F021   ADDU FP, SP, ZERO
9D003460  AFC40008   SW A0, 8(FP)
155:                     TRISBbits.TRISB3 = 0;
9D003464  3C03BF88   LUI V1, -16504
9D003468  8C626040   LW V0, 24640(V1)
9D00346C  7C0218C4   INS V0, ZERO, 3, 1
9D003470  AC626040   SW V0, 24640(V1)
156:                     LATBbits.LATB3 = (unsigned)Args;
9D003474  8FC20008   LW V0, 8(FP)
9D003478  304200FF   ANDI V0, V0, 255
9D00347C  30420001   ANDI V0, V0, 1
9D003480  304400FF   ANDI A0, V0, 255
9D003484  3C03BF88   LUI V1, -16504
9D003488  8C626060   LW V0, 24672(V1)
9D00348C  7C8218C4   INS V0, A0, 3, 1
9D003490  AC626060   SW V0, 24672(V1)
157:                     
158:                     while(1)
159:                     {
160:                         LATBbits.LATB3 ^= 1;
9D003494  3C02BF88   LUI V0, -16504
9D003498  8C426060   LW V0, 24672(V0)
9D00349C  7C4200C0   EXT V0, V0, 3, 1
9D0034A0  304200FF   ANDI V0, V0, 255
9D0034A4  38420001   XORI V0, V0, 1
9D0034A8  304200FF   ANDI V0, V0, 255
9D0034AC  30420001   ANDI V0, V0, 1
9D0034B0  304400FF   ANDI A0, V0, 255
9D0034B4  3C03BF88   LUI V1, -16504
9D0034B8  8C626060   LW V0, 24672(V1)
9D0034BC  7C8218C4   INS V0, A0, 3, 1
9D0034C0  AC626060   SW V0, 24672(V1)
161:                         
162:                         //TaskDelayTicks(5000);
163:                     }
9D0034C4  0B400D25   J 0x9D003494
9D0034C8  00000000   NOP
164:                 }
165:                     
166:                 int main(int argc, char** argv)
167:                 {
9D0034CC  27BDFFE0   ADDIU SP, SP, -32
9D0034D0  AFBF001C   SW RA, 28(SP)
9D0034D4  AFBE0018   SW FP, 24(SP)
9D0034D8  03A0F021   ADDU FP, SP, ZERO
9D0034DC  AFC40020   SW A0, 32(FP)
9D0034E0  AFC50024   SW A1, 36(FP)
168:                 	#ifdef RELEASE
169:                 		// initialize the Asyncrounous Serial Port
170:                 	#endif // end of #ifdef RELEASE
171:                 
172:                 	#ifdef SIMULATION
173:                 		U1MODEbits.UARTEN = 0x01;
9D0034E4  3C03BF80   LUI V1, -16512
9D0034E8  8C626000   LW V0, 24576(V1)
9D0034EC  24040001   ADDIU A0, ZERO, 1
9D0034F0  7C827BC4   INS V0, A0, 15, 1
9D0034F4  AC626000   SW V0, 24576(V1)
174:                 		U1STAbits.UTXEN = 0x01;
9D0034F8  3C03BF80   LUI V1, -16512
9D0034FC  8C626010   LW V0, 24592(V1)
9D003500  24040001   ADDIU A0, ZERO, 1
9D003504  7C825284   INS V0, A0, 10, 1
9D003508  AC626010   SW V0, 24592(V1)
175:                 	#endif // end of #if SIMULATION
176:                 
177:                     TRISAbits.TRISA0 = 0;
9D00350C  3C03BF88   LUI V1, -16504
9D003510  8C626000   LW V0, 24576(V1)
9D003514  7C020004   INS V0, ZERO, 0, 1
9D003518  AC626000   SW V0, 24576(V1)
178:                     LATAbits.LATA0 = 0;
9D00351C  3C03BF88   LUI V1, -16504
9D003520  8C626020   LW V0, 24608(V1)
9D003524  7C020004   INS V0, ZERO, 0, 1
9D003528  AC626020   SW V0, 24608(V1)
179:                 
180:                     #ifndef SIMULATION		
181:                         while(OSCCONbits.SLOCK != 1);
182:                     #endif // end of #ifndef SIMULATION		
183:                 
184:                 	mJTAGPortEnable(DEBUG_JTAGPORT_OFF);
9D00352C  3C03BF81   LUI V1, -16511
9D003530  8C62F200   LW V0, -3584(V1)
9D003534  7C0218C4   INS V0, ZERO, 3, 1
9D003538  AC62F200   SW V0, -3584(V1)
185:                     
186:                     SetSystemClocks(GetSystemClock());
9D00353C  3C0204C4   LUI V0, 1220
9D003540  3444B400   ORI A0, V0, -19456
9D003544  0F400AE5   JAL SetSystemClocks
9D003548  00000000   NOP
187:                     
188:                     if(InitOS() != OS_SUCCESS)
9D00354C  0F400000   JAL InitOS
9D003550  00000000   NOP
9D003554  10400003   BEQ V0, ZERO, 0x9D003564
9D003558  00000000   NOP
189:                         while(1);
9D00355C  0B400D57   J 0x9D00355C
9D003560  00000000   NOP
190:                 
191:                     TestTask = CreateTask(TaskTaskCode, 250, 1, (void*)0, (TASK*)NULL);
9D003564  AFA00010   SW ZERO, 16(SP)
9D003568  3C029D00   LUI V0, -25344
9D00356C  244433CC   ADDIU A0, V0, 13260
9D003570  240500FA   ADDIU A1, ZERO, 250
9D003574  24060001   ADDIU A2, ZERO, 1
9D003578  00003821   ADDU A3, ZERO, ZERO
9D00357C  0F4005D2   JAL CreateTask
9D003580  00000000   NOP
9D003584  AF828040   SW V0, -32704(GP)
192:                     TestTask2 = CreateTask(TaskTaskCode2, 250, 1, (void*)1, (TASK*)NULL);
9D003588  AFA00010   SW ZERO, 16(SP)
9D00358C  3C029D00   LUI V0, -25344
9D003590  24443454   ADDIU A0, V0, 13396
9D003594  240500FA   ADDIU A1, ZERO, 250
9D003598  24060001   ADDIU A2, ZERO, 1
9D00359C  24070001   ADDIU A3, ZERO, 1
9D0035A0  0F4005D2   JAL CreateTask
9D0035A4  00000000   NOP
9D0035A8  AF828044   SW V0, -32700(GP)
193:                 
194:                     StartOSScheduler();
9D0035AC  0F400023   JAL StartOSScheduler
9D0035B0  00000000   NOP
195:                     
196:                 	return (EXIT_SUCCESS);
9D0035B4  00001021   ADDU V0, ZERO, ZERO
197:                 }
9D0035B8  03C0E821   ADDU SP, FP, ZERO
---  c:/users/ben.danametrics/desktop/nexos/project/lists.c  --------------------------------------------
1:                   #include <stdlib.h>
2:                   
3:                   #include "Lists.h"
4:                   
5:                   void InitializeDoubleLinkedListHead(DOUBLE_LINKED_LIST_HEAD *Head)
6:                   {
9D0030F0  27BDFFF8   ADDIU SP, SP, -8
9D0030F4  AFBE0004   SW FP, 4(SP)
9D0030F8  03A0F021   ADDU FP, SP, ZERO
9D0030FC  AFC40008   SW A0, 8(FP)
7:                   	Head->Beginning = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D003100  8FC20008   LW V0, 8(FP)
9D003104  AC400000   SW ZERO, 0(V0)
8:                   	Head->End = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D003108  8FC20008   LW V0, 8(FP)
9D00310C  AC400004   SW ZERO, 4(V0)
9:                   }
9D003110  03C0E821   ADDU SP, FP, ZERO
9D003114  8FBE0004   LW FP, 4(SP)
9D003118  27BD0008   ADDIU SP, SP, 8
9D00311C  03E00008   JR RA
9D003120  00000000   NOP
10:                  
11:                  void InitializeDoubleLinkedListNode(DOUBLE_LINKED_LIST_NODE *Node)
12:                  {
9D003124  27BDFFF8   ADDIU SP, SP, -8
9D003128  AFBE0004   SW FP, 4(SP)
9D00312C  03A0F021   ADDU FP, SP, ZERO
9D003130  AFC40008   SW A0, 8(FP)
13:                  	Node->Data = (void*)NULL;
9D003134  8FC20008   LW V0, 8(FP)
9D003138  AC400008   SW ZERO, 8(V0)
14:                  
15:                  	Node->NextNode = Node->PreviousNode = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D00313C  8FC20008   LW V0, 8(FP)
9D003140  AC400004   SW ZERO, 4(V0)
9D003144  8FC20008   LW V0, 8(FP)
9D003148  8C430004   LW V1, 4(V0)
9D00314C  8FC20008   LW V0, 8(FP)
9D003150  AC430000   SW V1, 0(V0)
16:                  }
9D003154  03C0E821   ADDU SP, FP, ZERO
9D003158  8FBE0004   LW FP, 4(SP)
9D00315C  27BD0008   ADDIU SP, SP, 8
9D003160  03E00008   JR RA
9D003164  00000000   NOP
17:                  
18:                  #if (USING_INSERT_NODE_AT_BEGINNING_OF_DOUBLE_LINKED_LIST == 1)
19:                  	void InsertNodeAtBeginningOfDoubleLinkedList(DOUBLE_LINKED_LIST_HEAD *Head, DOUBLE_LINKED_LIST_NODE *Node)
20:                  	{
21:                  		if (Head->Beginning == (DOUBLE_LINKED_LIST_NODE*)NULL)
22:                  		{
23:                  			Head->Beginning = Head->End = Node;
24:                  			Node->NextNode = Node->PreviousNode = (DOUBLE_LINKED_LIST_NODE*)NULL;
25:                  		}
26:                  		else
27:                  		{
28:                  			Node->PreviousNode = NULL;
29:                  			Node->NextNode = Head->Beginning;
30:                  			Head->Beginning->PreviousNode = Node;
31:                  			Head->Beginning = Node;
32:                  		}
33:                  	}
34:                  #endif // end of #if (USING_INSERT_NODE_AT_BEGINNING_OF_DOUBLE_LINKED_LIST == 1)
35:                  
36:                  void InsertNodeAtEndOfDoubleLinkedList(DOUBLE_LINKED_LIST_HEAD *Head, DOUBLE_LINKED_LIST_NODE *Node)
37:                  {
9D003168  27BDFFF8   ADDIU SP, SP, -8
9D00316C  AFBE0004   SW FP, 4(SP)
9D003170  03A0F021   ADDU FP, SP, ZERO
9D003174  AFC40008   SW A0, 8(FP)
9D003178  AFC5000C   SW A1, 12(FP)
38:                  	if(Head->End == (DOUBLE_LINKED_LIST_NODE*)NULL)
9D00317C  8FC20008   LW V0, 8(FP)
9D003180  8C420004   LW V0, 4(V0)
9D003184  14400010   BNE V0, ZERO, 0x9D0031C8
9D003188  00000000   NOP
39:                  	{
40:                  		Head->End = Head->Beginning = Node;
9D00318C  8FC20008   LW V0, 8(FP)
9D003190  8FC3000C   LW V1, 12(FP)
9D003194  AC430000   SW V1, 0(V0)
9D003198  8FC20008   LW V0, 8(FP)
9D00319C  8C430000   LW V1, 0(V0)
9D0031A0  8FC20008   LW V0, 8(FP)
9D0031A4  AC430004   SW V1, 4(V0)
41:                  		Node->NextNode = Node->PreviousNode = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D0031A8  8FC2000C   LW V0, 12(FP)
9D0031AC  AC400004   SW ZERO, 4(V0)
9D0031B0  8FC2000C   LW V0, 12(FP)
9D0031B4  8C430004   LW V1, 4(V0)
9D0031B8  8FC2000C   LW V0, 12(FP)
9D0031BC  AC430000   SW V1, 0(V0)
9D0031C0  0B400C7F   J 0x9D0031FC
9D0031C4  00000000   NOP
42:                  	}
43:                  	else
44:                  	{
45:                  		Node->NextNode = NULL;
9D0031C8  8FC2000C   LW V0, 12(FP)
9D0031CC  AC400000   SW ZERO, 0(V0)
46:                  		Node->PreviousNode = Head->End;
9D0031D0  8FC20008   LW V0, 8(FP)
9D0031D4  8C430004   LW V1, 4(V0)
9D0031D8  8FC2000C   LW V0, 12(FP)
9D0031DC  AC430004   SW V1, 4(V0)
47:                  		Head->End = Head->End->NextNode = Node;
9D0031E0  8FC20008   LW V0, 8(FP)
9D0031E4  8C420004   LW V0, 4(V0)
9D0031E8  8FC3000C   LW V1, 12(FP)
9D0031EC  AC430000   SW V1, 0(V0)
9D0031F0  8C430000   LW V1, 0(V0)
9D0031F4  8FC20008   LW V0, 8(FP)
9D0031F8  AC430004   SW V1, 4(V0)
48:                  	}
49:                  }
9D0031FC  03C0E821   ADDU SP, FP, ZERO
9D003200  8FBE0004   LW FP, 4(SP)
9D003204  27BD0008   ADDIU SP, SP, 8
9D003208  03E00008   JR RA
9D00320C  00000000   NOP
50:                  
51:                  DOUBLE_LINKED_LIST_NODE *RemoveNodeFromDoubleLinkedList(DOUBLE_LINKED_LIST_HEAD *Head, DOUBLE_LINKED_LIST_NODE *Node)
52:                  {
9D003210  27BDFFF8   ADDIU SP, SP, -8
9D003214  AFBE0004   SW FP, 4(SP)
9D003218  03A0F021   ADDU FP, SP, ZERO
9D00321C  AFC40008   SW A0, 8(FP)
9D003220  AFC5000C   SW A1, 12(FP)
53:                  	if(Node->NextNode != (DOUBLE_LINKED_LIST_NODE*)NULL)
9D003224  8FC2000C   LW V0, 12(FP)
9D003228  8C420000   LW V0, 0(V0)
9D00322C  10400006   BEQ V0, ZERO, 0x9D003248
9D003230  00000000   NOP
54:                  	{
55:                  		Node->NextNode->PreviousNode = Node->PreviousNode;
9D003234  8FC2000C   LW V0, 12(FP)
9D003238  8C420000   LW V0, 0(V0)
9D00323C  8FC3000C   LW V1, 12(FP)
9D003240  8C630004   LW V1, 4(V1)
9D003244  AC430004   SW V1, 4(V0)
56:                  	}
57:                  
58:                  	if(Node->PreviousNode != (DOUBLE_LINKED_LIST_NODE*)NULL)
9D003248  8FC2000C   LW V0, 12(FP)
9D00324C  8C420004   LW V0, 4(V0)
9D003250  10400006   BEQ V0, ZERO, 0x9D00326C
9D003254  00000000   NOP
59:                  	{
60:                  		Node->PreviousNode->NextNode = Node->NextNode;
9D003258  8FC2000C   LW V0, 12(FP)
9D00325C  8C420004   LW V0, 4(V0)
9D003260  8FC3000C   LW V1, 12(FP)
9D003264  8C630000   LW V1, 0(V1)
9D003268  AC430000   SW V1, 0(V0)
61:                  	}
62:                  
63:                  	if(Head->Beginning == Node)
9D00326C  8FC20008   LW V0, 8(FP)
9D003270  8C430000   LW V1, 0(V0)
9D003274  8FC2000C   LW V0, 12(FP)
9D003278  14620014   BNE V1, V0, 0x9D0032CC
9D00327C  00000000   NOP
64:                  	{
65:                  		if(Head->End == Node)
9D003280  8FC20008   LW V0, 8(FP)
9D003284  8C430004   LW V1, 4(V0)
9D003288  8FC2000C   LW V0, 12(FP)
9D00328C  14620009   BNE V1, V0, 0x9D0032B4
9D003290  00000000   NOP
66:                  			Head->Beginning = Head->End = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D003294  8FC20008   LW V0, 8(FP)
9D003298  AC400004   SW ZERO, 4(V0)
9D00329C  8FC20008   LW V0, 8(FP)
9D0032A0  8C430004   LW V1, 4(V0)
9D0032A4  8FC20008   LW V0, 8(FP)
9D0032A8  AC430000   SW V1, 0(V0)
9D0032AC  0B400CBC   J 0x9D0032F0
9D0032B0  00000000   NOP
67:                  		else
68:                  			Head->Beginning = Node->NextNode;
9D0032B4  8FC2000C   LW V0, 12(FP)
9D0032B8  8C430000   LW V1, 0(V0)
9D0032BC  8FC20008   LW V0, 8(FP)
9D0032C0  AC430000   SW V1, 0(V0)
9D0032C4  0B400CBC   J 0x9D0032F0
9D0032C8  00000000   NOP
69:                  	}
70:                  	else
71:                  	{
72:                  		if(Head->End == Node)
9D0032CC  8FC20008   LW V0, 8(FP)
9D0032D0  8C430004   LW V1, 4(V0)
9D0032D4  8FC2000C   LW V0, 12(FP)
9D0032D8  14620005   BNE V1, V0, 0x9D0032F0
9D0032DC  00000000   NOP
73:                  			Head->End = Node->PreviousNode;
9D0032E0  8FC2000C   LW V0, 12(FP)
9D0032E4  8C430004   LW V1, 4(V0)
9D0032E8  8FC20008   LW V0, 8(FP)
9D0032EC  AC430004   SW V1, 4(V0)
74:                  	}
75:                  
76:                  	Node->NextNode = Node->PreviousNode = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D0032F0  8FC2000C   LW V0, 12(FP)
9D0032F4  AC400004   SW ZERO, 4(V0)
9D0032F8  8FC2000C   LW V0, 12(FP)
9D0032FC  8C430004   LW V1, 4(V0)
9D003300  8FC2000C   LW V0, 12(FP)
9D003304  AC430000   SW V1, 0(V0)
77:                  
78:                  	return Node;
9D003308  8FC2000C   LW V0, 12(FP)
79:                  }	
9D00330C  03C0E821   ADDU SP, FP, ZERO
9D003310  8FBE0004   LW FP, 4(SP)
9D003314  27BD0008   ADDIU SP, SP, 8
9D003318  03E00008   JR RA
9D00331C  00000000   NOP
80:                  
81:                  BOOL DoubleLinkedListHasData(DOUBLE_LINKED_LIST_HEAD *Head)
82:                  {
9D003320  27BDFFF8   ADDIU SP, SP, -8
9D003324  AFBE0004   SW FP, 4(SP)
9D003328  03A0F021   ADDU FP, SP, ZERO
9D00332C  AFC40008   SW A0, 8(FP)
83:                  	return (BOOL)(Head->Beginning != (DOUBLE_LINKED_LIST_NODE*)NULL);
9D003330  8FC20008   LW V0, 8(FP)
9D003334  8C420000   LW V0, 0(V0)
9D003338  10400004   BEQ V0, ZERO, 0x9D00334C
9D00333C  00000000   NOP
9D003340  24020001   ADDIU V0, ZERO, 1
9D003344  0B400CD4   J 0x9D003350
9D003348  00000000   NOP
9D00334C  00001021   ADDU V0, ZERO, ZERO
84:                  }
9D003350  03C0E821   ADDU SP, FP, ZERO
85:                  
86:                  #if (GET_DOUBLE_LINKED_LIST_SIZE == 1)
87:                  	UINT32 GetDoubleLinkedListSize(DOUBLE_LINKED_LIST_HEAD *Head)
88:                  	{
89:                  		UINT32 Size;
90:                  		DOUBLE_LINKED_LIST_NODE *Iterator;
91:                  
92:                  		if (Head->Beginning == (DOUBLE_LINKED_LIST_NODE*)NULL)
93:                  			return 0;
94:                  
95:                  		Iterator = Head->Beginning;
96:                  
97:                  		Size = 0;
98:                  
99:                  		do
100:                 		{
101:                 			Iterator = Iterator->NextNode;
102:                 			Size++;
103:                 		} while (Iterator != (DOUBLE_LINKED_LIST_NODE*)NULL);
104:                 
105:                 		return Size;
106:                 	}
107:                 #endif // end of #if (GET_DOUBLE_LINKED_LIST_SIZE == 1)
108:                 
109:                 #if (USING_ITERTATE_TO_NEXT_NODE_DOUBLE_LINKED_LIST == 1)
110:                 	DOUBLE_LINKED_LIST_NODE *IterateToNextNodeDoubleLinkedListNode(DOUBLE_LINKED_LIST_NODE *Node)
111:                 	{
112:                 		if(Node == (DOUBLE_LINKED_LIST_NODE*)NULL)
113:                 			return (DOUBLE_LINKED_LIST_NODE*)NULL;
114:                 
115:                 		return Node->NextNode;
116:                 	}
117:                 #endif // end of #if (USING_ITERTATE_TO_NEXT_NODE_DOUBLE_LINKED_LIST == 1)
---  c:/users/ben.danametrics/desktop/nexos/project/kerneltasks.c  --------------------------------------
1:                   #include <string.h>
2:                   
3:                   #include "Kernel.h"
4:                   #include "Memory.h"
5:                   #include "KernelTasks.h"
6:                   #include "CriticalSections.h"
7:                   #include "Callbacks.h"
8:                   
9:                   /*
10:                  	This is the Task code for when the Idle Task Executes.
11:                  */
12:                  UINT32 IdleTaskMethod(void *Args)
13:                  {
9D0041B8  27BDFFF8   ADDIU SP, SP, -8
9D0041BC  AFBE0004   SW FP, 4(SP)
9D0041C0  03A0F021   ADDU FP, SP, ZERO
9D0041C4  AFC40008   SW A0, 8(FP)
14:                      while(1)
15:                      {
16:                  		#if (USING_IDLE_TASK_USER_CALLBACK == 1)
17:                  			IdleTaskUserCallback(Args);
18:                  		#endif // end of #if (USING_IDLE_TASK_USER_CALLBACK != 1)
19:                  	}
9D0041C8  0B401072   J 0x9D0041C8
20:                  }
21:                  
22:                  #if (USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1)
23:                  	#include "Kernel.h"
24:                  	#include "Lists.h"
25:                  	#include "Task.h"
26:                  
27:                  	#if (USING_DELETE_TASK == 1)
28:                  		extern DOUBLE_LINKED_LIST_HEAD gDeleteTaskList;
29:                  
30:                  		static void MaintenanceDeleteTask(TASK *Task)
31:                  		{
32:                  			#if (USING_RESTART_TASK == 1)
33:                  				if(Task->RestartInfo != (TASK_RESTART_INFO*)NULL)
34:                  					ReleaseMemory((void*)Task->RestartInfo);
35:                  			#endif // end of #if (USING_RESTART_TASK == 1)
36:                  
37:                  			// make sure to delete the task checkin so no memory leaks occur
38:                  			#if (USING_TASK_CHECK_IN == 1)
39:                  				if(Task->TaskCheckIn != (TASK_CHECK_IN*)NULL)
40:                  					ReleaseMemory((void*)Task->TaskCheckIn);
41:                  			#endif // end of USING_TASK_CHECK_IN
42:                  
43:                  			#if (USING_MAILBOXES == 1)
44:                  				// Delete any unread messages
45:                  			#endif // end of USING_MAILBOXES
46:                  
47:                  			ReleaseMemory((void*)Task->StartOfTaskStackPointer);
48:                  	
49:                  			#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
50:                  				if(Task->TaskExitMethod != (void(*)(void))NULL)
51:                  					Task->TaskExitMethod();
52:                  			#endif // end of USING_TASK_EXIT_METHOD_CALLBACK
53:                  
54:                  			ReleaseMemory((void*)Task);
55:                  		}
56:                  	#endif // end of USING_DELETE_TASK
57:                  
58:                  	#if (USING_RESTART_TASK == 1)
59:                  		extern DOUBLE_LINKED_LIST_HEAD gRestartTaskList;
60:                  
61:                  		#if (USING_TASK_HIBERNATION == 1)
62:                  			extern DOUBLE_LINKED_LIST_HEAD gHibernationQueueHead;
63:                  		#endif // end of #if (USING_TASK_HIBERNATION == 1)
64:                  
65:                  		#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
66:                  			extern DOUBLE_LINKED_LIST_HEAD gSuspendedQueueHead;
67:                  		#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
68:                  
69:                  		static void MaintenanceRestartTask(TASK *Task)
70:                  		{
71:                  			UINT32 i;
72:                  
73:                  			ReleaseMemory((void*)Task->StartOfTaskStackPointer);
74:                  	
75:                  			// re-initialize the TASK stack
76:                  			Task->TaskStackPointer = OS_InitializeTaskStack(Task, Task->RestartInfo->StartingAddress, (void*)NULL, Task->RestartInfo->StartingTaskSize);
77:                  	
78:                  			// reset the critial count
79:                  			Task->CriticalCount = 0;
80:                  	
81:                  			// shouldn't be anything but 0, but just to be sure
82:                  			#if (USING_TASK_DELAY_METHOD == 1)
83:                  				Task->DelayInTicks = 0;
84:                  			#endif // end of USING_TASK_DELAY_METHOD
85:                  	
86:                  			Task->TaskState = Task->RestartInfo->TaskState;
87:                  			Task->TaskPriority = Task->RestartInfo->TaskPriority;
88:                  
89:                  			for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
90:                  				OS_InitializeTaskNode(&Task->TaskNodeArray[i], (void*)Task);
91:                  			
92:                  			// make sure to delete the task checkin so no memory leaks occur
93:                  			#if (USING_TASK_CHECK_IN == 1)
94:                  				if (Task->TaskCheckIn != (TASK_CHECK_IN*)NULL)
95:                  					ReleaseMemory((void*)Task->TaskCheckIn);
96:                  			#endif // end of USING_TASK_CHECK_IN
97:                  
98:                  			#if (USING_MAILBOXES == 1)
99:                  				// Delete any unread messages
100:                 			#endif // end of USING_MAILBOXES
101:                 
102:                 			EnterCritical();
103:                 			{
104:                 				switch (Task->TaskState)
105:                 				{
106:                 					case READY:
107:                 					{
108:                 						// we will always be higher priority than the TASK 
109:                 						// that is being added.  So we will not have to check
110:                 						// to see if we should surrender the CPU.
111:                 						OS_AddTaskToReadyQueue(Task);
112:                 
113:                 						break;
114:                 					}
115:                 
116:                 					#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
117:                 						case SUSPENDED:
118:                 						{
119:                 							OS_PlaceTaskOnBlockedList(Task, &gSuspendedQueueHead, &Task->TaskNodeArray[PRIMARY_TASK_NODE], SUSPENDED, FALSE);
120:                 
121:                 							break;
122:                 						}
123:                 					#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
124:                 
125:                 					#if (USING_TASK_HIBERNATION == 1)
126:                 						case HIBERNATING:
127:                 						{
128:                 							OS_PlaceTaskOnBlockedList(Task, &gHibernationQueueHead, &Task->TaskNodeArray[PRIMARY_TASK_NODE], HIBERNATING, FALSE);
129:                 
130:                 							break;
131:                 						}
132:                 					#endif // end of #if (USING_TASK_HIBERNATION == 1)
133:                 				}
134:                 			}
135:                 			ExitCritical();
136:                 		}		
137:                 	#endif // end of USING_RESTART_TASK
138:                 
139:                 	UINT32 MaintenanceTaskCode(void *Args)
140:                 	{
141:                 		DOUBLE_LINKED_LIST_NODE *Node;
142:                 		TASK *Task;		
143:                 
144:                 		while(1)
145:                 		{
146:                 			TaskDelayTicks(MAINTENANCE_TASK_PERIODICITY);
147:                 
148:                 			#if (USING_MAINTENANCE_TASK_USER_CALLBACK == 1)
149:                 				MaintenanceTaskUserCallback();
150:                 			#endif // end of USING_MAINTENANCE_TASK_USER_CALLBACK
151:                 
152:                 			#if (USING_DELETE_TASK == 1)
153:                 				EnterCritical();
154:                 				{
155:                 					while (DoubleLinkedListHasData(&gDeleteTaskList) == TRUE)
156:                 					{
157:                 						Node = RemoveNodeFromDoubleLinkedList(&gDeleteTaskList, gDeleteTaskList.Beginning);
158:                 
159:                 						ExitCritical();
160:                 
161:                 						Task = (TASK*)Node->Data;
162:                 
163:                 						MaintenanceDeleteTask(Task);
164:                 
165:                 						EnterCritical();
166:                 					}
167:                 				}
168:                 				ExitCritical();
169:                 			#endif // end of USING_DELETE_TASK
170:                 
171:                 			#if (USING_RESTART_TASK == 1)
172:                 				EnterCritical();
173:                 				{
174:                 					while (DoubleLinkedListHasData(&gRestartTaskList) == TRUE)
175:                 					{
176:                 						Node = RemoveNodeFromDoubleLinkedList(&gRestartTaskList, gRestartTaskList.Beginning);
177:                 
178:                 						ExitCritical();
179:                 
180:                 						Task = (TASK*)Node->Data;
181:                 
182:                 						MaintenanceRestartTask(Task);
183:                 
184:                 						EnterCritical();
185:                 					}
186:                 				}
187:                 				ExitCritical();
188:                 			#endif // end of USING_RESTART_TASK
189:                 		}
190:                 	}
191:                 #endif // end of USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1
192:                 
193:                 #if (USING_UART_BUFFERS == 1)
194:                 	#include "UARTBuffers.h"
195:                 	
196:                 	void UARTBufferTaskCode(void *Args)
197:                 	{
198:                 		BYTE i;
199:                 	
200:                 		while(1)
201:                 		{
202:                 			EnterCritical();
203:                 	
204:                 			for(i = 0; i < UART_NUMBER_OF_MODULES; i++)
205:                 				UARTBufferReadHardwareBuffer((UART_MODULE)i);
206:                 	
207:                 			ExitCritical();
208:                 	
209:                 			SurrenderCPU();
210:                 		}
211:                 	}
212:                 #endif // end of USING_UART_BUFFERS
---  c:/users/ben.danametrics/desktop/nexos/project/kernel.c  -------------------------------------------
1:                   #include <stdlib.h>
2:                   #include <string.h>
3:                   
4:                   #include "Kernel.h"
5:                   #include "CriticalSections.h"
6:                   #include "Task.h"
7:                   #include "KernelTasks.h"
8:                   #include "Port.h"
9:                   #include "Memory.h"
10:                  #include "Callbacks.h"
11:                  
12:                  #ifdef WINDOWS_ENVIRONMENT_TESTING
13:                  	PROCESS_INFORMATION gProcessInfo;
14:                  	STARTUPINFO StartupInfo;
15:                  #endif // end of #ifdef WINDOWS_ENVIRONMENT_TESTING
16:                  
17:                  #if (USING_SOFTWARE_TIMERS == 1)
18:                  	#include "SoftwareTimers.h"
19:                  #endif // end of USING_SOFTWARE_TIMERS
20:                  
21:                  #if (USING_CALLBACK_TIMERS == 1)
22:                  	#include "CallbackTimers.h"
23:                  #endif // end of USING_CALLBACK_TIMERS
24:                  
25:                  #if (USING_EVENT_TIMERS == 1)
26:                  	#include "EventTimers.h"
27:                  #endif // end of USING_EVENT_TIMERS
28:                  
29:                  #if (USING_EVENTS == 1)
30:                  	#include "Events.h"
31:                  #endif // end of USING_EVENTS
32:                  
33:                  #if (USING_RESOURCE_LOCKS == 1)
34:                  	#include "ResourceLock.h"
35:                  #endif // end of #if (USING_RESOURCE_LOCKS == 1)
36:                  
37:                  #if (USING_MAILBOXES == 1)
38:                  	#include "Mailbox.h"
39:                  #endif // end of USING_MAILBOXES
40:                  
41:                  #if (USING_UART_BUFFERS == 1)
42:                  	#include "UARTBuffers.h"
43:                  
44:                  	static TASK gUARTBufferTask;
45:                  #endif // end of USING_UART_BUFFERS
46:                  
47:                  // This is the critical count counter.  Each time a TASK calls a EnterCritical() 
48:                  // this variable is increased.  Each time a TASK called ExitCritical() this
49:                  // variable is decreased.  Once it gets back to zero, interrupts are enabled.
50:                  extern volatile OS_WORD gCurrentCriticalCount;
51:                  
52:                  static volatile UINT32 gOSTickCount;
53:                  static BOOL gCPUSchedulerRunning = FALSE;
54:                  static TASK gIdleTask;						// Dont even need this, but will keep it for now.
55:                  static volatile DOUBLE_LINKED_LIST_NODE *gCurrentNode;// A pointer to the DOUBLE_LINKED_LIST_NODE of the currently executing Task.
56:                  static BYTE gCurrentSystemPriority; 		// This is the priority of the currently executing Task, and is referenced to see
57:                  										 	// if there was a Task added to the Ready Queue that has a higher priority.
58:                  TASK * volatile gCurrentTask;			// Points to the currently executing Task.
59:                  DOUBLE_LINKED_LIST_HEAD gCPU_Scheduler[QUEUE_SIZE]; // The main guts of the Ready Queue.  This holds all the TASKs that are executing
60:                  
61:                  #if (USING_TASK_DELAY_TICKS_METHOD == 1)
62:                  	static DOUBLE_LINKED_LIST_HEAD gDelayQueue;
63:                  #endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
64:                  
65:                  #if (USING_TASK_HIBERNATION == 1)
66:                  	DOUBLE_LINKED_LIST_HEAD gHibernationQueueHead;
67:                  #endif // end of USING_TASK_HIBERNATION
68:                  
69:                  #if (USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1)
70:                  	DOUBLE_LINKED_LIST_HEAD gSuspendedQueueHead;			// This is the Head of the Suspended Queue.  It will only be used if any Suspended methods in Task.c are used.
71:                  #endif // end of USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1
72:                  
73:                  #if (USING_TASK_CHECK_IN == 1)
74:                  	DOUBLE_LINKED_LIST_HEAD gTaskCheckInList;
75:                  #endif // end of USING_TASK_CHECK_IN
76:                  
77:                  #if (USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1)
78:                  	static TASK gMaintenanceTask;
79:                  #endif // end of USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1
80:                  
81:                  #if (USING_DELETE_TASK == 1)
82:                  	DOUBLE_LINKED_LIST_HEAD gDeleteTaskList;
83:                  #endif // end of #if (USING_DELETE_TASK == 1)
84:                  
85:                  #if (USING_RESTART_TASK == 1)
86:                  	DOUBLE_LINKED_LIST_HEAD gRestartTaskList;
87:                  #endif // end of #if (USING_RESTART_TASK == 1)
88:                  
89:                  #if (USING_TASK_SIGNAL == 1)
90:                  	DOUBLE_LINKED_LIST_HEAD gSignalWaitTaskList;
91:                  #endif // end of #if (USING_TASK_SIGNAL == 1)
92:                  
93:                  //--------------------------------------------------------------------------------------------------//
94:                  //																									//
95:                  //				The user should only ever call the below four methods in this file.				//
96:                  //																									//
97:                  //--------------------------------------------------------------------------------------------------//
98:                  OS_RESULT InitOS(void)
99:                  {
9D000000  27BDFFE8   ADDIU SP, SP, -24
9D000004  AFBF0014   SW RA, 20(SP)
9D000008  AFBE0010   SW FP, 16(SP)
9D00000C  03A0F021   ADDU FP, SP, ZERO
100:                 	// should also init CPU scheduler and all modules.
101:                 	// the only thing in start os scheduler should be 
102:                 	// finding the first task, initializing the os timer
103:                 	// and starting the first task.
104:                 
105:                 	if (OS_InitializeHeap() == FALSE)
9D000010  0F400316   JAL OS_InitializeHeap
9D000014  00000000   NOP
9D000018  14400004   BNE V0, ZERO, 0x9D00002C
9D00001C  00000000   NOP
106:                 		return OS_HEAP_INITIALIZATION_FAILED;
9D000020  24020015   ADDIU V0, ZERO, 21
9D000024  0B40001D   J 0x9D000074
9D000028  00000000   NOP
107:                 
108:                 	// initialize all needed global variables
109:                 	memset((void*)gCPU_Scheduler, 0, sizeof(gCPU_Scheduler));
9D00002C  3C02A000   LUI V0, -24576
9D000030  24440238   ADDIU A0, V0, 568
9D000034  00002821   ADDU A1, ZERO, ZERO
9D000038  24060048   ADDIU A2, ZERO, 72
9D00003C  0F400F30   JAL memset
9D000040  00000000   NOP
110:                 
111:                 	gOSTickCount = 0;
9D000044  AF808010   SW ZERO, -32752(GP)
112:                 	gCurrentTask = &gIdleTask;
9D000048  3C02A001   LUI V0, -24575
9D00004C  2442C5D4   ADDIU V0, V0, -14892
9D000050  AF82803C   SW V0, -32708(GP)
113:                 	gCurrentCriticalCount = 0;
9D000054  AF80802C   SW ZERO, -32724(GP)
114:                 
115:                 	// initialize the delay queue
116:                 	#if (USING_TASK_DELAY_TICKS_METHOD == 1)
117:                 		InitializeDoubleLinkedListHead(&gDelayQueue);
9D000058  27848020   ADDIU A0, GP, -32736
9D00005C  0F400C3C   JAL InitializeDoubleLinkedListHead
9D000060  00000000   NOP
118:                 	#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
119:                 
120:                 	// initialize the suspended queue list
121:                 	#if (USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1)
122:                 		InitializeDoubleLinkedListHead(&gSuspendedQueueHead);
123:                 	#endif // end of USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_SUSPEND_TASK_METHOD == 1
124:                 
125:                 	// initialize the task hibernation list
126:                 	#if (USING_TASK_HIBERNATION == 1)
127:                 		InitializeDoubleLinkedListHead(&gHibernationQueueHead);
128:                 	#endif // end of USING_TASK_HIBERNATION
129:                 
130:                 	// initialize the task checkin list
131:                 	#if (USING_TASK_CHECK_IN == 1)
132:                 		InitializeDoubleLinkedListHead(&gTaskCheckInList);
133:                 	#endif // end of USING_TASK_CHECK_IN
134:                 
135:                 	// Initialize the delete list
136:                 	#if (USING_DELETE_TASK == 1)
137:                 		InitializeDoubleLinkedListHead(&gDeleteTaskList);
138:                 	#endif // end of USING_DELETE_TASK
139:                 
140:                 	// Initialize the restart list
141:                 	#if (USING_RESTART_TASK == 1)
142:                 		InitializeDoubleLinkedListHead(&gRestartTaskList);
143:                 	#endif // end of USING_RESTART_TASK
144:                 
145:                 	#if (USING_TASK_SIGNAL == 1)
146:                 		InitializeDoubleLinkedListHead(&gSignalWaitTaskList);
9D000064  27848034   ADDIU A0, GP, -32716
9D000068  0F400C3C   JAL InitializeDoubleLinkedListHead
9D00006C  00000000   NOP
147:                 	#endif // end of #if (USING_TASK_SIGNAL == 1)
148:                 
149:                 #if(0)
150:                 	// create the idle TASK
151:                 	if (CreateTask(	IdleTaskMethod, 
152:                 					IDLE_TASK_STACK_SIZE_IN_WORDS,
153:                 					IDLE_TASK_PRIORITY,
154:                 					IDLE_TASK_ARGS,
155:                 
156:                 					#if (USING_RESTART_TASK == 1)
157:                 						FALSE,
158:                 					#endif // end of #if (USING_RESTART_TASK == 1)
159:                 
160:                 					#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
161:                 						READY,
162:                 					#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
163:                 					
164:                 					#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
165:                 						FALSE,
166:                 					#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
167:                 
168:                 					#if(USING_TASK_NAMES == 1)
169:                 						IDLE_TASK_TASK_NAME,
170:                 					#endif // end of #if(USING_TASK_NAMES == 1)
171:                 
172:                 					#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
173:                 						(TASK_EXIT_CALLBACK)NULL,
174:                 					#endif // end of #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
175:                 
176:                 					&gIdleTask) == (TASK*)NULL)
177:                 		return OS_CREATE_IDLE_TASK_FAILED;
178:                 #endif
179:                 	// create the maintenance TASK
180:                 	#if (USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1)
181:                 		if (CreateTask(	MaintenanceTaskCode,
182:                 						MAINTENANCE_TASK_STACK_SIZE_IN_WORDS,
183:                 						MAINTENANCE_TASK_PRIORITY,
184:                 						(void*)NULL,
185:                 
186:                 						#if (USING_RESTART_TASK == 1)
187:                 							FALSE,
188:                 						#endif // end of #if (USING_RESTART_TASK == 1)
189:                 
190:                 						#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
191:                 							READY,
192:                 						#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1 || USING_TASK_HIBERNATION == 1)
193:                 						
194:                 						#if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
195:                 							FALSE,
196:                 						#endif // end of #if (USING_SUSPEND_TASK_METHOD == 1 || USING_SUSPEND_ALL_TASKS_METHOD == 1)
197:                 
198:                 						#if(USING_TASK_NAMES == 1)
199:                 							MAINTENANCE_TASK_TASK_NAME,
200:                 						#endif // end of #if(USING_TASK_NAMES == 1)
201:                 
202:                 						#if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
203:                 							(TASK_EXIT_CALLBACK)NULL,
204:                 						#endif // end of #if (USING_TASK_EXIT_METHOD_CALLBACK == 1)
205:                 
206:                 						&gMaintenanceTask) == (TASK*)NULL)
207:                 			return OS_CREATE_MAINTENANCE_TASK_FAILED;
208:                 	#endif // end of USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1
209:                 
210:                 	#if (USING_UART_BUFFERS == 1)
211:                 		if (CreateTask(UARTBufferTaskCode, UART_BUFFER_TASK_STACK_SIZE_IN_WORDS, UART_BUFFER_TASK_PRIORITY, FALSE, READY, FALSE, UART_BUFFER_TASK_TASK_NAME, NULL, NULL, &gUARTBufferTask) == (TASK*)NULL)
212:                 			return OS_CREATE_BUFFER_TASK_FAILED;
213:                 	#endif // end of USING_UART_BUFFERS
214:                 
215:                 	#if (USING_SOFTWARE_TIMERS == 1)
216:                 		if (OS_InitSoftwareTimerLib() == FALSE)
217:                 			return OS_INITIALIZE_TIMER_LIB_FAILED;
218:                 	#endif // end of #if (USING_SOFTWARE_TIMERS == 1)
219:                 
220:                 	#if (USING_CALLBACK_TIMERS == 1)
221:                 		if (OS_InitCallbackTimersLib() == FALSE)
222:                 			return OS_INITIALIZE_CALLBACK_TIMER_LIB_FAILED;
223:                 	#endif // end of #if (USING_CALLBACK_TIMERS == 1)
224:                 
225:                 	#if (USING_EVENTS == 1)
226:                 		if (OS_InitEventsLib() == FALSE)
227:                 			return OS_INITIALIZE_EVENTS_LIB_FAILED;
228:                 	#endif // end of USING_EVENTS
229:                 
230:                 	#if (USING_EVENT_TIMERS == 1)
231:                 		if (OS_InitEventTimersLib() == FALSE)
232:                 			return OS_INITIALIZE_EVENT_TIMERS_LIB_FAILED;
233:                 	#endif // end of USING_EVENT_TIMERS
234:                 
235:                 	#if (USING_RESOURCE_LOCKS == 1)
236:                 		if (OS_InitResourceLocksLib() == FALSE)
237:                 			return OS_INITIALIZE_RESOURCE_LOCKS_FAILED;
238:                 	#endif // end of #if (USING_RESOURCE_LOCKS == 1)
239:                 
240:                 	#if (USING_UART_BUFFERS == 1)
241:                 		if (InitUARTBuffers() == FALSE)
242:                 			return OS_INITIALIZE_UART_BUFFERS_FAILED;
243:                 	#endif // end of USING_UART_BUFFERS
244:                 
245:                 	return OS_SUCCESS;
9D000070  00001021   ADDU V0, ZERO, ZERO
246:                 }
9D000074  03C0E821   ADDU SP, FP, ZERO
9D000078  8FBF0014   LW RA, 20(SP)
9D00007C  8FBE0010   LW FP, 16(SP)
9D000080  27BD0018   ADDIU SP, SP, 24
9D000084  03E00008   JR RA
9D000088  00000000   NOP
247:                 
248:                 void StartOSScheduler(void)
249:                 {
9D00008C  27BDFFE0   ADDIU SP, SP, -32
9D000090  AFBF001C   SW RA, 28(SP)
9D000094  AFBE0018   SW FP, 24(SP)
9D000098  03A0F021   ADDU FP, SP, ZERO
250:                 	BYTE i = HIGHEST_USER_TASK_PRIORITY;
9D00009C  24020007   ADDIU V0, ZERO, 7
9D0000A0  A3C20010   SB V0, 16(FP)
251:                 
252:                 	// search for the first task to run
253:                 	while (gCPU_Scheduler[i].Beginning == (DOUBLE_LINKED_LIST_NODE*)NULL)
9D0000A4  0B40002E   J 0x9D0000B8
9D0000A8  00000000   NOP
9D0000B8  93C30010   LBU V1, 16(FP)
9D0000BC  3C02A000   LUI V0, -24576
9D0000C0  000318C0   SLL V1, V1, 3
9D0000C4  24420238   ADDIU V0, V0, 568
9D0000C8  00621021   ADDU V0, V1, V0
9D0000CC  8C420000   LW V0, 0(V0)
9D0000D0  1040FFF6   BEQ V0, ZERO, 0x9D0000AC
9D0000D4  00000000   NOP
254:                 		i--;
9D0000AC  93C20010   LBU V0, 16(FP)
9D0000B0  2442FFFF   ADDIU V0, V0, -1
9D0000B4  A3C20010   SB V0, 16(FP)
255:                 
256:                 	gCurrentTask = (TASK*)gCPU_Scheduler[i].Beginning->Data;
9D0000D8  93C30010   LBU V1, 16(FP)
9D0000DC  3C02A000   LUI V0, -24576
9D0000E0  000318C0   SLL V1, V1, 3
9D0000E4  24420238   ADDIU V0, V0, 568
9D0000E8  00621021   ADDU V0, V1, V0
9D0000EC  8C420000   LW V0, 0(V0)
9D0000F0  8C420008   LW V0, 8(V0)
9D0000F4  AF82803C   SW V0, -32708(GP)
257:                 	gCurrentNode = gCPU_Scheduler[i].Beginning;
9D0000F8  93C30010   LBU V1, 16(FP)
9D0000FC  3C02A000   LUI V0, -24576
9D000100  000318C0   SLL V1, V1, 3
9D000104  24420238   ADDIU V0, V0, 568
9D000108  00621021   ADDU V0, V1, V0
9D00010C  8C420000   LW V0, 0(V0)
9D000110  AF828018   SW V0, -32744(GP)
258:                 
259:                 	// set the system priority to the currently selected TASK
260:                 	gCurrentSystemPriority = gCurrentTask->TaskPriority;
9D000114  8F82803C   LW V0, -32708(GP)
9D000118  90420028   LBU V0, 40(V0)
9D00011C  A382801C   SB V0, -32740(GP)
261:                 
262:                 	gCPUSchedulerRunning = TRUE;
9D000120  24020001   ADDIU V0, ZERO, 1
9D000124  AF828014   SW V0, -32748(GP)
263:                 
264:                 	PortStartOSScheduler();
9D000128  0F400B8C   JAL PortStartOSScheduler
9D00012C  00000000   NOP
265:                 
266:                 	#ifndef WINDOWS_ENVIRONMENT_TESTING
267:                 		OS_StartFirstTask((OS_WORD*)(gCurrentTask->TaskStackPointer));
9D000130  8F82803C   LW V0, -32708(GP)
9D000134  8C420020   LW V0, 32(V0)
9D000138  00402021   ADDU A0, V0, ZERO
9D00013C  0F400DCE   JAL OS_StartFirstTask
9D000140  00000000   NOP
268:                 	#else
269:                 		OS_StartFirstTask(gCurrentTask);
270:                 	#endif // end of #if WINDOWS_ENVIRONMENT_TESTING
271:                 }
9D000144  03C0E821   ADDU SP, FP, ZERO
9D000148  8FBF001C   LW RA, 28(SP)
9D00014C  8FBE0018   LW FP, 24(SP)
9D000150  27BD0020   ADDIU SP, SP, 32
9D000154  03E00008   JR RA
9D000158  00000000   NOP
272:                 
273:                 UINT32 GetOSTickCount(void)
274:                 {
9D00015C  27BDFFF8   ADDIU SP, SP, -8
9D000160  AFBE0004   SW FP, 4(SP)
9D000164  03A0F021   ADDU FP, SP, ZERO
275:                 	return gOSTickCount;
9D000168  8F828010   LW V0, -32752(GP)
276:                 }
9D00016C  03C0E821   ADDU SP, FP, ZERO
9D000170  8FBE0004   LW FP, 4(SP)
9D000174  27BD0008   ADDIU SP, SP, 8
9D000178  03E00008   JR RA
9D00017C  00000000   NOP
277:                 
278:                 //--------------------------------------------------------------------------------------------------//
279:                 //																									//
280:                 //									End user callable section										//
281:                 //																									//
282:                 //--------------------------------------------------------------------------------------------------//
283:                 
284:                 
285:                 
286:                 
287:                 
288:                 
289:                 
290:                 
291:                 
292:                 
293:                 
294:                 //--------------------------------------------------------------------------------------------------//
295:                 //																									//
296:                 //						The user should NEVER call any of the below methods							//
297:                 //																									//
298:                 //--------------------------------------------------------------------------------------------------//
299:                 
300:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
301:                 // OS CPU Scheudler manipulation related functions beginning
302:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
303:                 
304:                 /*
305:                 	This method will add the specified Task to the Ready Queue and makes sure all the pointers to the next and previous nodes
306:                 	of all the involved Tasks are pointing to the correct nodes.
307:                 */
308:                 static void OS_AddTaskToCPUScheduler(TASK *TaskToAdd)
309:                 {
9D000180  27BDFFF8   ADDIU SP, SP, -8
9D000184  AFBE0004   SW FP, 4(SP)
9D000188  03A0F021   ADDU FP, SP, ZERO
9D00018C  AFC40008   SW A0, 8(FP)
310:                 	TaskToAdd->TaskState = READY;
9D000190  8FC20008   LW V0, 8(FP)
9D000194  AC400024   SW ZERO, 36(V0)
311:                 
312:                 	if (gCPU_Scheduler[TaskToAdd->TaskPriority].End == (DOUBLE_LINKED_LIST_NODE*)NULL)
9D000198  8FC20008   LW V0, 8(FP)
9D00019C  90420028   LBU V0, 40(V0)
9D0001A0  3C03A000   LUI V1, -24576
9D0001A4  24630238   ADDIU V1, V1, 568
9D0001A8  000210C0   SLL V0, V0, 3
9D0001AC  00621021   ADDU V0, V1, V0
9D0001B0  8C420004   LW V0, 4(V0)
9D0001B4  1440001F   BNE V0, ZERO, 0x9D000234
9D0001B8  00000000   NOP
313:                 	{
314:                 		// there are no other tasks at this priority
315:                 		gCPU_Scheduler[TaskToAdd->TaskPriority].End = gCPU_Scheduler[TaskToAdd->TaskPriority].Beginning = &(TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode);
9D0001BC  8FC20008   LW V0, 8(FP)
9D0001C0  90420028   LBU V0, 40(V0)
9D0001C4  00402821   ADDU A1, V0, ZERO
9D0001C8  8FC20008   LW V0, 8(FP)
9D0001CC  90420028   LBU V0, 40(V0)
9D0001D0  8FC40008   LW A0, 8(FP)
9D0001D4  3C03A000   LUI V1, -24576
9D0001D8  000230C0   SLL A2, V0, 3
9D0001DC  24630238   ADDIU V1, V1, 568
9D0001E0  00C31821   ADDU V1, A2, V1
9D0001E4  AC640000   SW A0, 0(V1)
9D0001E8  3C04A000   LUI A0, -24576
9D0001EC  000218C0   SLL V1, V0, 3
9D0001F0  24820238   ADDIU V0, A0, 568
9D0001F4  00621021   ADDU V0, V1, V0
9D0001F8  8C430000   LW V1, 0(V0)
9D0001FC  3C02A000   LUI V0, -24576
9D000200  24440238   ADDIU A0, V0, 568
9D000204  000510C0   SLL V0, A1, 3
9D000208  00821021   ADDU V0, A0, V0
9D00020C  AC430004   SW V1, 4(V0)
316:                 
317:                 		TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.NextNode = TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode = &(TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode);
9D000210  8FC30008   LW V1, 8(FP)
9D000214  8FC20008   LW V0, 8(FP)
9D000218  AC430004   SW V1, 4(V0)
9D00021C  8FC20008   LW V0, 8(FP)
9D000220  8C430004   LW V1, 4(V0)
9D000224  8FC20008   LW V0, 8(FP)
9D000228  AC430000   SW V1, 0(V0)
9D00022C  0B4000BB   J 0x9D0002EC
9D000230  00000000   NOP
318:                 	}
319:                 	else
320:                 	{
321:                 		// Add it to the end of the list at the specified priority
322:                 		gCPU_Scheduler[TaskToAdd->TaskPriority].End->NextNode = &(TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode);
9D000234  8FC20008   LW V0, 8(FP)
9D000238  90420028   LBU V0, 40(V0)
9D00023C  3C03A000   LUI V1, -24576
9D000240  24630238   ADDIU V1, V1, 568
9D000244  000210C0   SLL V0, V0, 3
9D000248  00621021   ADDU V0, V1, V0
9D00024C  8C420004   LW V0, 4(V0)
9D000250  8FC30008   LW V1, 8(FP)
9D000254  AC430000   SW V1, 0(V0)
323:                 
324:                 		TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode = gCPU_Scheduler[TaskToAdd->TaskPriority].End;
9D000258  8FC20008   LW V0, 8(FP)
9D00025C  90420028   LBU V0, 40(V0)
9D000260  3C03A000   LUI V1, -24576
9D000264  24630238   ADDIU V1, V1, 568
9D000268  000210C0   SLL V0, V0, 3
9D00026C  00621021   ADDU V0, V1, V0
9D000270  8C430004   LW V1, 4(V0)
9D000274  8FC20008   LW V0, 8(FP)
9D000278  AC430004   SW V1, 4(V0)
325:                 
326:                 		gCPU_Scheduler[TaskToAdd->TaskPriority].End = &(TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode);
9D00027C  8FC20008   LW V0, 8(FP)
9D000280  90420028   LBU V0, 40(V0)
9D000284  8FC30008   LW V1, 8(FP)
9D000288  3C04A000   LUI A0, -24576
9D00028C  24840238   ADDIU A0, A0, 568
9D000290  000210C0   SLL V0, V0, 3
9D000294  00821021   ADDU V0, A0, V0
9D000298  AC430004   SW V1, 4(V0)
327:                 
328:                 		TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.NextNode = gCPU_Scheduler[TaskToAdd->TaskPriority].Beginning;
9D00029C  8FC20008   LW V0, 8(FP)
9D0002A0  90420028   LBU V0, 40(V0)
9D0002A4  00401821   ADDU V1, V0, ZERO
9D0002A8  3C02A000   LUI V0, -24576
9D0002AC  000318C0   SLL V1, V1, 3
9D0002B0  24420238   ADDIU V0, V0, 568
9D0002B4  00621021   ADDU V0, V1, V0
9D0002B8  8C430000   LW V1, 0(V0)
9D0002BC  8FC20008   LW V0, 8(FP)
9D0002C0  AC430000   SW V1, 0(V0)
329:                 
330:                 		gCPU_Scheduler[TaskToAdd->TaskPriority].Beginning->PreviousNode = &(TaskToAdd->TaskNodeArray[PRIMARY_TASK_NODE].ListNode);
9D0002C4  8FC20008   LW V0, 8(FP)
9D0002C8  90420028   LBU V0, 40(V0)
9D0002CC  00401821   ADDU V1, V0, ZERO
9D0002D0  3C02A000   LUI V0, -24576
9D0002D4  000318C0   SLL V1, V1, 3
9D0002D8  24420238   ADDIU V0, V0, 568
9D0002DC  00621021   ADDU V0, V1, V0
9D0002E0  8C420000   LW V0, 0(V0)
9D0002E4  8FC30008   LW V1, 8(FP)
9D0002E8  AC430004   SW V1, 4(V0)
331:                 	}
332:                 }
9D0002EC  03C0E821   ADDU SP, FP, ZERO
9D0002F0  8FBE0004   LW FP, 4(SP)
9D0002F4  27BD0008   ADDIU SP, SP, 8
9D0002F8  03E00008   JR RA
9D0002FC  00000000   NOP
333:                 
334:                 /*
335:                 	This method will remove the specified Task from the Ready Queue.
336:                 */
337:                 static void OS_RemoveTaskFromCPUScheduler(TASK *TaskToRemove)
338:                 {	
9D000300  27BDFFF8   ADDIU SP, SP, -8
9D000304  AFBE0004   SW FP, 4(SP)
9D000308  03A0F021   ADDU FP, SP, ZERO
9D00030C  AFC40008   SW A0, 8(FP)
339:                 	// The next item in the list has its previous pointer pointing to the same item that TaskToRemove->SystemQueueTaskNode.PreviousItem is pointing to
340:                 	TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.NextNode->PreviousNode = TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode;
9D000310  8FC20008   LW V0, 8(FP)
9D000314  8C420000   LW V0, 0(V0)
9D000318  8FC30008   LW V1, 8(FP)
9D00031C  8C630004   LW V1, 4(V1)
9D000320  AC430004   SW V1, 4(V0)
341:                 
342:                 	// The previous item in the list has its next pointer to the one after the item being removed.
343:                 	TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode->NextNode = TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.NextNode;
9D000324  8FC20008   LW V0, 8(FP)
9D000328  8C420004   LW V0, 4(V0)
9D00032C  8FC30008   LW V1, 8(FP)
9D000330  8C630000   LW V1, 0(V1)
9D000334  AC430000   SW V1, 0(V0)
344:                 
345:                 	// If the item were removing is the beginning of the list its being removed from
346:                 	if (&(TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode) == gCPU_Scheduler[TaskToRemove->TaskPriority].Beginning)
9D000338  8FC30008   LW V1, 8(FP)
9D00033C  8FC20008   LW V0, 8(FP)
9D000340  90420028   LBU V0, 40(V0)
9D000344  00402021   ADDU A0, V0, ZERO
9D000348  3C02A000   LUI V0, -24576
9D00034C  000420C0   SLL A0, A0, 3
9D000350  24420238   ADDIU V0, V0, 568
9D000354  00821021   ADDU V0, A0, V0
9D000358  8C420000   LW V0, 0(V0)
9D00035C  1462002E   BNE V1, V0, 0x9D000418
9D000360  00000000   NOP
347:                 	{
348:                 		// If TaskToRemove is the beginning of the list but not the end of the list, then there is another Task that has the same priority
349:                 		if (&(TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode) != gCPU_Scheduler[TaskToRemove->TaskPriority].End)
9D000364  8FC30008   LW V1, 8(FP)
9D000368  8FC20008   LW V0, 8(FP)
9D00036C  90420028   LBU V0, 40(V0)
9D000370  3C04A000   LUI A0, -24576
9D000374  24840238   ADDIU A0, A0, 568
9D000378  000210C0   SLL V0, V0, 3
9D00037C  00821021   ADDU V0, A0, V0
9D000380  8C420004   LW V0, 4(V0)
9D000384  1062000D   BEQ V1, V0, 0x9D0003BC
9D000388  00000000   NOP
350:                 		{
351:                 			// Make the beginning pointer point to the next item since its confirmed to be in the same list
352:                 			gCPU_Scheduler[TaskToRemove->TaskPriority].Beginning = TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.NextNode;
9D00038C  8FC20008   LW V0, 8(FP)
9D000390  90420028   LBU V0, 40(V0)
9D000394  00402021   ADDU A0, V0, ZERO
9D000398  8FC20008   LW V0, 8(FP)
9D00039C  8C430000   LW V1, 0(V0)
9D0003A0  3C02A000   LUI V0, -24576
9D0003A4  000420C0   SLL A0, A0, 3
9D0003A8  24420238   ADDIU V0, V0, 568
9D0003AC  00821021   ADDU V0, A0, V0
9D0003B0  AC430000   SW V1, 0(V0)
9D0003B4  0B400119   J 0x9D000464
9D0003B8  00000000   NOP
353:                 		}
354:                 		else
355:                 		{
356:                 			//if were the beginning and end of the list of the list, then were the only
357:                 			// node in the list.  therefore once were gone the beginning and end pointers of this list must be NULL.
358:                 			gCPU_Scheduler[TaskToRemove->TaskPriority].Beginning = gCPU_Scheduler[TaskToRemove->TaskPriority].End = NULL;
9D0003BC  8FC20008   LW V0, 8(FP)
9D0003C0  90420028   LBU V0, 40(V0)
9D0003C4  00402021   ADDU A0, V0, ZERO
9D0003C8  8FC20008   LW V0, 8(FP)
9D0003CC  90420028   LBU V0, 40(V0)
9D0003D0  00401821   ADDU V1, V0, ZERO
9D0003D4  3C02A000   LUI V0, -24576
9D0003D8  24450238   ADDIU A1, V0, 568
9D0003DC  000310C0   SLL V0, V1, 3
9D0003E0  00A21021   ADDU V0, A1, V0
9D0003E4  AC400004   SW ZERO, 4(V0)
9D0003E8  3C02A000   LUI V0, -24576
9D0003EC  24450238   ADDIU A1, V0, 568
9D0003F0  000310C0   SLL V0, V1, 3
9D0003F4  00A21021   ADDU V0, A1, V0
9D0003F8  8C430004   LW V1, 4(V0)
9D0003FC  3C02A000   LUI V0, -24576
9D000400  000420C0   SLL A0, A0, 3
9D000404  24420238   ADDIU V0, V0, 568
9D000408  00821021   ADDU V0, A0, V0
9D00040C  AC430000   SW V1, 0(V0)
9D000410  0B400119   J 0x9D000464
9D000414  00000000   NOP
359:                 		}
360:                 	}
361:                 	else
362:                 	{
363:                 		// if were not the beginning check to see if were the end.
364:                 		if (&(TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode) == gCPU_Scheduler[TaskToRemove->TaskPriority].End)
9D000418  8FC30008   LW V1, 8(FP)
9D00041C  8FC20008   LW V0, 8(FP)
9D000420  90420028   LBU V0, 40(V0)
9D000424  3C04A000   LUI A0, -24576
9D000428  24840238   ADDIU A0, A0, 568
9D00042C  000210C0   SLL V0, V0, 3
9D000430  00821021   ADDU V0, A0, V0
9D000434  8C420004   LW V0, 4(V0)
9D000438  1462000A   BNE V1, V0, 0x9D000464
9D00043C  00000000   NOP
365:                 		{
366:                 			// sice we know were not the beginning but we are the end, our previous item must be of the same priority
367:                 			// and in the the same list.  so make the end pointer point to it.
368:                 			gCPU_Scheduler[TaskToRemove->TaskPriority].End = TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode;
9D000440  8FC20008   LW V0, 8(FP)
9D000444  90420028   LBU V0, 40(V0)
9D000448  8FC30008   LW V1, 8(FP)
9D00044C  8C630004   LW V1, 4(V1)
9D000450  3C04A000   LUI A0, -24576
9D000454  24840238   ADDIU A0, A0, 568
9D000458  000210C0   SLL V0, V0, 3
9D00045C  00821021   ADDU V0, A0, V0
9D000460  AC430004   SW V1, 4(V0)
369:                 		}
370:                 	}
371:                 
372:                 	// now clear out the queue node data pointers
373:                 	TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.NextNode = TaskToRemove->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode = (DOUBLE_LINKED_LIST_NODE*)NULL;
9D000464  8FC20008   LW V0, 8(FP)
9D000468  AC400004   SW ZERO, 4(V0)
9D00046C  8FC20008   LW V0, 8(FP)
9D000470  8C430004   LW V1, 4(V0)
9D000474  8FC20008   LW V0, 8(FP)
9D000478  AC430000   SW V1, 0(V0)
374:                 }
9D00047C  03C0E821   ADDU SP, FP, ZERO
9D000480  8FBE0004   LW FP, 4(SP)
9D000484  27BD0008   ADDIU SP, SP, 8
9D000488  03E00008   JR RA
9D00048C  00000000   NOP
375:                 
376:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
377:                 // OS CPU Scheudler manipulation related functions end
378:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
379:                 
380:                 
381:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
382:                 // OS Timer Tick related functions beginning
383:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
384:                 
385:                 #if (USING_TASK_CHECK_IN == 1)
386:                 	#if (USING_RESTART_TASK != 1)
387:                 		#error "USING_RESTART_TASK in RTOSConfig.h must be defined as 1 if USING_TASK_CHECK_IN is defined as 1!"
388:                 	#endif // end of USING_RESTART_TASK
389:                 
390:                 	#if (USING_DELETE_TASK != 1)
391:                 		#error "USING_DELETE_TASK in RTOSConfig.h must be defined as 1 if USING_TASK_CHECK_IN is defined as 1!"
392:                 	#endif // end of USING_RESTART_TASK
393:                 	
394:                 	void OS_UpdateTaskCheckIn(void)
395:                 	{
396:                 		DOUBLE_LINKED_LIST_NODE *Node = gTaskCheckInList.Beginning;
397:                 		TASK *Task;
398:                 		
399:                 		// Iterate through the task list and see if everyones checking in
400:                 		while(Node != (DOUBLE_LINKED_LIST_NODE*)NULL)
401:                 		{
402:                 			Task = (TASK*)(Node->Data);
403:                 	
404:                 			Task->TaskCheckIn->CurrentCount++;
405:                 	
406:                 			Node = (DOUBLE_LINKED_LIST_NODE*)(Node->NextNode);
407:                 
408:                 			if(Task->TaskCheckIn->CurrentCount == Task->TaskCheckIn->Timeout)
409:                 			{
410:                 				Task->TaskCheckIn->CurrentCount = 0;
411:                 
412:                 				// restart or delete the Task
413:                 				#if (USING_TASK_CHECK_IN_USER_CALLBACK == 1)
414:                 					if(TaskCheckInUserCallback(Task) == TRUE)
415:                 					{
416:                 						if (Task->RestartInfo == (TASK_RESTART_INFO*)NULL)
417:                 						{
418:                 							OS_DeleteTask(Task);
419:                 						}
420:                 						else
421:                 						{
422:                 							OS_RestartTask(Task);
423:                 						}
424:                 					}
425:                 				#endif // end of #if (USING_TASK_CHECK_IN_USER_CALLBACK == 1)
426:                 			}
427:                 		}
428:                 	}
429:                 #endif // end of USING_TASK_CHECK_IN
430:                 
431:                 #if (USING_TASK_DELAY_TICKS_METHOD == 1)
432:                 	static void OS_UpdateTaskDelayList(void)
433:                 	{
9D000490  27BDFFD8   ADDIU SP, SP, -40
9D000494  AFBF0024   SW RA, 36(SP)
9D000498  AFBE0020   SW FP, 32(SP)
9D00049C  03A0F021   ADDU FP, SP, ZERO
434:                 		DOUBLE_LINKED_LIST_NODE *TempCurrentNode, *TempNextNode;
435:                 		TASK *TempTask;
436:                 		UINT32 i;
437:                 
438:                 		// now update the timer list
439:                 		// we just have to iterate through and see if anybody is done yet
440:                 		TempCurrentNode = gDelayQueue.Beginning;
9D0004A0  8F828020   LW V0, -32736(GP)
9D0004A4  AFC20010   SW V0, 16(FP)
441:                 
442:                 		while (TempCurrentNode != (DOUBLE_LINKED_LIST_NODE*)NULL)
9D0004A8  0B400154   J 0x9D000550
9D0004AC  00000000   NOP
9D000550  8FC20010   LW V0, 16(FP)
9D000554  1440FFD6   BNE V0, ZERO, 0x9D0004B0
9D000558  00000000   NOP
443:                 		{
444:                 			TempNextNode = TempCurrentNode->NextNode;
9D0004B0  8FC20010   LW V0, 16(FP)
9D0004B4  8C420000   LW V0, 0(V0)
9D0004B8  AFC20018   SW V0, 24(FP)
445:                 
446:                 			TempTask = (TASK*)TempCurrentNode->Data;
9D0004BC  8FC20010   LW V0, 16(FP)
9D0004C0  8C420008   LW V0, 8(V0)
9D0004C4  AFC2001C   SW V0, 28(FP)
447:                 
448:                 			TempTask->DelayInTicks--;
9D0004C8  8FC2001C   LW V0, 28(FP)
9D0004CC  8C420030   LW V0, 48(V0)
9D0004D0  2443FFFF   ADDIU V1, V0, -1
9D0004D4  8FC2001C   LW V0, 28(FP)
9D0004D8  AC430030   SW V1, 48(V0)
449:                 
450:                 			if (TempTask->DelayInTicks == 0)
9D0004DC  8FC2001C   LW V0, 28(FP)
9D0004E0  8C420030   LW V0, 48(V0)
9D0004E4  14400018   BNE V0, ZERO, 0x9D000548
9D0004E8  00000000   NOP
451:                 			{
452:                 				// remove all the nodes from any lists they were on
453:                 				for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
9D0004EC  AFC00014   SW ZERO, 20(FP)
9D0004F0  0B400148   J 0x9D000520
9D0004F4  00000000   NOP
9D000514  8FC20014   LW V0, 20(FP)
9D000518  24420001   ADDIU V0, V0, 1
9D00051C  AFC20014   SW V0, 20(FP)
9D000520  8FC20014   LW V0, 20(FP)
9D000524  2C420002   SLTIU V0, V0, 2
9D000528  1440FFF3   BNE V0, ZERO, 0x9D0004F8
9D00052C  00000000   NOP
454:                 					OS_RemoveTaskFromList(&TempTask->TaskNodeArray[i]);
9D0004F8  8FC3001C   LW V1, 28(FP)
9D0004FC  8FC20014   LW V0, 20(FP)
9D000500  00021100   SLL V0, V0, 4
9D000504  00621021   ADDU V0, V1, V0
9D000508  00402021   ADDU A0, V0, ZERO
9D00050C  0F4002D6   JAL OS_RemoveTaskFromList
9D000510  00000000   NOP
455:                 
456:                 				// now set the indicator which means the timeout was done.
457:                 				TempTask->DelayInTicks = TASK_TIMEOUT_DONE_VALUE;
9D000530  8FC2001C   LW V0, 28(FP)
9D000534  2403FFFF   ADDIU V1, ZERO, -1
9D000538  AC430030   SW V1, 48(V0)
458:                 
459:                 				// now add it to the READY_QUEUE
460:                 				OS_AddTaskToReadyQueue(TempTask);
9D00053C  8FC4001C   LW A0, 28(FP)
9D000540  0F4001F8   JAL OS_AddTaskToReadyQueue
9D000544  00000000   NOP
461:                 			}
462:                 
463:                 			TempCurrentNode = TempNextNode;
9D000548  8FC20018   LW V0, 24(FP)
9D00054C  AFC20010   SW V0, 16(FP)
464:                 		}
465:                 	}
9D00055C  03C0E821   ADDU SP, FP, ZERO
9D000560  8FBF0024   LW RA, 36(SP)
9D000564  8FBE0020   LW FP, 32(SP)
9D000568  27BD0028   ADDIU SP, SP, 40
9D00056C  03E00008   JR RA
9D000570  00000000   NOP
466:                 #endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
467:                 
468:                 static void UpdateOSTick(UINT32 CurrentOSTickCount)
469:                 {
9D000574  27BDFFE8   ADDIU SP, SP, -24
9D000578  AFBF0014   SW RA, 20(SP)
9D00057C  AFBE0010   SW FP, 16(SP)
9D000580  03A0F021   ADDU FP, SP, ZERO
9D000584  AFC40018   SW A0, 24(FP)
470:                 	// we have to update OS tick
471:                 	PortClearOSTickTimerInterruptFlag();
9D000588  00002021   ADDU A0, ZERO, ZERO
9D00058C  0F40103F   JAL INTClearFlag
9D000590  00000000   NOP
472:                 	
473:                 	// allow the hardware to update any timer related values for the next tick.
474:                 	PortUpdateOSTimer();
9D000594  34049C40   ORI A0, ZERO, -25536
9D000598  0F40108B   JAL UpdateCoreTimer
9D00059C  00000000   NOP
475:                 
476:                 	#if (USING_OS_TICK_UPDATE_USER_CALLBACK == 1)
477:                 		OSTickUpdateUserCallback(CurrentOSTickCount);
478:                 	#endif // end of USING_OS_TICK_UPDATE_USER_CALLBACK
479:                 
480:                 	#if (USING_TASK_DELAY_TICKS_METHOD == 1)
481:                 		OS_UpdateTaskDelayList();
9D0005A0  0F400124   JAL OS_UpdateTaskDelayList
9D0005A4  00000000   NOP
482:                 	#endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
483:                 
484:                 	#if(USING_SOFTWARE_TIMERS == 1)
485:                 		OS_UpdateSoftwareTimers();
486:                 	#endif // end of USING_SOFTWARE_TIMERS
487:                 
488:                 	#if(USING_CALLBACK_TIMERS == 1)
489:                 		OS_UpdateCallbackTimers(CurrentOSTickCount);
490:                 	#endif // end of USING_CALLBACK_TIMERS
491:                 
492:                 	#if (USING_TASK_CHECK_IN == 1)
493:                 		OS_UpdateTaskCheckIn();
494:                 	#endif // end of USING_TASK_CHECK_IN
495:                 }
9D0005A8  03C0E821   ADDU SP, FP, ZERO
9D0005AC  8FBF0014   LW RA, 20(SP)
9D0005B0  8FBE0010   LW FP, 16(SP)
9D0005B4  27BD0018   ADDIU SP, SP, 24
9D0005B8  03E00008   JR RA
9D0005BC  00000000   NOP
496:                 
497:                 OS_WORD *OS_NextTask(OS_WORD *CurrentTaskStackPointer)
498:                 {
9D0005C0  27BDFFE8   ADDIU SP, SP, -24
9D0005C4  AFBF0014   SW RA, 20(SP)
9D0005C8  AFBE0010   SW FP, 16(SP)
9D0005CC  03A0F021   ADDU FP, SP, ZERO
9D0005D0  AFC40018   SW A0, 24(FP)
499:                 	// clear the core interrupt flag regardless of if it is set or not
500:                 	PortClearCoreInterruptFlag();
9D0005D4  24040001   ADDIU A0, ZERO, 1
9D0005D8  0F40103F   JAL INTClearFlag
9D0005DC  00000000   NOP
9D0005E0  0F401086   JAL CoreClearSoftwareInterrupt0
9D0005E4  00000000   NOP
501:                 
502:                 	// Save the Stack Pointer of the Task whose Context we saved in ContextSwitch().
503:                 	gCurrentTask->TaskStackPointer = CurrentTaskStackPointer;
9D0005E8  8F82803C   LW V0, -32708(GP)
9D0005EC  8FC30018   LW V1, 24(FP)
9D0005F0  AC430020   SW V1, 32(V0)
504:                 
505:                 	gCurrentTask->CriticalCount = gCurrentCriticalCount;
9D0005F4  8F82803C   LW V0, -32708(GP)
9D0005F8  8F83802C   LW V1, -32724(GP)
9D0005FC  AC43002C   SW V1, 44(V0)
506:                 
507:                 	#if (USING_CONTEXT_SWITCH_USER_CALLBACK == 1)
508:                 		ContextSwitchUserCallback();
509:                 	#endif // end of USING_CONTEXT_SWITCH_USER_CALLBACK
510:                 
511:                 	if (PortGetOSTickTimerInterruptFlagSet())
9D000600  00002021   ADDU A0, ZERO, ZERO
9D000604  0F401053   JAL INTGetFlag
9D000608  00000000   NOP
9D00060C  10400008   BEQ V0, ZERO, 0x9D000630
9D000610  00000000   NOP
512:                 	{
513:                 		// we have to update OS tick
514:                 		gOSTickCount++;
9D000614  8F828010   LW V0, -32752(GP)
9D000618  24420001   ADDIU V0, V0, 1
9D00061C  AF828010   SW V0, -32752(GP)
515:                 
516:                 		// now call any timer related functions
517:                 		UpdateOSTick(gOSTickCount);
9D000620  8F828010   LW V0, -32752(GP)
9D000624  00402021   ADDU A0, V0, ZERO
9D000628  0F40015D   JAL UpdateOSTick
9D00062C  00000000   NOP
518:                 	}
519:                 
520:                 	// Iterate CurrentNode to the Next Node in the Ready Queue.
521:                 	gCurrentNode = (DOUBLE_LINKED_LIST_NODE*)gCurrentNode->NextNode;
9D000630  8F828018   LW V0, -32744(GP)
9D000634  8C420000   LW V0, 0(V0)
9D000638  AF828018   SW V0, -32744(GP)
522:                 
523:                 	// Update CurrentTask to point to the new Task that will be Executed.
524:                 	gCurrentTask = (TASK*)gCurrentNode->Data;
9D00063C  8F828018   LW V0, -32744(GP)
9D000640  8C420008   LW V0, 8(V0)
9D000644  AF82803C   SW V0, -32708(GP)
525:                 
526:                 	gCurrentCriticalCount = gCurrentTask->CriticalCount;
9D000648  8F82803C   LW V0, -32708(GP)
9D00064C  8C42002C   LW V0, 44(V0)
9D000650  AF82802C   SW V0, -32724(GP)
527:                 
528:                 	// Return the Stack Pointer of the Task whose Context will be restored by ContextSwitch().
529:                 	return gCurrentTask->TaskStackPointer;
9D000654  8F82803C   LW V0, -32708(GP)
9D000658  8C420020   LW V0, 32(V0)
530:                 }
9D00065C  03C0E821   ADDU SP, FP, ZERO
9D000660  8FBF0014   LW RA, 20(SP)
9D000664  8FBE0010   LW FP, 16(SP)
9D000668  27BD0018   ADDIU SP, SP, 24
9D00066C  03E00008   JR RA
9D000670  00000000   NOP
531:                 
532:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
533:                 // OS Timer Tick related functions end
534:                 //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
535:                 
536:                 #if (USING_OS_GENERAL_EXCEPTION_HANDLER == 1)
537:                 	#if (USING_RESTART_TASK != 1)
538:                 		#error "USING_RESTART_TASK in RTOSConfig.h must be defined as 1 if USING_OS_GENERAL_EXCEPTION_HANDLER is defined as 1!"
539:                 	#endif // end of USING_RESTART_TASK
540:                 
541:                 	#if (USING_DELETE_TASK != 1)
542:                 		#error "USING_DELETE_TASK in RTOSConfig.h must be defined as 1 if USING_OS_GENERAL_EXCEPTION_HANDLER is defined as 1!"
543:                 	#endif // end of USING_RESTART_TASK
544:                 
545:                 	BOOL OS_KernalTaskRunning(void)
546:                 	{
547:                 		if (gCurrentTask == &gIdleTask)
548:                 			return TRUE;
549:                 
550:                 		#if(USING_RESTART_TASK == 1 || USING_DELETE_TASK == 1)
551:                 			if(gCurrentTask == &gMaintenanceTask)
552:                 				return TRUE;
553:                 		#endif // end of USING_RESTART_TASK and USING_DELETE_TASK
554:                 
555:                 		#if (USING_UART_BUFFERS == 1)
556:                 			if (gCurrentTask == &gUARTBufferTask)
557:                 				return TRUE;
558:                 		#endif // end of USING_UART_BUFFERS
559:                 
560:                 		return FALSE;
561:                 	}
562:                 
563:                 	OS_WORD *GeneralExceptionHandler(OS_WORD *CurrentTaskStackPointer, OS_EXCEPTION_CODE ExceptionCode, UINT32 ExceptionAddress)
564:                 	{
565:                 		#if (USING_CPU_EXCEPTION_RAISED_USER_CALLBACK == 1)
566:                 			BOOL RestartCurrentTask;
567:                 		#endif // end of #if (USING_CPU_EXCEPTION_RAISED_USER_CALLBACK == 1)
568:                 
569:                 		#if (USING_CPU_EXCEPTION_RAISED_USER_CALLBACK == 1)
570:                 			RestartCurrentTask = GeneralExceptionHandlerUserCallback(ExceptionCode, ExceptionAddress);
571:                 		#endif // end of #if (USING_CPU_EXCEPTION_RAISED_USER_CALLBACK == 1)
572:                 
573:                 		// Check to see if we're in the OS or not, if so we can't gurantee anything about anything
574:                 		// when it comes to calling an OS method.
575:                 		// If a Task was running then we do have the power to restart it or delete it and then
576:                 		// "gracefully" recover from this error.
577:                 		if(gCurrentCriticalCount == 0 && OS_KernalTaskRunning() == FALSE)
578:                 		{
579:                 			// We can only raise this exception if we can continue along gracefully...
580:                 			#if (USING_CPU_EXCEPTION_RAISED_EVENT == 1)
581:                 				OS_RaiseEvent(CPU_EXCEPTION_RAISED_EVENT);
582:                 			#endif // end of #if (USING_CPU_EXCEPTION_RAISED_EVENT == 1)
583:                 
584:                 			// Let the user decide if we must delete or restart the current task.
585:                 			// To the OS it doesn't care which choice is made, either one is valid.
586:                 			#if (USING_CPU_EXCEPTION_RAISED_USER_CALLBACK == 1)
587:                 				if (RestartCurrentTask == TRUE && gCurrentTask->RestartInfo != (TASK_RESTART_INFO*)NULL)
588:                 					OS_RestartTask(gCurrentTask);
589:                 				else
590:                 					OS_DeleteTask(gCurrentTask);
591:                 			#else
592:                 				OS_DeleteTask(gCurrentTask);
593:                 			#endif // end of #if (USING_CPU_EXCEPTION_RAISED_USER_CALLBACK == 1)
594:                 	
595:                 			// we need to swap the TASK because the current one
596:                 			// generated the exception event and cannot run
597:                 			return OS_NextTask(CurrentTaskStackPointer);
598:                 		}
599:                 
600:                 		// put up a BSOD, we cannot recover from this
601:                 	
602:                 		return (OS_WORD*)NULL;
603:                 	}
604:                 #endif // end of USING_OS_GENERAL_EXCEPTION_HANDLER
605:                 
606:                 OS_WORD *OS_InitializeTaskStack(TASK *Task, TASK_ENTRY_POINT StartingAddress, void *Args, UINT32 StackSizeInWords)
607:                 {
9D000674  27BDFFE0   ADDIU SP, SP, -32
9D000678  AFBF001C   SW RA, 28(SP)
9D00067C  AFBE0018   SW FP, 24(SP)
9D000680  03A0F021   ADDU FP, SP, ZERO
9D000684  AFC40020   SW A0, 32(FP)
9D000688  AFC50024   SW A1, 36(FP)
9D00068C  AFC60028   SW A2, 40(FP)
9D000690  AFC7002C   SW A3, 44(FP)
608:                 	OS_WORD *Stack = (OS_WORD*)AllocateMemory(StackSizeInWords * OS_WORD_SIZE_IN_BYTES);
9D000694  8FC2002C   LW V0, 44(FP)
9D000698  00021080   SLL V0, V0, 2
9D00069C  00402021   ADDU A0, V0, ZERO
9D0006A0  0F400478   JAL AllocateMemory
9D0006A4  00000000   NOP
9D0006A8  AFC20010   SW V0, 16(FP)
609:                 
610:                 	if(Stack == (OS_WORD*)NULL)
9D0006AC  8FC20010   LW V0, 16(FP)
9D0006B0  14400004   BNE V0, ZERO, 0x9D0006C4
9D0006B4  00000000   NOP
611:                 		return (OS_WORD*)NULL;
9D0006B8  00001021   ADDU V0, ZERO, ZERO
9D0006BC  0B4001B7   J 0x9D0006DC
9D0006C0  00000000   NOP
612:                 
613:                 	#if (USING_RESTART_TASK == 1 || USING_DELETE_TASK == 1)
614:                 		Task->StartOfTaskStackPointer = Stack;
615:                 	#endif // end of USING_RESTART_TASK == 1 || USING_DELETE_TASK == 1
616:                 
617:                 	return PortInitializeTaskStack(Stack, StackSizeInWords, StartingAddress, Args);
9D0006C4  8FC40010   LW A0, 16(FP)
9D0006C8  8FC5002C   LW A1, 44(FP)
9D0006CC  8FC60024   LW A2, 36(FP)
9D0006D0  8FC70028   LW A3, 40(FP)
9D0006D4  0F400BBB   JAL PortInitializeTaskStack
9D0006D8  00000000   NOP
618:                 }
9D0006DC  03C0E821   ADDU SP, FP, ZERO
9D0006E0  8FBF001C   LW RA, 28(SP)
9D0006E4  8FBE0018   LW FP, 24(SP)
9D0006E8  27BD0020   ADDIU SP, SP, 32
9D0006EC  03E00008   JR RA
9D0006F0  00000000   NOP
619:                 
620:                 #if (USING_BINARY_SEMAPHORE_STARVATION_PROTECTION == 1)
621:                 	void OS_IncrementTaskListPriorities(DOUBLE_LINKED_LIST_HEAD *ListHead)
622:                 	{
9D0006F4  27BDFFF0   ADDIU SP, SP, -16
9D0006F8  AFBE000C   SW FP, 12(SP)
9D0006FC  03A0F021   ADDU FP, SP, ZERO
9D000700  AFC40010   SW A0, 16(FP)
623:                 		TASK *TaskHandle1;
624:                 		DOUBLE_LINKED_LIST_NODE *PriorityIterator = ListHead->Beginning;
9D000704  8FC20010   LW V0, 16(FP)
9D000708  8C420000   LW V0, 0(V0)
9D00070C  AFC20000   SW V0, 0(FP)
625:                 
626:                 		while (PriorityIterator != (DOUBLE_LINKED_LIST_NODE*)NULL)
9D000710  0B4001D7   J 0x9D00075C
9D000714  00000000   NOP
9D00075C  8FC20000   LW V0, 0(FP)
9D000760  1440FFED   BNE V0, ZERO, 0x9D000718
9D000764  00000000   NOP
627:                 		{
628:                 			TaskHandle1 = (TASK*)(PriorityIterator->Data);
9D000718  8FC20000   LW V0, 0(FP)
9D00071C  8C420008   LW V0, 8(V0)
9D000720  AFC20004   SW V0, 4(FP)
629:                 
630:                 			if (TaskHandle1->TaskPriority != OS_HIGHEST_TASK_PRIORITY)
9D000724  8FC20004   LW V0, 4(FP)
9D000728  90430028   LBU V1, 40(V0)
9D00072C  24020008   ADDIU V0, ZERO, 8
9D000730  10620007   BEQ V1, V0, 0x9D000750
9D000734  00000000   NOP
631:                 				TaskHandle1->TaskPriority++;
9D000738  8FC20004   LW V0, 4(FP)
9D00073C  90420028   LBU V0, 40(V0)
9D000740  24420001   ADDIU V0, V0, 1
9D000744  304300FF   ANDI V1, V0, 255
9D000748  8FC20004   LW V0, 4(FP)
9D00074C  A0430028   SB V1, 40(V0)
632:                 
633:                 			PriorityIterator = (DOUBLE_LINKED_LIST_NODE*)(PriorityIterator->NextNode);
9D000750  8FC20000   LW V0, 0(FP)
9D000754  8C420000   LW V0, 0(V0)
9D000758  AFC20000   SW V0, 0(FP)
634:                 		}
635:                 	}
9D000768  03C0E821   ADDU SP, FP, ZERO
9D00076C  8FBE000C   LW FP, 12(SP)
9D000770  27BD0010   ADDIU SP, SP, 16
9D000774  03E00008   JR RA
9D000778  00000000   NOP
636:                 #endif // end of #if (USING_SEMAPHORE_STARVATION_PROTECTION == 1)
637:                 
638:                 #if (USING_BINARY_SEMAPHORES == 1)
639:                 	/*
640:                 		This method primarily designed for use by ReleaseBinarySemaphore is used to get the next Task
641:                 		in a Double Linked List that has the highest Priority.  It can however be used on any
642:                 		Double Linked List, not just BinarySemaphores Blocked List.  One minor quirk of this is that
643:                 		the calling method must determine if the Double Linked List is empty before calling
644:                 		this method.
645:                 	*/
646:                 	DOUBLE_LINKED_LIST_NODE *OS_PriorityRemoveDoubleLinkedList(DOUBLE_LINKED_LIST_HEAD *Head)
647:                 	{
648:                 		TASK *TaskIterator1, *TaskIterator2;
649:                 		DOUBLE_LINKED_LIST_NODE *Iterator1, *Iterator2;
650:                 		UINT32 i;
651:                 
652:                 		// If there's only one item in the list just remove it
653:                 		if (Head->Beginning == Head->End)
654:                 		{
655:                 			DOUBLE_LINKED_LIST_NODE *TempNode = Head->Beginning;
656:                 			TASK *TaskHandle = TempNode->Data;
657:                 
658:                 			// remove all the nodes from any lists they were on
659:                 			for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
660:                 				OS_RemoveTaskFromList(&TaskHandle->TaskNodeArray[i]);
661:                 
662:                 			return &TaskHandle->TaskNodeArray[PRIMARY_TASK_NODE].ListNode;
663:                 		}
664:                 
665:                 		// There is more than one Task in the Double Linked List if we're here.
666:                 
667:                 		/*
668:                 			Iterator1 and Task1 will be set the to Task with the highest Priority.  Iterator2 and Task2 will
669:                 			iterate through the List and comapre their values to Task1, and if Task2 has a higher priority,
670:                 			Task1 will be set to Task2.  This process will repeat until Task2 and Iterator2 equal NULL.
671:                 		*/
672:                 
673:                 		// Iterator1 will be set to the first Item in the list, and Iterator2 will be set the 2nd Item in the List.
674:                 		Iterator1 = Head->Beginning;
675:                 		Iterator2 = (DOUBLE_LINKED_LIST_NODE*)Head->Beginning->NextNode;
676:                 
677:                 		// Tasks assigned to their respective spots.
678:                 		TaskIterator1 = (TASK*)Iterator1->Data;
679:                 		TaskIterator2 = (TASK*)Iterator2->Data;
680:                 
681:                 		/*
682:                 		This loop will iterate through the entire List and determine the Task in the List with the highest Priority.
683:                 		*/
684:                 		do
685:                 		{
686:                 			// If Task2 has a higher Priority than Task1, Task1 equals Task2, and Iterator1 equals Iterator2.
687:                 			if (TaskIterator2->TaskPriority > TaskIterator1->TaskPriority)
688:                 			{
689:                 				Iterator1 = Iterator2;
690:                 				TaskIterator1 = TaskIterator2;
691:                 			}
692:                 
693:                 			Iterator2 = (DOUBLE_LINKED_LIST_NODE*)Iterator2->NextNode;
694:                 
695:                 			// Increment Iterator2 to the next Item in the List.
696:                 			if (Iterator2 != (DOUBLE_LINKED_LIST_NODE*)NULL)
697:                 			{
698:                 				TaskIterator2 = (TASK*)Iterator2->Data;
699:                 			}
700:                 		} 
701:                 		while (Iterator2 != (DOUBLE_LINKED_LIST_NODE*)NULL);
702:                 
703:                 		// remove all the nodes from any lists they were on
704:                 		for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
705:                 			OS_RemoveTaskFromList(&TaskIterator1->TaskNodeArray[i]);
706:                 
707:                 		// Remove and return the Task with the highest Priority from the List specified by the DOUBLE_LINKED_LIST_HEAD *Head parameter.
708:                 		return &TaskIterator1->TaskNodeArray[PRIMARY_TASK_NODE].ListNode;
709:                 	}
710:                 #endif // end of #if (USING_BINARY_SEMAPHORES == 1)
711:                 
712:                 #if (USING_CHANGE_TASK_PRIORITY_METHOD == 1 || USING_MUTEXES == 1 || USING_BINARY_SEMAPHORES == 1)
713:                 	BOOL OS_ChangeTaskPriority(TASK *Task, BYTE Priority)
714:                 	{
715:                 		BOOL CallNextTask = FALSE;
716:                 
717:                 		// if the TASK isn't ready, just change the priority
718:                 		if (Task->TaskState != READY)
719:                 		{
720:                 			// just change the priority to the current task
721:                 			Task->TaskPriority = Priority;
722:                 		}
723:                 		else
724:                 		{
725:                 			// the TASK is in the ready queue, we must remove it
726:                 			// prior to changing the priority.
727:                 
728:                 			if (OS_RemoveTaskFromReadyQueue(Task) == TRUE)
729:                 				CallNextTask = TRUE;
730:                 
731:                 			Task->TaskPriority = Priority;
732:                 
733:                 			if (OS_AddTaskToReadyQueue(Task) == TRUE)
734:                 				CallNextTask = TRUE;
735:                 		}
736:                 
737:                 		return CallNextTask;
738:                 	}
739:                 #endif // end of #if (USING_CHANGE_TASK_PRIORITY_METHOD == 1 || USING_MUTEXES == 1 || USING_BINARY_SEMAPHORES == 1)
740:                 
741:                 #if (USING_DELETE_TASK == 1 || USING_RESTART_TASK == 1)
742:                 	BOOL OS_PrepTaskForRemoval(TASK *Task)
743:                 	{
744:                 		if (Task->TaskState != RESTARTING && Task->TaskState != DELETING)
745:                 		{
746:                 			#if (USING_TASK_CHECK_IN == 1)
747:                 				if (Task->TaskCheckIn != (TASK_CHECK_IN*)NULL)
748:                 					OS_RemoveTaskFromList(&(Task->TaskCheckIn->TaskCheckInNode));
749:                 			#endif // end of USING_TASK_CHECK_IN
750:                 
751:                 			// Get it out of the ready queue so we can add it to the restart list
752:                 			if (Task->TaskState == READY)
753:                 			{
754:                 				OS_RemoveTaskFromReadyQueue(Task);
755:                 			}
756:                 			else
757:                 			{
758:                 				UINT32 i;
759:                 
760:                 				// remove all the nodes from any lists they were on
761:                 				for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
762:                 					OS_RemoveTaskFromList(&Task->TaskNodeArray[i]);
763:                 			}
764:                 
765:                 			return TRUE;
766:                 		}
767:                 
768:                 		return FALSE;
769:                 	}
770:                 #endif // end of USING_DELETE_TASK and USING_RESTART_TASK
771:                 
772:                 #if (USING_DELETE_TASK == 1)
773:                 	BOOL OS_DeleteTask(TASK *Task)
774:                 	{
775:                 		if (OS_PrepTaskForRemoval(Task) == TRUE)
776:                 		{
777:                 			OS_PlaceTaskOnBlockedList(Task, &gDeleteTaskList, &Task->TaskNodeArray[PRIMARY_TASK_NODE], DELETING, FALSE);
778:                 
779:                 			return TRUE;
780:                 		}
781:                 
782:                 		return FALSE;
783:                 	}
784:                 #endif // end of #if (USING_DELETE_TASK == 1)
785:                 
786:                 #if (USING_RESTART_TASK == 1)
787:                 	BOOL OS_RestartTask(TASK *Task)
788:                 	{
789:                 		if (OS_PrepTaskForRemoval(Task) == TRUE)
790:                 		{
791:                 			OS_PlaceTaskOnBlockedList(Task, &gRestartTaskList, &Task->TaskNodeArray[PRIMARY_TASK_NODE], RESTARTING, FALSE);
792:                 
793:                 			return TRUE;
794:                 		}
795:                 
796:                 		return FALSE;
797:                 	}
798:                 #endif // end of USING_RESTART_TASK
799:                 
800:                 #if (USING_TASK_DELAY_TICKS_METHOD == 1)
801:                 	void OS_AddTaskToDelayQueue(TASK *Task, TASK_NODE *Node, UINT32 TicksToDelay, BOOL RemoveTaskFromReadyQueue)
802:                 	{
9D00077C  27BDFFE0   ADDIU SP, SP, -32
9D000780  AFBF001C   SW RA, 28(SP)
9D000784  AFBE0018   SW FP, 24(SP)
9D000788  03A0F021   ADDU FP, SP, ZERO
9D00078C  AFC40020   SW A0, 32(FP)
9D000790  AFC50024   SW A1, 36(FP)
9D000794  AFC60028   SW A2, 40(FP)
9D000798  AFC7002C   SW A3, 44(FP)
803:                 		Task->DelayInTicks = TicksToDelay;
9D00079C  8FC20020   LW V0, 32(FP)
9D0007A0  8FC30028   LW V1, 40(FP)
9D0007A4  AC430030   SW V1, 48(V0)
804:                 
805:                 		OS_PlaceTaskOnBlockedList(Task, &gDelayQueue, Node, BLOCKED, RemoveTaskFromReadyQueue);
9D0007A8  8FC2002C   LW V0, 44(FP)
9D0007AC  AFA20010   SW V0, 16(SP)
9D0007B0  8FC40020   LW A0, 32(FP)
9D0007B4  27858020   ADDIU A1, GP, -32736
9D0007B8  8FC60024   LW A2, 36(FP)
9D0007BC  24070001   ADDIU A3, ZERO, 1
9D0007C0  0F40028E   JAL OS_PlaceTaskOnBlockedList
9D0007C4  00000000   NOP
806:                 	}
9D0007C8  03C0E821   ADDU SP, FP, ZERO
9D0007CC  8FBF001C   LW RA, 28(SP)
9D0007D0  8FBE0018   LW FP, 24(SP)
9D0007D4  27BD0020   ADDIU SP, SP, 32
9D0007D8  03E00008   JR RA
9D0007DC  00000000   NOP
807:                 #endif // end of #if (USING_TASK_DELAY_TICKS_METHOD == 1)
808:                 
809:                 /*
810:                 	This method is only created to serve the purpose of place ONE Task into the Ready Queue.  This method CANNOT be called
811:                 	multiple times in a row to add multile Tasks.
812:                 */
813:                 BOOL OS_AddTaskToReadyQueue(TASK *TaskToAddToReadyQueue)
814:                 {	
9D0007E0  27BDFFE8   ADDIU SP, SP, -24
9D0007E4  AFBF0014   SW RA, 20(SP)
9D0007E8  AFBE0010   SW FP, 16(SP)
9D0007EC  03A0F021   ADDU FP, SP, ZERO
9D0007F0  AFC40018   SW A0, 24(FP)
815:                 	OS_AddTaskToCPUScheduler(TaskToAddToReadyQueue);
9D0007F4  8FC40018   LW A0, 24(FP)
9D0007F8  0F400060   JAL OS_AddTaskToCPUScheduler
9D0007FC  00000000   NOP
816:                 
817:                 	if(TaskToAddToReadyQueue->TaskPriority > gCurrentSystemPriority)
9D000800  8FC20018   LW V0, 24(FP)
9D000804  90430028   LBU V1, 40(V0)
9D000808  9382801C   LBU V0, -32740(GP)
9D00080C  0043102B   SLTU V0, V0, V1
9D000810  1040000A   BEQ V0, ZERO, 0x9D00083C
9D000814  00000000   NOP
818:                 	{
819:                 		gCurrentSystemPriority = TaskToAddToReadyQueue->TaskPriority;
9D000818  8FC20018   LW V0, 24(FP)
9D00081C  90420028   LBU V0, 40(V0)
9D000820  A382801C   SB V0, -32740(GP)
820:                 
821:                 		gCurrentNode = TaskToAddToReadyQueue->TaskNodeArray[PRIMARY_TASK_NODE].ListNode.PreviousNode;
9D000824  8FC20018   LW V0, 24(FP)
9D000828  8C420004   LW V0, 4(V0)
9D00082C  AF828018   SW V0, -32744(GP)
822:                 
823:                 		return gCPUSchedulerRunning;
9D000830  8F828014   LW V0, -32748(GP)
9D000834  0B400210   J 0x9D000840
9D000838  00000000   NOP
824:                 	}
825:                 
826:                 	return FALSE;
9D00083C  00001021   ADDU V0, ZERO, ZERO
827:                 }
9D000840  03C0E821   ADDU SP, FP, ZERO
9D000844  8FBF0014   LW RA, 20(SP)
9D000848  8FBE0010   LW FP, 16(SP)
9D00084C  27BD0018   ADDIU SP, SP, 24
9D000850  03E00008   JR RA
9D000854  00000000   NOP
828:                 
829:                 /*
830:                 	This method performs all the necessary actions needed to fully remove a Task from the Ready Queue.  This is the only method needed to
831:                 	remove a Task from the Ready Queue.  It first decrements the Number of Ready Tasks, then removes the specified Task from the Pending Queue
832:                 	if it is on there.  Then it Removes and returns the Task specified from the Ready Queue.
833:                 */
834:                 BOOL OS_RemoveTaskFromReadyQueue(TASK *TaskToRemoveFromReadyQueue)
835:                 {
9D000858  27BDFFE8   ADDIU SP, SP, -24
9D00085C  AFBF0014   SW RA, 20(SP)
9D000860  AFBE0010   SW FP, 16(SP)
9D000864  03A0F021   ADDU FP, SP, ZERO
9D000868  AFC40018   SW A0, 24(FP)
836:                 	// If we are removing the current Node...
837:                 	if (gCurrentNode == &(TaskToRemoveFromReadyQueue->TaskNodeArray[PRIMARY_TASK_NODE].ListNode))
9D00086C  8FC20018   LW V0, 24(FP)
9D000870  00401821   ADDU V1, V0, ZERO
9D000874  8F828018   LW V0, -32744(GP)
9D000878  14620004   BNE V1, V0, 0x9D00088C
9D00087C  00000000   NOP
838:                 	{
839:                 		gCurrentNode = gCurrentNode->PreviousNode;
9D000880  8F828018   LW V0, -32744(GP)
9D000884  8C420004   LW V0, 4(V0)
9D000888  AF828018   SW V0, -32744(GP)
840:                 	}
841:                 		
842:                 	OS_RemoveTaskFromCPUScheduler(TaskToRemoveFromReadyQueue);
9D00088C  8FC40018   LW A0, 24(FP)
9D000890  0F4000C0   JAL OS_RemoveTaskFromCPUScheduler
9D000894  00000000   NOP
843:                 
844:                 	// if we have removed all tasks from the current priority, we must find a new one
845:                 	if(gCPU_Scheduler[TaskToRemoveFromReadyQueue->TaskPriority].End == (DOUBLE_LINKED_LIST_NODE*)NULL && gCurrentSystemPriority == TaskToRemoveFromReadyQueue->TaskPriority)
9D000898  8FC20018   LW V0, 24(FP)
9D00089C  90420028   LBU V0, 40(V0)
9D0008A0  3C03A000   LUI V1, -24576
9D0008A4  24630238   ADDIU V1, V1, 568
9D0008A8  000210C0   SLL V0, V0, 3
9D0008AC  00621021   ADDU V0, V1, V0
9D0008B0  8C420004   LW V0, 4(V0)
9D0008B4  1440001D   BNE V0, ZERO, 0x9D00092C
9D0008B8  00000000   NOP
9D0008BC  8FC20018   LW V0, 24(FP)
9D0008C0  90430028   LBU V1, 40(V0)
9D0008C4  9382801C   LBU V0, -32740(GP)
9D0008C8  14620018   BNE V1, V0, 0x9D00092C
9D0008CC  00000000   NOP
846:                 	{
847:                 		// this means we have to find a new priority level to execute
848:                 		do
849:                 		{
850:                 			gCurrentSystemPriority--;
9D0008D0  9382801C   LBU V0, -32740(GP)
9D0008D4  2442FFFF   ADDIU V0, V0, -1
9D0008D8  304200FF   ANDI V0, V0, 255
9D0008DC  A382801C   SB V0, -32740(GP)
851:                 		}
852:                 		while(gCPU_Scheduler[gCurrentSystemPriority].Beginning == (DOUBLE_LINKED_LIST_NODE*)NULL);
9D0008E0  9382801C   LBU V0, -32740(GP)
9D0008E4  00401821   ADDU V1, V0, ZERO
9D0008E8  3C02A000   LUI V0, -24576
9D0008EC  000318C0   SLL V1, V1, 3
9D0008F0  24420238   ADDIU V0, V0, 568
9D0008F4  00621021   ADDU V0, V1, V0
9D0008F8  8C420000   LW V0, 0(V0)
9D0008FC  1040FFF4   BEQ V0, ZERO, 0x9D0008D0
9D000900  00000000   NOP
853:                 
854:                 		// get the current node to point to the last node
855:                 		gCurrentNode = gCPU_Scheduler[gCurrentSystemPriority].End;
9D000904  9382801C   LBU V0, -32740(GP)
9D000908  3C03A000   LUI V1, -24576
9D00090C  24630238   ADDIU V1, V1, 568
9D000910  000210C0   SLL V0, V0, 3
9D000914  00621021   ADDU V0, V1, V0
9D000918  8C420004   LW V0, 4(V0)
9D00091C  AF828018   SW V0, -32744(GP)
856:                 
857:                 		return TRUE;
9D000920  24020001   ADDIU V0, ZERO, 1
9D000924  0B40024C   J 0x9D000930
9D000928  00000000   NOP
858:                 	}
859:                 
860:                 	// no context switch needed
861:                 	return FALSE;
9D00092C  00001021   ADDU V0, ZERO, ZERO
862:                 }
9D000930  03C0E821   ADDU SP, FP, ZERO
9D000934  8FBF0014   LW RA, 20(SP)
9D000938  8FBE0010   LW FP, 16(SP)
9D00093C  27BD0018   ADDIU SP, SP, 24
9D000940  03E00008   JR RA
9D000944  00000000   NOP
863:                 
864:                 BOOL OS_AddTaskListToReadyQueue(DOUBLE_LINKED_LIST_HEAD *ListHead)
865:                 {
9D000948  27BDFFD8   ADDIU SP, SP, -40
9D00094C  AFBF0024   SW RA, 36(SP)
9D000950  AFBE0020   SW FP, 32(SP)
9D000954  03A0F021   ADDU FP, SP, ZERO
9D000958  AFC40028   SW A0, 40(FP)
866:                 	DOUBLE_LINKED_LIST_NODE *Iterator;
867:                 	TASK *TaskHandle;
868:                 	UINT32 i;
869:                 	BOOL CallNextTask = FALSE;
9D00095C  AFC00018   SW ZERO, 24(FP)
870:                 
871:                 	if (ListHead->Beginning == NULL)
9D000960  8FC20028   LW V0, 40(FP)
9D000964  8C420000   LW V0, 0(V0)
9D000968  14400004   BNE V0, ZERO, 0x9D00097C
9D00096C  00000000   NOP
872:                 		return FALSE;
9D000970  00001021   ADDU V0, ZERO, ZERO
9D000974  0B400288   J 0x9D000A20
9D000978  00000000   NOP
873:                 
874:                 	Iterator = ListHead->Beginning;
9D00097C  8FC20028   LW V0, 40(FP)
9D000980  8C420000   LW V0, 0(V0)
9D000984  AFC20010   SW V0, 16(FP)
875:                 
876:                 	while (Iterator != (DOUBLE_LINKED_LIST_NODE*)NULL)
9D000988  0B400284   J 0x9D000A10
9D00098C  00000000   NOP
9D000A10  8FC20010   LW V0, 16(FP)
9D000A14  1440FFDE   BNE V0, ZERO, 0x9D000990
9D000A18  00000000   NOP
877:                 	{
878:                 		TaskHandle = (TASK*)Iterator->Data;
9D000990  8FC20010   LW V0, 16(FP)
9D000994  8C420008   LW V0, 8(V0)
9D000998  AFC2001C   SW V0, 28(FP)
879:                 
880:                 		// remove all the nodes from any lists they were on
881:                 		for (i = 0; i < NUMBER_OF_INTERNAL_TASK_NODES; i++)
9D00099C  AFC00014   SW ZERO, 20(FP)
9D0009A0  0B400274   J 0x9D0009D0
9D0009A4  00000000   NOP
9D0009C4  8FC20014   LW V0, 20(FP)
9D0009C8  24420001   ADDIU V0, V0, 1
9D0009CC  AFC20014   SW V0, 20(FP)
9D0009D0  8FC20014   LW V0, 20(FP)
9D0009D4  2C420002   SLTIU V0, V0, 2
9D0009D8  1440FFF3   BNE V0, ZERO, 0x9D0009A8
9D0009DC  00000000   NOP
882:                 			OS_RemoveTaskFromList(&TaskHandle->TaskNodeArray[i]);
9D0009A8  8FC3001C   LW V1, 28(FP)
9D0009AC  8FC20014   LW V0, 20(FP)
9D0009B0  00021100   SLL V0, V0, 4
9D0009B4  00621021   ADDU V0, V1, V0
9D0009B8  00402021   ADDU A0, V0, ZERO
9D0009BC  0F4002D6   JAL OS_RemoveTaskFromList
9D0009C0  00000000   NOP
883:                 
884:                 		if (OS_AddTaskToReadyQueue(TaskHandle) == TRUE)
9D0009E0  8FC4001C   LW A0, 28(FP)
9D0009E4  0F4001F8   JAL OS_AddTaskToReadyQueue
9D0009E8  00000000   NOP
9D0009EC  00401821   ADDU V1, V0, ZERO
9D0009F0  24020001   ADDIU V0, ZERO, 1
9D0009F4  14620003   BNE V1, V0, 0x9D000A04
9D0009F8  00000000   NOP
885:                 			CallNextTask = TRUE;
9D0009FC  24020001   ADDIU V0, ZERO, 1
9D000A00  AFC20018   SW V0, 24(FP)
886:                 
887:                 		Iterator = ListHead->Beginning;
9D000A04  8FC20028   LW V0, 40(FP)
9D000A08  8C420000   LW V0, 0(V0)
9D000A0C  AFC20010   SW V0, 16(FP)
888:                 	}
889:                 
890:                 	return CallNextTask;
9D000A1C  8FC20018   LW V0, 24(FP)
891:                 }
9D000A20  03C0E821   ADDU SP, FP, ZERO
9D000A24  8FBF0024   LW RA, 36(SP)
9D000A28  8FBE0020   LW FP, 32(SP)
9D000A2C  27BD0028   ADDIU SP, SP, 40
9D000A30  03E00008   JR RA
9D000A34  00000000   NOP
892:                 
893:                 BOOL OS_PlaceTaskOnBlockedList(TASK *Task, DOUBLE_LINKED_LIST_HEAD *BlockedListHead, TASK_NODE *TaskNode, TASK_STATE NewTaskState, BOOL RemoveTaskFromReadyQueue)
894:                 {
9D000A38  27BDFFE0   ADDIU SP, SP, -32
9D000A3C  AFBF001C   SW RA, 28(SP)
9D000A40  AFBE0018   SW FP, 24(SP)
9D000A44  03A0F021   ADDU FP, SP, ZERO
9D000A48  AFC40020   SW A0, 32(FP)
9D000A4C  AFC50024   SW A1, 36(FP)
9D000A50  AFC60028   SW A2, 40(FP)
9D000A54  AFC7002C   SW A3, 44(FP)
895:                 	BOOL CallNextTask = FALSE;
9D000A58  AFC00010   SW ZERO, 16(FP)
896:                 
897:                 	// set the current task state to BLOCKED
898:                 	Task->TaskState = NewTaskState;
9D000A5C  8FC20020   LW V0, 32(FP)
9D000A60  8FC3002C   LW V1, 44(FP)
9D000A64  AC430024   SW V1, 36(V0)
899:                 	
900:                 	// remove the current task from the ready queue
901:                 	if (RemoveTaskFromReadyQueue == TRUE)
9D000A68  8FC30030   LW V1, 48(FP)
9D000A6C  24020001   ADDIU V0, ZERO, 1
9D000A70  14620005   BNE V1, V0, 0x9D000A88
9D000A74  00000000   NOP
902:                 		CallNextTask = OS_RemoveTaskFromReadyQueue(Task);
9D000A78  8FC40020   LW A0, 32(FP)
9D000A7C  0F400216   JAL OS_RemoveTaskFromReadyQueue
9D000A80  00000000   NOP
9D000A84  AFC20010   SW V0, 16(FP)
903:                 
904:                 	// Make the Task point to the head of the list it is in, wherever it might be.
905:                 	OS_AddTaskToList(BlockedListHead, TaskNode);
9D000A88  8FC40024   LW A0, 36(FP)
9D000A8C  8FC50028   LW A1, 40(FP)
9D000A90  0F4002C2   JAL OS_AddTaskToList
9D000A94  00000000   NOP
906:                 
907:                 	return CallNextTask;
9D000A98  8FC20010   LW V0, 16(FP)
908:                 }
9D000A9C  03C0E821   ADDU SP, FP, ZERO
9D000AA0  8FBF001C   LW RA, 28(SP)
9D000AA4  8FBE0018   LW FP, 24(SP)
9D000AA8  27BD0020   ADDIU SP, SP, 32
9D000AAC  03E00008   JR RA
9D000AB0  00000000   NOP
909:                 
910:                 void OS_InitializeTaskNode(TASK_NODE *TaskNode, void *Data)
911:                 {
9D000AB4  27BDFFE8   ADDIU SP, SP, -24
9D000AB8  AFBF0014   SW RA, 20(SP)
9D000ABC  AFBE0010   SW FP, 16(SP)
9D000AC0  03A0F021   ADDU FP, SP, ZERO
9D000AC4  AFC40018   SW A0, 24(FP)
9D000AC8  AFC5001C   SW A1, 28(FP)
912:                 	
913:                 	InitializeDoubleLinkedListNode(&TaskNode->ListNode);
9D000ACC  8FC20018   LW V0, 24(FP)
9D000AD0  00402021   ADDU A0, V0, ZERO
9D000AD4  0F400C49   JAL InitializeDoubleLinkedListNode
9D000AD8  00000000   NOP
914:                 
915:                 	TaskNode->ListNode.Data = Data;
9D000ADC  8FC20018   LW V0, 24(FP)
9D000AE0  8FC3001C   LW V1, 28(FP)
9D000AE4  AC430008   SW V1, 8(V0)
916:                 
917:                 	TaskNode->ListHead = (DOUBLE_LINKED_LIST_HEAD*)NULL;
9D000AE8  8FC20018   LW V0, 24(FP)
9D000AEC  AC40000C   SW ZERO, 12(V0)
918:                 }
9D000AF0  03C0E821   ADDU SP, FP, ZERO
9D000AF4  8FBF0014   LW RA, 20(SP)
9D000AF8  8FBE0010   LW FP, 16(SP)
9D000AFC  27BD0018   ADDIU SP, SP, 24
9D000B00  03E00008   JR RA
9D000B04  00000000   NOP
919:                 
920:                 void OS_AddTaskToList(DOUBLE_LINKED_LIST_HEAD *Head, TASK_NODE *TaskNode)
921:                 {
9D000B08  27BDFFE8   ADDIU SP, SP, -24
9D000B0C  AFBF0014   SW RA, 20(SP)
9D000B10  AFBE0010   SW FP, 16(SP)
9D000B14  03A0F021   ADDU FP, SP, ZERO
9D000B18  AFC40018   SW A0, 24(FP)
9D000B1C  AFC5001C   SW A1, 28(FP)
922:                 	TaskNode->ListHead = Head;
9D000B20  8FC2001C   LW V0, 28(FP)
9D000B24  8FC30018   LW V1, 24(FP)
9D000B28  AC43000C   SW V1, 12(V0)
923:                 	
924:                 	InsertNodeAtEndOfDoubleLinkedList(Head, &TaskNode->ListNode);
9D000B2C  8FC2001C   LW V0, 28(FP)
9D000B30  8FC40018   LW A0, 24(FP)
9D000B34  00402821   ADDU A1, V0, ZERO
9D000B38  0F400C5A   JAL InsertNodeAtEndOfDoubleLinkedList
9D000B3C  00000000   NOP
925:                 }
9D000B40  03C0E821   ADDU SP, FP, ZERO
9D000B44  8FBF0014   LW RA, 20(SP)
9D000B48  8FBE0010   LW FP, 16(SP)
9D000B4C  27BD0018   ADDIU SP, SP, 24
9D000B50  03E00008   JR RA
9D000B54  00000000   NOP
926:                 
927:                 TASK *OS_RemoveTaskFromList(TASK_NODE *TaskNode)
928:                 {
9D000B58  27BDFFE8   ADDIU SP, SP, -24
9D000B5C  AFBF0014   SW RA, 20(SP)
9D000B60  AFBE0010   SW FP, 16(SP)
9D000B64  03A0F021   ADDU FP, SP, ZERO
9D000B68  AFC40018   SW A0, 24(FP)
929:                 	// If it's empty, just return
930:                 	if (TaskNode->ListHead == (DOUBLE_LINKED_LIST_HEAD*)NULL)
9D000B6C  8FC20018   LW V0, 24(FP)
9D000B70  8C42000C   LW V0, 12(V0)
9D000B74  14400005   BNE V0, ZERO, 0x9D000B8C
9D000B78  00000000   NOP
931:                 		return (TASK*)TaskNode->ListNode.Data;
9D000B7C  8FC20018   LW V0, 24(FP)
9D000B80  8C420008   LW V0, 8(V0)
9D000B84  0B4002EE   J 0x9D000BB8
9D000B88  00000000   NOP
932:                 
933:                 	RemoveNodeFromDoubleLinkedList(TaskNode->ListHead, &TaskNode->ListNode);
9D000B8C  8FC20018   LW V0, 24(FP)
9D000B90  8C43000C   LW V1, 12(V0)
9D000B94  8FC20018   LW V0, 24(FP)
9D000B98  00602021   ADDU A0, V1, ZERO
9D000B9C  00402821   ADDU A1, V0, ZERO
9D000BA0  0F400C84   JAL RemoveNodeFromDoubleLinkedList
9D000BA4  00000000   NOP
934:                 
935:                 	TaskNode->ListHead = (DOUBLE_LINKED_LIST_HEAD*)NULL;
9D000BA8  8FC20018   LW V0, 24(FP)
9D000BAC  AC40000C   SW ZERO, 12(V0)
936:                 
937:                 	return (TASK*)TaskNode->ListNode.Data;
9D000BB0  8FC20018   LW V0, 24(FP)
9D000BB4  8C420008   LW V0, 8(V0)
938:                 }
9D000BB8  03C0E821   ADDU SP, FP, ZERO
939:                 
940:                 //--------------------------------------------------------------------------------------------------//
941:                 //																									//
942:                 //									End user non-callable section									//
943:                 //																									//
944:                 //--------------------------------------------------------------------------------------------------//
---  c:/users/ben.danametrics/desktop/nexos/project/hardwareprofile.c  ----------------------------------
1:                   #include <plib.h>
2:                   
3:                   #include "p32xxxx.h"
4:                   #include "HardwareProfile.h"
5:                   #include "GenericTypeDefs.h"
6:                   
7:                   UINT32 PBFrequency = 0;
8:                   
9:                   void __attribute__((weak))OSCFailCallback(void)
10:                  {
9D002A34  27BDFFF8   ADDIU SP, SP, -8
9D002A38  AFBE0004   SW FP, 4(SP)
9D002A3C  03A0F021   ADDU FP, SP, ZERO
11:                  	// TODO: To override the default handler define the same function.
12:                  }
9D002A40  03C0E821   ADDU SP, FP, ZERO
9D002A44  8FBE0004   LW FP, 4(SP)
9D002A48  27BD0008   ADDIU SP, SP, 8
9D002A4C  03E00008   JR RA
9D002A50  00000000   NOP
13:                  
14:                  void __ISR(_FAIL_SAFE_MONITOR_VECTOR, ipl3) FSCMISR(void)
15:                  {
9D002A54  415DE800   RDPGPR SP, SP
9D002A58  401A7000   MFC0 K0, EPC
9D002A5C  401B6000   MFC0 K1, Status
9D002A60  27BDFF90   ADDIU SP, SP, -112
9D002A64  AFBA006C   SW K0, 108(SP)
9D002A68  AFBB0068   SW K1, 104(SP)
9D002A6C  7C1B7844   INS K1, ZERO, 1, 15
9D002A70  377B0C00   ORI K1, K1, 3072
9D002A74  409B6000   MTC0 K1, Status
9D002A78  AFBF005C   SW RA, 92(SP)
9D002A7C  AFBE0058   SW FP, 88(SP)
9D002A80  AFB90054   SW T9, 84(SP)
9D002A84  AFB80050   SW T8, 80(SP)
9D002A88  AFAF004C   SW T7, 76(SP)
9D002A8C  AFAE0048   SW T6, 72(SP)
9D002A90  AFAD0044   SW T5, 68(SP)
9D002A94  AFAC0040   SW T4, 64(SP)
9D002A98  AFAB003C   SW T3, 60(SP)
9D002A9C  AFAA0038   SW T2, 56(SP)
9D002AA0  AFA90034   SW T1, 52(SP)
9D002AA4  AFA80030   SW T0, 48(SP)
9D002AA8  AFA7002C   SW A3, 44(SP)
9D002AAC  AFA60028   SW A2, 40(SP)
9D002AB0  AFA50024   SW A1, 36(SP)
9D002AB4  AFA40020   SW A0, 32(SP)
9D002AB8  AFA3001C   SW V1, 28(SP)
9D002ABC  AFA20018   SW V0, 24(SP)
9D002AC0  AFA10014   SW AT, 20(SP)
9D002AC4  00001012   MFLO V0
9D002AC8  AFA20064   SW V0, 100(SP)
9D002ACC  00001810   MFHI V1
9D002AD0  AFA30060   SW V1, 96(SP)
9D002AD4  03A0F021   ADDU FP, SP, ZERO
16:                  	INTClearFlag(INT_FSCM);
9D002AD8  2404005E   ADDIU A0, ZERO, 94
9D002ADC  0F40103F   JAL INTClearFlag
9D002AE0  00000000   NOP
17:                  
18:                  	OSCFailCallback();
9D002AE4  0F400A8D   JAL OSCFailCallback
9D002AE8  00000000   NOP
19:                  }
9D002AEC  03C0E821   ADDU SP, FP, ZERO
9D002AF0  8FA20064   LW V0, 100(SP)
9D002AF4  00400013   MTLO V0
9D002AF8  8FA30060   LW V1, 96(SP)
9D002AFC  00600011   MTHI V1
9D002B00  8FBF005C   LW RA, 92(SP)
9D002B04  8FBE0058   LW FP, 88(SP)
9D002B08  8FB90054   LW T9, 84(SP)
9D002B0C  8FB80050   LW T8, 80(SP)
9D002B10  8FAF004C   LW T7, 76(SP)
9D002B14  8FAE0048   LW T6, 72(SP)
9D002B18  8FAD0044   LW T5, 68(SP)
9D002B1C  8FAC0040   LW T4, 64(SP)
9D002B20  8FAB003C   LW T3, 60(SP)
9D002B24  8FAA0038   LW T2, 56(SP)
9D002B28  8FA90034   LW T1, 52(SP)
9D002B2C  8FA80030   LW T0, 48(SP)
9D002B30  8FA7002C   LW A3, 44(SP)
9D002B34  8FA60028   LW A2, 40(SP)
9D002B38  8FA50024   LW A1, 36(SP)
9D002B3C  8FA40020   LW A0, 32(SP)
9D002B40  8FA3001C   LW V1, 28(SP)
9D002B44  8FA20018   LW V0, 24(SP)
9D002B48  8FA10014   LW AT, 20(SP)
9D002B4C  41606000   DI ZERO
9D002B50  000000C0   EHB
9D002B54  8FBA006C   LW K0, 108(SP)
9D002B58  8FBB0068   LW K1, 104(SP)
9D002B5C  409A7000   MTC0 K0, EPC
9D002B60  27BD0070   ADDIU SP, SP, 112
9D002B64  41DDE800   WRPGPR SP, SP
9D002B68  409B6000   MTC0 K1, Status
9D002B6C  42000018   ERET
20:                  
21:                  UINT32 GetPeripheralClock(void)
22:                  {
9D002B70  27BDFFF8   ADDIU SP, SP, -8
9D002B74  AFBE0004   SW FP, 4(SP)
9D002B78  03A0F021   ADDU FP, SP, ZERO
23:                      return (UINT32)PBFrequency;
9D002B7C  8F828030   LW V0, -32720(GP)
24:                  }
9D002B80  03C0E821   ADDU SP, FP, ZERO
9D002B84  8FBE0004   LW FP, 4(SP)
9D002B88  27BD0008   ADDIU SP, SP, 8
9D002B8C  03E00008   JR RA
9D002B90  00000000   NOP
25:                  
26:                  void SetSystemClocks(UINT32 CPUFrequency)
27:                  {
9D002B94  27BDFFA0   ADDIU SP, SP, -96
9D002B98  AFBF005C   SW RA, 92(SP)
9D002B9C  AFBE0058   SW FP, 88(SP)
9D002BA0  03A0F021   ADDU FP, SP, ZERO
9D002BA4  AFC40060   SW A0, 96(FP)
9D002BA8  8FC20060   LW V0, 96(FP)
9D002BAC  AFC20010   SW V0, 16(FP)
9D002BB0  8FC20010   LW V0, 16(FP)
9D002BB4  AFC20014   SW V0, 20(FP)
9D002BB8  8FC20014   LW V0, 20(FP)
9D002BBC  AFC20018   SW V0, 24(FP)
28:                      PBFrequency = SYSTEMConfigPerformance(CPUFrequency);
9D002E14  AF828030   SW V0, -32720(GP)
29:                  }
9D002E18  03C0E821   ADDU SP, FP, ZERO
---  c:/users/ben.danametrics/desktop/nexos/project/exceptions.c  ---------------------------------------
1:                   /*
2:                   	Developer: Benjamin Michaud
3:                   	Date: August 24, 2012
4:                   	File Name: Exceptions.c
5:                   	Version: 1.00
6:                   	IDE: MPLAB X IDE v1.30
7:                   	Compiler: XC32 v1.10
8:                   
9:                   	Description:  This file contains all the necessary code
10:                  	for handling Exceptions in the PIC32.  An explination
11:                  	of each function can be found in Exceptions.h.
12:                  */
13:                  
14:                  #include <p32xxxx.h>
15:                  #include <plib.h>
16:                  #include <string.h>
17:                  
18:                  #include "GenericTypeDefs.h"
19:                  #include "Exceptions.h"
20:                  
21:                  BOOL __attribute__((weak))GeneralExceptionHandler(EXCEPTION_CODE ExceptionCode, UINT32 ExceptionAddress)
22:                  {
9D0025D4  27BDFFF8   ADDIU SP, SP, -8
9D0025D8  AFBE0004   SW FP, 4(SP)
9D0025DC  03A0F021   ADDU FP, SP, ZERO
9D0025E0  AFC40008   SW A0, 8(FP)
9D0025E4  AFC5000C   SW A1, 12(FP)
23:                  	// TODO: To override the default handler define the same function.
24:                  
25:                  	return (BOOL) FALSE;
9D0025E8  00001021   ADDU V0, ZERO, ZERO
26:                  }
9D0025EC  03C0E821   ADDU SP, FP, ZERO
9D0025F0  8FBE0004   LW FP, 4(SP)
9D0025F4  27BD0008   ADDIU SP, SP, 8
9D0025F8  03E00008   JR RA
9D0025FC  00000000   NOP
27:                  
28:                  void _general_exception_handler(void)
29:                  {
9D002600  27BDFFE0   ADDIU SP, SP, -32
9D002604  AFBF001C   SW RA, 28(SP)
9D002608  AFBE0018   SW FP, 24(SP)
9D00260C  03A0F021   ADDU FP, SP, ZERO
30:                  	UINT32 _epc_code;
31:                  	UINT32 _excep_addr;
32:                  
33:                  	asm volatile("mfc0 %0,$13" : "=r" (_epc_code));
9D002610  401F6800   MFC0 RA, Cause
9D002614  AFDF0010   SW RA, 16(FP)
34:                  	asm volatile("mfc0 %0,$14" : "=r" (_excep_addr));
9D002618  401F7000   MFC0 RA, EPC
9D00261C  AFDF0014   SW RA, 20(FP)
35:                  
36:                  	_epc_code = (UINT32) ((_epc_code & 0x0000007C) >> 2);
9D002620  8FC20010   LW V0, 16(FP)
9D002624  3042007C   ANDI V0, V0, 124
9D002628  00021082   SRL V0, V0, 2
9D00262C  AFC20010   SW V0, 16(FP)
37:                  
38:                  	if(GeneralExceptionHandler((EXCEPTION_CODE) _epc_code, (UINT32) _excep_addr) == TRUE)
9D002630  8FC40010   LW A0, 16(FP)
9D002634  0F400CD9   JAL GeneralExceptionHandler
9D002638  8FC50014   LW A1, 20(FP)
9D00263C  00401821   ADDU V1, V0, ZERO
9D002640  24020001   ADDIU V0, ZERO, 1
9D002644  14620002   BNE V1, V0, 0x9D002650
9D002648  00000000   NOP
39:                  		asm("ERET");
9D00264C  42000018   ERET
40:                  
41:                  	switch(_epc_code)
9D002650  8FC20010   LW V0, 16(FP)
9D002654  2C420013   SLTIU V0, V0, 19
9D002658  10400038   BEQ V0, ZERO, 0x9D00273C
9D00265C  00000000   NOP
9D002660  8FC20010   LW V0, 16(FP)
9D002664  00021880   SLL V1, V0, 2
9D002668  3C029D00   LUI V0, -25344
9D00266C  24422680   ADDIU V0, V0, 9856
9D002670  00621021   ADDU V0, V1, V0
9D002674  8C420000   LW V0, 0(V0)
9D002678  00400008   JR V0
9D00267C  00000000   NOP
42:                  	{
43:                  		case EXCEP_IRQ:
44:                  			while(1);
9D0026CC  0B4009B3   J 0x9D0026CC
9D0026D0  00000000   NOP
45:                  
46:                  		case EXCEP_ADEL:
47:                  			while(1);
9D0026D4  0B4009B5   J 0x9D0026D4
9D0026D8  00000000   NOP
48:                  
49:                  		case EXCEP_ADES:
50:                  			while(1);
9D0026DC  0B4009B7   J 0x9D0026DC
9D0026E0  00000000   NOP
51:                  
52:                  		case EXCEP_IBE:
53:                  			while(1);
9D0026E4  0B4009B9   J 0x9D0026E4
9D0026E8  00000000   NOP
54:                  
55:                  		case EXCEP_DBE:
56:                  			while(1);
9D0026EC  0B4009BB   J 0x9D0026EC
9D0026F0  00000000   NOP
57:                  
58:                  		case EXCEP_SYS:
59:                  			while(1);
9D0026F4  0B4009BD   J 0x9D0026F4
9D0026F8  00000000   NOP
60:                  
61:                  		case EXCEP_BP:
62:                  			while(1);
9D0026FC  0B4009BF   J 0x9D0026FC
9D002700  00000000   NOP
63:                  
64:                  		case EXCEP_RI:
65:                  			while(1);
9D002704  0B4009C1   J 0x9D002704
9D002708  00000000   NOP
66:                  
67:                  		case EXCEP_CPU:
68:                  			while(1);
9D00270C  0B4009C3   J 0x9D00270C
9D002710  00000000   NOP
69:                  
70:                  		case EXCEP_OVERFLOW:
71:                  			while(1);
9D002714  0B4009C5   J 0x9D002714
9D002718  00000000   NOP
72:                  
73:                  		case EXCEP_TRAP:
74:                  			while(1);
9D00271C  0B4009C7   J 0x9D00271C
9D002720  00000000   NOP
75:                  
76:                  		case EXCEP_IS1:
77:                  			while(1);
9D002724  0B4009C9   J 0x9D002724
9D002728  00000000   NOP
78:                  
79:                  		case EXCEP_CEU:
80:                  			while(1);
9D00272C  0B4009CB   J 0x9D00272C
9D002730  00000000   NOP
81:                  
82:                  		case EXCEP_C2E:
83:                  			while(1);
9D002734  0B4009CD   J 0x9D002734
9D002738  00000000   NOP
84:                  
85:                  		default:
86:                  			while(1);
9D00273C  0B4009CF   J 0x9D00273C
9D002740  00000000   NOP
87:                  	}
88:                  }
89:                  
90:                  const BYTE* ExceptionsErrorStrings[] = {
91:                         "Interrupt Error\0",
92:                         "Address Error I\0",
93:                         "Address Error LS\0",
94:                         "Bus Error I\0",
95:                         "Bus Error LS\0",
96:                         "Syscall Error\0",
97:                         "Breakpoint Error\0",
98:                         "Reserve Inst Err\0",
99:                         "CoCPU Unusable\0",
100:                        "Overflow Error\0",
101:                        "Trap Error\0",
102:                        "Imp Specific Err\0",
103:                        "CorExt Unusable\0",
104:                        "CoCPU 2 Unusable\0"
105:                 };
106:                 
107:                 BYTE *ExceptionToString(BYTE *Buffer, BYTE BufferSize, EXCEPTION_CODE EPCCode)
108:                 {
9D002744  27BDFFE8   ADDIU SP, SP, -24
9D002748  AFBF0014   SW RA, 20(SP)
9D00274C  AFBE0010   SW FP, 16(SP)
9D002750  03A0F021   ADDU FP, SP, ZERO
9D002754  AFC40018   SW A0, 24(FP)
9D002758  00A01021   ADDU V0, A1, ZERO
9D00275C  AFC60020   SW A2, 32(FP)
9D002760  A3C2001C   SB V0, 28(FP)
109:                 	switch(EPCCode)
9D002764  8FC20020   LW V0, 32(FP)
9D002768  2C420013   SLTIU V0, V0, 19
9D00276C  104000A7   BEQ V0, ZERO, 0x9D002A0C
9D002770  00000000   NOP
9D002774  8FC20020   LW V0, 32(FP)
9D002778  00021880   SLL V1, V0, 2
9D00277C  3C029D00   LUI V0, -25344
9D002780  24422794   ADDIU V0, V0, 10132
9D002784  00621021   ADDU V0, V1, V0
9D002788  8C420000   LW V0, 0(V0)
9D00278C  00400008   JR V0
9D002790  00000000   NOP
110:                 	{
111:                 		case EXCEP_IRQ:
112:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[0]);
9D0027E0  8FC30018   LW V1, 24(FP)
9D0027E4  3C02A001   LUI V0, -24575
9D0027E8  8C42C610   LW V0, -14832(V0)
9D0027EC  00602021   ADDU A0, V1, ZERO
9D0027F0  00402821   ADDU A1, V0, ZERO
9D0027F4  0F400DF8   JAL strcpy
9D0027F8  00000000   NOP
113:                 			break;
9D0027FC  0B400A86   J 0x9D002A18
9D002800  00000000   NOP
114:                 
115:                 		case EXCEP_ADEL:
116:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[1]);
9D002804  8FC30018   LW V1, 24(FP)
9D002808  3C02A001   LUI V0, -24575
9D00280C  2442C610   ADDIU V0, V0, -14832
9D002810  8C420004   LW V0, 4(V0)
9D002814  00602021   ADDU A0, V1, ZERO
9D002818  00402821   ADDU A1, V0, ZERO
9D00281C  0F400DF8   JAL strcpy
9D002820  00000000   NOP
117:                 			break;
9D002824  0B400A86   J 0x9D002A18
9D002828  00000000   NOP
118:                 
119:                 		case EXCEP_ADES:
120:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[2]);
9D00282C  8FC30018   LW V1, 24(FP)
9D002830  3C02A001   LUI V0, -24575
9D002834  2442C610   ADDIU V0, V0, -14832
9D002838  8C420008   LW V0, 8(V0)
9D00283C  00602021   ADDU A0, V1, ZERO
9D002840  00402821   ADDU A1, V0, ZERO
9D002844  0F400DF8   JAL strcpy
9D002848  00000000   NOP
121:                 			break;
9D00284C  0B400A86   J 0x9D002A18
9D002850  00000000   NOP
122:                 
123:                 		case EXCEP_IBE:
124:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[3]);
9D002854  8FC30018   LW V1, 24(FP)
9D002858  3C02A001   LUI V0, -24575
9D00285C  2442C610   ADDIU V0, V0, -14832
9D002860  8C42000C   LW V0, 12(V0)
9D002864  00602021   ADDU A0, V1, ZERO
9D002868  00402821   ADDU A1, V0, ZERO
9D00286C  0F400DF8   JAL strcpy
9D002870  00000000   NOP
125:                 			break;
9D002874  0B400A86   J 0x9D002A18
9D002878  00000000   NOP
126:                 
127:                 		case EXCEP_DBE:
128:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[4]);
9D00287C  8FC30018   LW V1, 24(FP)
9D002880  3C02A001   LUI V0, -24575
9D002884  2442C610   ADDIU V0, V0, -14832
9D002888  8C420010   LW V0, 16(V0)
9D00288C  00602021   ADDU A0, V1, ZERO
9D002890  00402821   ADDU A1, V0, ZERO
9D002894  0F400DF8   JAL strcpy
9D002898  00000000   NOP
129:                 			break;
9D00289C  0B400A86   J 0x9D002A18
9D0028A0  00000000   NOP
130:                 
131:                 		case EXCEP_SYS:
132:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[5]);
9D0028A4  8FC30018   LW V1, 24(FP)
9D0028A8  3C02A001   LUI V0, -24575
9D0028AC  2442C610   ADDIU V0, V0, -14832
9D0028B0  8C420014   LW V0, 20(V0)
9D0028B4  00602021   ADDU A0, V1, ZERO
9D0028B8  00402821   ADDU A1, V0, ZERO
9D0028BC  0F400DF8   JAL strcpy
9D0028C0  00000000   NOP
133:                 			break;
9D0028C4  0B400A86   J 0x9D002A18
9D0028C8  00000000   NOP
134:                 
135:                 		case EXCEP_BP:
136:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[6]);
9D0028CC  8FC30018   LW V1, 24(FP)
9D0028D0  3C02A001   LUI V0, -24575
9D0028D4  2442C610   ADDIU V0, V0, -14832
9D0028D8  8C420018   LW V0, 24(V0)
9D0028DC  00602021   ADDU A0, V1, ZERO
9D0028E0  00402821   ADDU A1, V0, ZERO
9D0028E4  0F400DF8   JAL strcpy
9D0028E8  00000000   NOP
137:                 			break;
9D0028EC  0B400A86   J 0x9D002A18
9D0028F0  00000000   NOP
138:                 
139:                 		case EXCEP_RI:
140:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[7]);
9D0028F4  8FC30018   LW V1, 24(FP)
9D0028F8  3C02A001   LUI V0, -24575
9D0028FC  2442C610   ADDIU V0, V0, -14832
9D002900  8C42001C   LW V0, 28(V0)
9D002904  00602021   ADDU A0, V1, ZERO
9D002908  00402821   ADDU A1, V0, ZERO
9D00290C  0F400DF8   JAL strcpy
9D002910  00000000   NOP
141:                 			break;
9D002914  0B400A86   J 0x9D002A18
9D002918  00000000   NOP
142:                 
143:                 		case EXCEP_CPU:
144:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[8]);
9D00291C  8FC30018   LW V1, 24(FP)
9D002920  3C02A001   LUI V0, -24575
9D002924  2442C610   ADDIU V0, V0, -14832
9D002928  8C420020   LW V0, 32(V0)
9D00292C  00602021   ADDU A0, V1, ZERO
9D002930  00402821   ADDU A1, V0, ZERO
9D002934  0F400DF8   JAL strcpy
9D002938  00000000   NOP
145:                 			break;
9D00293C  0B400A86   J 0x9D002A18
9D002940  00000000   NOP
146:                 
147:                 		case EXCEP_OVERFLOW:
148:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[9]);
9D002944  8FC30018   LW V1, 24(FP)
9D002948  3C02A001   LUI V0, -24575
9D00294C  2442C610   ADDIU V0, V0, -14832
9D002950  8C420024   LW V0, 36(V0)
9D002954  00602021   ADDU A0, V1, ZERO
9D002958  00402821   ADDU A1, V0, ZERO
9D00295C  0F400DF8   JAL strcpy
9D002960  00000000   NOP
149:                 			break;
9D002964  0B400A86   J 0x9D002A18
9D002968  00000000   NOP
150:                 
151:                 		case EXCEP_TRAP:
152:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[10]);
9D00296C  8FC30018   LW V1, 24(FP)
9D002970  3C02A001   LUI V0, -24575
9D002974  2442C610   ADDIU V0, V0, -14832
9D002978  8C420028   LW V0, 40(V0)
9D00297C  00602021   ADDU A0, V1, ZERO
9D002980  00402821   ADDU A1, V0, ZERO
9D002984  0F400DF8   JAL strcpy
9D002988  00000000   NOP
153:                 			break;
9D00298C  0B400A86   J 0x9D002A18
9D002990  00000000   NOP
154:                 
155:                 		case EXCEP_IS1:
156:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[11]);
9D002994  8FC30018   LW V1, 24(FP)
9D002998  3C02A001   LUI V0, -24575
9D00299C  2442C610   ADDIU V0, V0, -14832
9D0029A0  8C42002C   LW V0, 44(V0)
9D0029A4  00602021   ADDU A0, V1, ZERO
9D0029A8  00402821   ADDU A1, V0, ZERO
9D0029AC  0F400DF8   JAL strcpy
9D0029B0  00000000   NOP
157:                 			break;
9D0029B4  0B400A86   J 0x9D002A18
9D0029B8  00000000   NOP
158:                 
159:                 		case EXCEP_CEU:
160:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[12]);
9D0029BC  8FC30018   LW V1, 24(FP)
9D0029C0  3C02A001   LUI V0, -24575
9D0029C4  2442C610   ADDIU V0, V0, -14832
9D0029C8  8C420030   LW V0, 48(V0)
9D0029CC  00602021   ADDU A0, V1, ZERO
9D0029D0  00402821   ADDU A1, V0, ZERO
9D0029D4  0F400DF8   JAL strcpy
9D0029D8  00000000   NOP
161:                 			break;
9D0029DC  0B400A86   J 0x9D002A18
9D0029E0  00000000   NOP
162:                 
163:                 		case EXCEP_C2E:
164:                 			strcpy((char*) Buffer, (const char*) ExceptionsErrorStrings[13]);
9D0029E4  8FC30018   LW V1, 24(FP)
9D0029E8  3C02A001   LUI V0, -24575
9D0029EC  2442C610   ADDIU V0, V0, -14832
9D0029F0  8C420034   LW V0, 52(V0)
9D0029F4  00602021   ADDU A0, V1, ZERO
9D0029F8  00402821   ADDU A1, V0, ZERO
9D0029FC  0F400DF8   JAL strcpy
9D002A00  00000000   NOP
165:                 			break;
9D002A04  0B400A86   J 0x9D002A18
9D002A08  00000000   NOP
166:                 
167:                 		default:
168:                 			return (BYTE*) NULL;
9D002A0C  00001021   ADDU V0, ZERO, ZERO
9D002A10  0B400A87   J 0x9D002A1C
9D002A14  00000000   NOP
169:                 	}
170:                 
171:                 	return (BYTE*) Buffer;
9D002A18  8FC20018   LW V0, 24(FP)
172:                 }
9D002A1C  03C0E821   ADDU SP, FP, ZERO
---  c:/users/ben.danametrics/desktop/nexos/project/criticalsections.c  ---------------------------------
1:                   #include "CriticalSections.h"
2:                   #include "Kernel.h"
3:                   #include "Port.h"
4:                   
5:                   volatile OS_WORD gCurrentCriticalCount = 0;
6:                   
7:                   void EnterCritical(void)
8:                   {
9D003E08  27BDFFE8   ADDIU SP, SP, -24
9D003E0C  AFBF0014   SW RA, 20(SP)
9D003E10  AFBE0010   SW FP, 16(SP)
9D003E14  03A0F021   ADDU FP, SP, ZERO
9:                   	if(gCurrentCriticalCount == 0)
9D003E18  8F82802C   LW V0, -32724(GP)
9D003E1C  14400004   BNE V0, ZERO, 0x9D003E30
9D003E20  00000000   NOP
10:                  	{
11:                  		PortSetInterruptPriority(OS_PRIORITY);
9D003E24  24040001   ADDIU A0, ZERO, 1
9D003E28  0F400C14   JAL PortSetInterruptPriority
9D003E2C  00000000   NOP
12:                  	}
13:                  
14:                  	gCurrentCriticalCount++;
9D003E30  8F82802C   LW V0, -32724(GP)
9D003E34  24420001   ADDIU V0, V0, 1
9D003E38  AF82802C   SW V0, -32724(GP)
15:                  }
9D003E3C  03C0E821   ADDU SP, FP, ZERO
9D003E40  8FBF0014   LW RA, 20(SP)
9D003E44  8FBE0010   LW FP, 16(SP)
9D003E48  27BD0018   ADDIU SP, SP, 24
9D003E4C  03E00008   JR RA
9D003E50  00000000   NOP
16:                  
17:                  void ExitCritical(void)
18:                  {
9D003E54  27BDFFE8   ADDIU SP, SP, -24
9D003E58  AFBF0014   SW RA, 20(SP)
9D003E5C  AFBE0010   SW FP, 16(SP)
9D003E60  03A0F021   ADDU FP, SP, ZERO
19:                  	gCurrentCriticalCount--;
9D003E64  8F82802C   LW V0, -32724(GP)
9D003E68  2442FFFF   ADDIU V0, V0, -1
9D003E6C  AF82802C   SW V0, -32724(GP)
20:                  
21:                  	if(gCurrentCriticalCount == 0)
9D003E70  8F82802C   LW V0, -32724(GP)
9D003E74  14400004   BNE V0, ZERO, 0x9D003E88
9D003E78  00000000   NOP
22:                  	{
23:                  		PortSetInterruptPriority(0);
9D003E7C  00002021   ADDU A0, ZERO, ZERO
9D003E80  0F400C14   JAL PortSetInterruptPriority
9D003E84  00000000   NOP
24:                  	}
25:                  }
9D003E88  03C0E821   ADDU SP, FP, ZERO
---  c:/program files (x86)/microchip/xc32/v1.32/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
9D002BC0  8FC20018   LW V0, 24(FP)
9D002BC4  AFC2001C   SW V0, 28(FP)
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D002BC8  8FC30018   LW V1, 24(FP)
9D002BCC  3C0204C4   LUI V0, 1220
9D002BD0  3442B401   ORI V0, V0, -19455
9D002BD4  0062102B   SLTU V0, V1, V0
9D002BD8  14400008   BNE V0, ZERO, 0x9D002BFC
9D002BDC  00000000   NOP
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
9D002BE0  3C020008   LUI V0, 8
9D002BE4  AFC20020   SW V0, 32(FP)
131:                         pb_clock >>= 1;
9D002BE8  8FC2001C   LW V0, 28(FP)
9D002BEC  00021042   SRL V0, V0, 1
9D002BF0  AFC2001C   SW V0, 28(FP)
9D002BF4  0B400B00   J 0x9D002C00
9D002BF8  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
9D002BFC  AFC00020   SW ZERO, 32(FP)
9D002C00  8FC20020   LW V0, 32(FP)
9D002C04  AFC20024   SW V0, 36(FP)
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
9D002D48  8FC2001C   LW V0, 28(FP)
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D002D4C  AFC2003C   SW V0, 60(FP)
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
9D002D50  AFC00040   SW ZERO, 64(FP)
9D002D54  0B400B5F   J 0x9D002D7C
9D002D58  00000000   NOP
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
9D002D7C  8FC30014   LW V1, 20(FP)
9D002D80  3C0201C9   LUI V0, 457
9D002D84  3442C381   ORI V0, V0, -15487
9D002D88  0062102B   SLTU V0, V1, V0
9D002D8C  1040FFF3   BEQ V0, ZERO, 0x9D002D5C
9D002D90  00000000   NOP
240:                     {
241:                         wait_states++;
9D002D5C  8FC20040   LW V0, 64(FP)
9D002D60  24420001   ADDIU V0, V0, 1
9D002D64  AFC20040   SW V0, 64(FP)
242:                         sys_clock -= FLASH_SPEED_HZ;
9D002D68  8FC30014   LW V1, 20(FP)
9D002D6C  3C02FE36   LUI V0, -458
9D002D70  34423C80   ORI V0, V0, 15488
9D002D74  00621021   ADDU V0, V1, V0
9D002D78  AFC20014   SW V0, 20(FP)
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
9D002D94  0F40109B   JAL INTDisableInterrupts
9D002D98  00000000   NOP
9D002D9C  AFC20044   SW V0, 68(FP)
246:                     mCheConfigure(wait_states);
9D002DA0  3C02BF88   LUI V0, -16504
9D002DA4  8FC30040   LW V1, 64(FP)
9D002DA8  AC434000   SW V1, 16384(V0)
247:                     INTRestoreInterrupts(int_status);
9D002DAC  8FC40044   LW A0, 68(FP)
9D002DB0  0F401067   JAL INTRestoreInterrupts
9D002DB4  00000000   NOP
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
9D002DB8  8FC2003C   LW V0, 60(FP)
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
9D002DBC  AFC20048   SW V0, 72(FP)
292:                 
293:                     int_status=INTDisableInterrupts();
9D002DC0  0F40109B   JAL INTDisableInterrupts
9D002DC4  00000000   NOP
9D002DC8  AFC2004C   SW V0, 76(FP)
294:                 
295:                     mBMXDisableDRMWaitState();
9D002DCC  3C02BF88   LUI V0, -16504
9D002DD0  24030040   ADDIU V1, ZERO, 64
9D002DD4  AC432004   SW V1, 8196(V0)
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
9D002DD8  3C02BF88   LUI V0, -16504
9D002DDC  8C424000   LW V0, 16384(V0)
9D002DE0  AFC20050   SW V0, 80(FP)
299:                     cache_status |= CHE_CONF_PF_ALL;
9D002DE4  8FC20050   LW V0, 80(FP)
9D002DE8  34420030   ORI V0, V0, 48
9D002DEC  AFC20050   SW V0, 80(FP)
300:                     mCheConfigure(cache_status);
9D002DF0  3C02BF88   LUI V0, -16504
9D002DF4  8FC30050   LW V1, 80(FP)
9D002DF8  AC434000   SW V1, 16384(V0)
301:                     CheKseg0CacheOn();
9D002DFC  0F40107A   JAL CheKseg0CacheOn
9D002E00  00000000   NOP
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
9D002E04  8FC4004C   LW A0, 76(FP)
9D002E08  0F401067   JAL INTRestoreInterrupts
9D002E0C  00000000   NOP
305:                 
306:                     return pb_clk;
9D002E10  8FC20048   LW V0, 72(FP)
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/program files (x86)/microchip/xc32/v1.32/pic32mx/include/peripheral/osc.h  ----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:	    Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   * 		     		source and then switches to the new clock source
74:                   *
75:                   *		    		Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                  	/******************************************************************************
80:                  	 * Available options for source parameter
81:                  	 *****************************************************************************/
82:                  		// CPU Oscillator modes - values are mutually exclusive
83:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
84:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
85:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
88:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
90:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                  	/******************************************************************************
93:                  	 * Available options for mult parameter
94:                  	 *****************************************************************************/
95:                  		// CPU PLL multiplier values - values are mutually exclusive
96:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                 		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                 		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                 		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                 		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                 	/******************************************************************************
106:                 	 * Available options for post parameter
107:                 	 *****************************************************************************/
108:                 		// CPU PLL output divisor values - values are mutuallye exclusive
109:                 		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                 		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                 	/******************************************************************************
119:                 	 * Available options for div parameter
120:                 	 *****************************************************************************/
121:                 		// CPU FRC output divisor values - values are mutually exclusive
122:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                 	/***********************************
131:                 	 * End parameter values
132:                 	 ************************************/
133:                 
134:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
135:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
136:                 	
137:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
138:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
139:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
140:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
141:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
142:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
143:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
144:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
145:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
146:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
147:                 		
148:                 	typedef enum
149:                 	{		
150:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
151:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
152:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
153:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
154:                 	} OSCREFConfigFlags;
155:                 	
156:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
157:                 	 
158:                 
159:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
160:                 
161:                 #endif
162:                 
163:                 	 
164:                 	 
165:                 	 
166:                 /*********************************************************************
167:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
168:                  *
169:                  * Description:	Configures peripheral bus divisor
170:                  *
171:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
172:                  *
173:                  * Inputs:    oscPbDiv - desired PB divider
174:                  *
175:                  * Output:      None
176:                  *
177:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
178:                  *
179:                  ********************************************************************/
180:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
181:                 {
182:                 	unsigned int dma_status;
183:                 	unsigned int int_status;
184:                 	__OSCCONbits_t oscBits;
185:                 
186:                 	mSYSTEMUnlock(int_status, dma_status);
9D002C08  0F40109B   JAL INTDisableInterrupts
9D002C0C  00000000   NOP
9D002C10  AFC20028   SW V0, 40(FP)
9D002C58  AFC20030   SW V0, 48(FP)
9D002C5C  3C02BF81   LUI V0, -16511
9D002C60  AC40F230   SW ZERO, -3536(V0)
9D002C64  3C02BF81   LUI V0, -16511
9D002C68  3C03AA99   LUI V1, -21863
9D002C6C  34636655   ORI V1, V1, 26197
9D002C70  AC43F230   SW V1, -3536(V0)
9D002C74  3C02BF81   LUI V0, -16511
9D002C78  3C035566   LUI V1, 21862
9D002C7C  346399AA   ORI V1, V1, -26198
9D002C80  AC43F230   SW V1, -3536(V0)
187:                 	
188:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D002C84  3C02BF81   LUI V0, -16511
9D002C88  8C42F000   LW V0, -4096(V0)
9D002C8C  AFC20054   SW V0, 84(FP)
189:                 	oscBits.PBDIV=0;
9D002C90  8FC20054   LW V0, 84(FP)
9D002C94  7C02A4C4   INS V0, ZERO, 19, 2
9D002C98  AFC20054   SW V0, 84(FP)
190:                 	oscBits.w|=oscPbDiv;	
9D002C9C  8FC30054   LW V1, 84(FP)
9D002CA0  8FC20024   LW V0, 36(FP)
9D002CA4  00621025   OR V0, V1, V0
9D002CA8  AFC20054   SW V0, 84(FP)
191:                 	OSCCON=oscBits.w;		// write back
9D002CAC  8FC30054   LW V1, 84(FP)
9D002CB0  3C02BF81   LUI V0, -16511
9D002CB4  AC43F000   SW V1, -4096(V0)
192:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D002CB8  3C02BF81   LUI V0, -16511
9D002CBC  8C42F000   LW V0, -4096(V0)
9D002CC0  AFC20054   SW V0, 84(FP)
193:                 	
194:                 	mSYSTEMLock(int_status, dma_status);
9D002CC4  3C02BF81   LUI V0, -16511
9D002CC8  3C033333   LUI V1, 13107
9D002CCC  34633333   ORI V1, V1, 13107
9D002CD0  AC43F230   SW V1, -3536(V0)
9D002CD4  8FC20030   LW V0, 48(FP)
9D002CD8  AFC20034   SW V0, 52(FP)
9D002D3C  8FC40028   LW A0, 40(FP)
9D002D40  0F401067   JAL INTRestoreInterrupts
9D002D44  00000000   NOP
195:                 }
196:                 
197:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
198:                 
199:                 
200:                 
201:                 	/******************************************************************************
202:                 	 * Available options for config parameter
203:                 	 *****************************************************************************/
204:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
205:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
206:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
207:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
208:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
209:                 	/***********************************
210:                 	 * End config parameter values
211:                 	 ************************************/
212:                 
213:                 
214:                 /*********************************************************************
215:                  * Function:    mOSCGetPBDIV()
216:                  *
217:                  * Description:	Reads peripheral bus divisor
218:                  *
219:                  * PreCondition:None
220:                  *
221:                  * Inputs:	  	None
222:                  *
223:                  * Output:      None
224:                  *
225:                  * Example:	  	mOSCGetPBDIV()
226:                  *
227:                  ********************************************************************/
228:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
229:                 
230:                 
231:                 /*********************************************************************
232:                  * Function:    mOSCClockFailStatus()
233:                  *
234:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
235:                  *
236:                  * PreCondition: None
237:                  *
238:                  * Inputs:	  	None
239:                  *
240:                  * Output:      None
241:                  *
242:                  * Example:	  	mOSCClockFailStatus()
243:                  *
244:                  ********************************************************************/
245:                 #define mOSCClockFailStatus (OSCCONbits.CF)
246:                 
247:                 
248:                 /*********************************************************************
249:                  * Function:      	mOSCEnableSOSC()
250:                  *
251:                  * Description:	  	Enables the LPRC
252:                  *
253:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
254:                  *
255:                  * Inputs:	  		None
256:                  *
257:                  * Output:        	None
258:                  *
259:                  * Example:	  		mOSCEnableSOSC()
260:                  *
261:                  ********************************************************************/
262:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
263:                 
264:                 
265:                 /*********************************************************************
266:                  * Function:      	mOSCDisableSOSC(config)
267:                  *
268:                  * Description:	  	Disables SOSC
269:                  *
270:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
271:                  *
272:                  * Inputs:	  		None
273:                  *
274:                  * Output:        	None
275:                  *
276:                  * Example:	  		mOSCDisableSOSC()
277:                  *
278:                  ********************************************************************/
279:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
280:                 
281:                 
282:                 
283:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.32/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ----------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                  	#define _DMA_CHANNELS		// DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                  	typedef enum
66:                  	{
67:                  		DMA_CHANNEL0,
68:                  	#ifdef _DMAC1
69:                  		DMA_CHANNEL1,
70:                  	#ifdef _DMAC2
71:                  		DMA_CHANNEL2,
72:                  	#ifdef _DMAC3
73:                  		DMA_CHANNEL3,
74:                  	#ifdef _DMAC4
75:                  		DMA_CHANNEL4,
76:                  	#ifdef _DMAC5
77:                  		DMA_CHANNEL5,
78:                  	#ifdef _DMAC6
79:                  		DMA_CHANNEL6,
80:                  	#ifdef _DMAC7
81:                  		DMA_CHANNEL7,
82:                  	#endif	// _DMAC7
83:                  	#endif	// _DMAC6
84:                  	#endif	// _DMAC5
85:                  	#endif	// _DMAC4
86:                  	#endif	// _DMAC3
87:                  	#endif	// _DMAC2
88:                  	#endif	// _DMAC1
89:                  		//	add/remove DMA channel as needed here
90:                  
91:                  		DMA_CHANNELS	// number of current available channels
92:                  	}DmaChannel;
93:                  
94:                  
95:                  	// Relative Dma channels priority, between each other
96:                  	typedef enum
97:                  	{
98:                  		DMA_CHN_PRI0,
99:                  		DMA_CHN_PRI1,
100:                 		DMA_CHN_PRI2,
101:                 		DMA_CHN_PRI3
102:                 	}DmaChannelPri;
103:                 
104:                 
105:                 
106:                 	// high level definitions for the API functions
107:                 
108:                 	typedef enum
109:                 	{
110:                 		DMA_OPEN_DEFAULT = 0,							        // DMA default operation
111:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
112:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
113:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
114:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
115:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
116:                 		DMA_OPEN_MATCH	= 0x80000000,						    // DMA channel stops on match
117:                 	}DmaOpenFlags;	// flags for the channel open
118:                 
119:                 
120:                 	typedef enum
121:                 	{
122:                 		DMA_EV_ERR =			0x1,		// address error event
123:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
124:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
125:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
126:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
127:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
128:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
129:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
130:                 
131:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
132:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
133:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
134:                 
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_TXFER_OK,			// the transfer was performed successfully
139:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
140:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
141:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
142:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
143:                 		DMA_TXFER_TMO			// DMA transfer timeout
144:                 	}DmaTxferRes;		// DMA transfer result
145:                 
146:                 	typedef enum
147:                 	{
148:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
149:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
150:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
151:                 	}DmaWaitMode;		// DMA transfer wait mode
152:                 
153:                 	typedef enum
154:                 	{
155:                 		DMA_CHKSUM_CRC,		// LFSR CRC
156:                 		DMA_CHKSUM_IP,		// IP Checksum
157:                 	}DmaChksumType;		// DMA SFM supported checksum types
158:                 
159:                 	typedef enum
160:                 	{
161:                 		DMA_BITO_MSb,		// MSb first (not reflected)
162:                 		DMA_BITO_LSb,		// LSb first (reflected)
163:                 	}DmaBitOrder;		// DMA SFM supported bit ordering
164:                 
165:                 	typedef enum
166:                 	{
167:                 		DMA_REORDER_NOT,	// no reordering, destination matches the source
168:                 		DMA_REORDER_ENDIAN,	// change endianess on word (32 bit) boundaries: LE<->BE
169:                 		DMA_REORDER_SWAP_HALF,	// swap half words (16 bit) within word (32 bit)		
170:                 		DMA_REORDER_SWAP_BYTE,	// swap bytes within half word (16 bit)				
171:                 	}DmaReorderMode;	// DMA SFM supported re-ordering modes
172:                 
173:                 
174:                 	/*********************************************************************
175:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
176:                 	 *
177:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
178:                 	 *
179:                 	 * Input:           chn    - channel to be configured in the DMA controller
180:                 	 *                  chPri  - the priority given to the channel, 0-3
181:                 	 *                  oFlags - orred flags specifying the open mode:
182:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
183:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
184:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
185:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
186:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
187:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
188:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
189:                 	 *
190:                 	 *
191:                 	 *
192:                 	 * Output:          None
193:                 	 *
194:                 	 * Side Effects:    None
195:                 	 *
196:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
197:                 	 *
198:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
199:                 	 *                  Use the low level functions to address special settings.
200:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
201:                 	 *                  After that the channel is configured.
202:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
203:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
204:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
205:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
206:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
207:                 	 *                  User has to call event channel functions to enable the event flags if needed.
208:                 	 *
209:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
210:                 	 ********************************************************************/
211:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
212:                 
213:                 	/*********************************************************************
214:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
215:                 	 *
216:                 	 * PreCondition:    None
217:                 	 *
218:                 	 * Input:			chn		- channel to be enabled
219:                 	 *
220:                 	 * Output:          None
221:                 	 *
222:                 	 * Side Effects:    None
223:                 	 *
224:                 	 * Overview:		The function enables a previously configured DMA channel.
225:                 	 *
226:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
227:                 	 *
228:                 	 * Example:			DmaChnEnable(DMA_CHANNEL3);
229:                 	 ********************************************************************/
230:                 	 void			DmaChnEnable(DmaChannel chn);
231:                 
232:                 	/*********************************************************************
233:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
234:                 	 *
235:                 	 * PreCondition:    None
236:                 	 *
237:                 	 * Input:			chn		- selected channel in the DMA controller
238:                 	 *
239:                 	 * Output:          None
240:                 	 *
241:                 	 * Side Effects:    None
242:                 	 *
243:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
244:                 	 *
245:                 	 * Note:            None.
246:                 	 *
247:                 	 * Example:			DmaChnDisable(DMA_CHANNEL3);
248:                 	 ********************************************************************/
249:                 	 void			DmaChnDisable(DmaChannel chn);
250:                 
251:                 	/*********************************************************************
252:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
253:                 	 *
254:                 	 * PreCondition:    chn		- valid DMA channel
255:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
256:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
257:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
258:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
259:                 	 *
260:                 	 * Input:			chn			- DMA channel number
261:                 	 * 								- vSrcAdd: source of the DMA transfer
262:                 	 * 								- vDstAdd: destination of the DMA transfer
263:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
264:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
265:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
266:                 	 *
267:                 	 * Output:          None
268:                 	 *
269:                 	 * Side Effects:    None
270:                 	 *
271:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
272:                 	 * 					the source and the destination addresses.
273:                 	 * 					the source and destination lengths
274:                 	 * 					and the number of bytes	transferred per event.
275:                 	 *
276:                 	 * Note:            The function clears the existing DMA channel event flags.
277:                 	 *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
278:                 	 *
279:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
280:                 	 ********************************************************************/
281:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
282:                 
283:                 
284:                 	/*********************************************************************
285:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
286:                 	 *
287:                 	 * PreCondition:    chn		- valid DMA channel
288:                 	 *
289:                 	 * Input:           chn		- DMA channel number
290:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
291:                 	 * Output:          None
292:                 	 *
293:                 	 * Side Effects:    None
294:                 	 *
295:                 	 * Overview:        The function is a helper to set directly the transfer source address.
296:                 	 *
297:                 	 * Note:            None.
298:                 	 *
299:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
300:                 	 ********************************************************************/
301:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
302:                 
303:                 	/*********************************************************************
304:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
305:                 	 *
306:                 	 * PreCondition:    chn		- valid DMA channel
307:                 	 *
308:                 	 * Input:			chn			- DMA channel number
309:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
310:                 	 * Output:          None
311:                 	 *
312:                 	 * Side Effects:    None
313:                 	 *
314:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
315:                 	 *
316:                 	 * Note:            None
317:                 	 *
318:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
319:                 	 ********************************************************************/
320:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
321:                 
322:                 	/*********************************************************************
323:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
324:                 	 *
325:                 	 * PreCondition:    chn	- valid DMA channel
326:                 	 *
327:                 	 * Input:			chn		- DMA channel number
328:                 	 * 					pattern	-  the match pattern
329:                 	 *
330:                 	 * Output:          None
331:                 	 *
332:                 	 * Side Effects:    None
333:                 	 *
334:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
335:                 	 *
336:                 	 * Note:            None.
337:                 	 *
338:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
339:                 	 ********************************************************************/
340:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
341:                 
342:                 	/*********************************************************************
343:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
344:                 	 *
345:                 	 * PreCondition:    chn	- valid DMA channel
346:                 	 *
347:                 	 * Input:			chn		- DMA channel number
348:                 	 *
349:                 	 * Output:          The channel match pattern.
350:                 	 *
351:                 	 * Side Effects:    None
352:                 	 *
353:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
354:                 	 *
355:                 	 * Note:            None.
356:                 	 *
357:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
358:                 	 ********************************************************************/
359:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
360:                 
361:                 	/*********************************************************************
362:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
363:                 	 *
364:                 	 * PreCondition:    chn	- valid DMA channel
365:                 	 *
366:                 	 * Input:			chn		- DMA channel number
367:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
368:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
369:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
370:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
371:                 	 * 								If 0, wait forever.
372:                 	 *
373:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
374:                 	 * 					an DmaTxferRes error code  otherwise
375:                 	 *
376:                 	 * Side Effects:    None
377:                 	 *
378:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
379:                 	 * 					The DMA channel is enabled.
380:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
381:                 	 * 					this event) the function will periodically query the DMA controller for the
382:                 	 * 					transfer completion status.
383:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
384:                      * 					the block transfer than the function will re-force the transfer for each cell.
385:                 	 *
386:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
387:                      *                  by hardware interrupt requests.
388:                      *                  This is because the transfers are software forced, theere is no
389:                      *                  wait for the occurrence of the hardware trigger. 
390:                 	 *
391:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
392:                 	 ********************************************************************/
393:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
394:                 
395:                 	/*********************************************************************
396:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
397:                 	 *
398:                 	 * PreCondition:    chn	- valid DMA channel
399:                 	 *
400:                 	 * Input:			chn		- DMA channel number
401:                 	 *
402:                 	 * Output:          None
403:                 	 *
404:                 	 * Side Effects:    None
405:                 	 *
406:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
407:                 	 *
408:                 	 * Note:            None.
409:                 	 *
410:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL3);
411:                 	 ********************************************************************/
412:                 	 void			DmaChnForceTxfer(DmaChannel chn);
413:                 
414:                 	/*********************************************************************
415:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
416:                 	 *
417:                 	 * PreCondition:    chn	- valid DMA channel
418:                 	 *
419:                 	 * Input:			chn		- DMA channel number
420:                 	 *
421:                 	 * Output:          None
422:                 	 *
423:                 	 * Side Effects:    None
424:                 	 *
425:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
426:                 	 *
427:                 	 * Note:            None.
428:                 	 *
429:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL3);
430:                 	 ********************************************************************/
431:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
432:                 
433:                 	// High level channel event and interrupt control functions
434:                 
435:                 	/*********************************************************************
436:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                 	 *
438:                 	 * PreCondition:    chn	- valid DMA channel
439:                 	 *
440:                 	 * Input:			chn		- DMA channel number
441:                 	 * 					eFlags	- event flags with the following significance:
442:                 	 * 								- DMA_EV_ERR: address error event
443:                 	 * 								- DMA_EV_ABORT: transfer abort event
444:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
445:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
446:                 	 * 								- DMA_EV_DST_HALF: destination half event
447:                 	 * 								- DMA_EV_DST_FULL: destination full event
448:                 	 * 								- DMA_EV_SRC_HALF: source half event
449:                 	 * 								- DMA_EV_SRC_FULL: source full event
450:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
451:                 	 *
452:                 	 * Output:          None
453:                 	 *
454:                 	 * Side Effects:    None
455:                 	 *
456:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
457:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
459:                 	 *
460:                 	 * Note:            None.
461:                 	 *
462:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                 	 ********************************************************************/
464:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                 	/*********************************************************************
467:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                 	 *
469:                 	 * PreCondition:    chn	- valid DMA channel
470:                 	 *
471:                 	 * Input:			chn		- DMA channel number
472:                 	 * 					eFlags	- event flags with the following significance:
473:                 	 * 								- DMA_EV_ERR: address error event
474:                 	 * 								- DMA_EV_ABORT: transfer abort event
475:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
476:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
477:                 	 * 								- DMA_EV_DST_HALF: destination half event
478:                 	 * 								- DMA_EV_DST_FULL: destination full event
479:                 	 * 								- DMA_EV_SRC_HALF: source half event
480:                 	 * 								- DMA_EV_SRC_FULL: source full event
481:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
482:                 	 *
483:                 	 * Output:          None
484:                 	 *
485:                 	 * Side Effects:    None
486:                 	 *
487:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
488:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
489:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
490:                 	 *
491:                 	 * Note:            None.
492:                 	 *
493:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
494:                 	 ********************************************************************/
495:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
496:                 
497:                 	/*********************************************************************
498:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
499:                 	 *
500:                 	 * PreCondition:    chn	- valid DMA channel
501:                 	 *
502:                 	 * Input:			chn		- DMA channel number
503:                 	 * 					eFlags	- event flags with the following significance:
504:                 	 * 								- DMA_EV_ERR: address error event
505:                 	 * 								- DMA_EV_ABORT: transfer abort event
506:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
507:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
508:                 	 * 								- DMA_EV_DST_HALF: destination half event
509:                 	 * 								- DMA_EV_DST_FULL: destination full event
510:                 	 * 								- DMA_EV_SRC_HALF: source half event
511:                 	 * 								- DMA_EV_SRC_FULL: source full event
512:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
513:                 	 *
514:                 	 * Output:          None
515:                 	 *
516:                 	 * Side Effects:    None
517:                 	 *
518:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
519:                 	 * 					The channel event flags are forced to the eFlags value.
520:                 	 *
521:                 	 * Note:            None.
522:                 	 *
523:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
524:                 	 ********************************************************************/
525:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
526:                 
527:                 	/*********************************************************************
528:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
529:                 	 *
530:                 	 * PreCondition:    chn	- valid DMA channel
531:                 	 *
532:                 	 * Input:			chn		- DMA channel number
533:                 	 *
534:                 	 * Output:          - event flags with the following significance:
535:                 	 * 						- DMA_EV_ERR: address error event
536:                 	 * 						- DMA_EV_ABORT: transfer abort event
537:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
538:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
539:                 	 * 						- DMA_EV_DST_HALF: destination half event
540:                 	 * 						- DMA_EV_DST_FULL: destination full event
541:                 	 * 						- DMA_EV_SRC_HALF: source half event
542:                 	 * 						- DMA_EV_SRC_FULL: source full event
543:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
544:                 	 *
545:                 	 * Side Effects:    None
546:                 	 *
547:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
548:                 	 *
549:                 	 * Note:            None.
550:                 	 *
551:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
552:                 	 ********************************************************************/
553:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
554:                 
555:                 	/*********************************************************************
556:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
557:                 	 *
558:                 	 * PreCondition:    chn	- valid DMA channel
559:                 	 *
560:                 	 * Input:			chn		- DMA channel number
561:                 	 * 					eFlags	- event flags with the following significance:
562:                 	 * 								- DMA_EV_ERR: address error event
563:                 	 * 								- DMA_EV_ABORT: transfer abort event
564:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
565:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
566:                 	 * 								- DMA_EV_DST_HALF: destination half event
567:                 	 * 								- DMA_EV_DST_FULL: destination full event
568:                 	 * 								- DMA_EV_SRC_HALF: source half event
569:                 	 * 								- DMA_EV_SRC_FULL: source full event
570:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
571:                 	 *
572:                 	 * Output:          None
573:                 	 *
574:                 	 * Side Effects:    None
575:                 	 *
576:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
577:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
578:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
579:                 	 *
580:                 	 * Note:            None.
581:                 	 *
582:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
583:                 	 ********************************************************************/
584:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
585:                 
586:                 	/*********************************************************************
587:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
588:                 	 *
589:                 	 * PreCondition:    chn	- valid DMA channel
590:                 	 *
591:                 	 * Input:			chn		- DMA channel number
592:                 	 *
593:                 	 * Output:          event flags with the following significance:
594:                 	 * 						- DMA_EV_ERR: address error event
595:                 	 * 						- DMA_EV_ABORT: transfer abort event
596:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
597:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
598:                 	 * 						- DMA_EV_DST_HALF: destination half event
599:                 	 * 						- DMA_EV_DST_FULL: destination full event
600:                 	 * 						- DMA_EV_SRC_HALF: source half event
601:                 	 * 						- DMA_EV_SRC_FULL: source full event
602:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
603:                 	 *
604:                 	 * Side Effects:    None
605:                 	 *
606:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
607:                 	 *
608:                 	 * Note:            None.
609:                 	 *
610:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
611:                 	 ********************************************************************/
612:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
613:                 
614:                 
615:                 	// high level helpers for fast strcpy/memcpy transfers
616:                 
617:                 	/*********************************************************************
618:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
619:                 	 *
620:                 	 * PreCondition:    chn		- a valid DMA channel
621:                 	 * 					s1, s2	- valid memory pointers
622:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
623:                 	 *
624:                 	 * Input:			s1		- destination pointer
625:                 	 * 					s2		- source pointer
626:                 	 * 					n		- number of bytes to transfer
627:                 	 * 					chn		- the DMA channel to perform the transfer
628:                 	 * 					chPri	- the desired channel priority
629:                 	 *
630:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
631:                 	 * 					an DmaTxferRes error code  otherwise
632:                 	 *
633:                 	 * Side Effects:    None
634:                 	 *
635:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
636:                 	 * 			Then it copies one block of memory from source to destination.
637:                 	 *
638:                 	 *
639:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
640:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
641:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
642:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
643:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
644:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
645:                 	 *
646:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
647:                  	 ********************************************************************/
648:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
649:                 
650:                 	/*********************************************************************
651:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
652:                 	 *
653:                 	 * PreCondition:    chn		- a valid DMA channel
654:                 	 * 					s1, s2	- valid memory pointers
655:                 	 *
656:                 	 * Input:			s1		- destination pointer
657:                 	 * 					s2		- source pointer
658:                 	 * 					chn		- the DMA channel to perform the transfer
659:                 	 * 					chPri	- the desired channel priority
660:                 	 *
661:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
662:                 	 * 					an DmaTxferRes error code  otherwise
663:                 	 *
664:                 	 * Side Effects:    None
665:                 	 *
666:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
667:                 	 * 			Then it copies one zero terminated string from source to destination.
668:                 	 *
669:                 	 *
670:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
671:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
672:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
673:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
674:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
675:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
676:                 	 *
677:                 	 *
678:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
679:                 	 *********************************************************************/
680:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
681:                 
682:                 	/*********************************************************************
683:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
684:                 	 *
685:                 	 * PreCondition:    chn		- a valid DMA channel
686:                 	 * 				- s1, s2	- valid memory pointers
687:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
688:                 	 *
689:                 	 * Input:			s1		- destination pointer
690:                 	 * 					s2		- source pointer
691:                 	 * 					n	- max number of bytes to transfer
692:                 	 * 					chn		- the DMA channel to perform the transfer
693:                 	 * 					chPri	- the desired channel priority
694:                 	 *
695:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
696:                 	 * 					an DmaTxferRes error code  otherwise
697:                 	 *
698:                 	 * Side Effects:    None
699:                 	 *
700:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
701:                 	 * 			Then it copies one zero terminated string from source to destination.
702:                 	 * 			It copies no more than n characters from s2.
703:                 	 *
704:                 	 *
705:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
706:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
707:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
709:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
710:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
711:                 	 *
712:                 	 *
713:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
714:                 	 ********************************************************************/
715:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
716:                 
717:                 	/*********************************************************************
718:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
719:                 	 *
720:                 	 * PreCondition:    chn    - a valid DMA channel
721:                 	 *                  d, s   - valid memory pointer
722:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
723:                 	 *
724:                 	 * Input:           d     - address where to deposit the result
725:                 	 *                  s     - source buffer pointer
726:                 	 *                  n     - number of bytes in the pointer
727:                 	 *                  chn   - the DMA channel to use
728:                 	 *                  chPri - the desired channel priority
729:                 	 * 
730:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
731:                 	 *                  an DmaTxferRes error code  otherwise
732:                 	 *
733:                 	 * Side Effects:    None
734:                 	 *
735:                 	 * Overview:        The function is a helper that calculates the CRC of a memory block.
736:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
737:                 	 *
738:                 	 *
739:                 	 * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
740:                 	 *                  - No transfer is done, just the CRC is calculated.
741:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
742:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
743:                 	 *                  - The checksum type is switched to CRC.
744:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
745:                 	 *                  
746:                 	 * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
747:                 	 ********************************************************************/
748:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
749:                 
750:                 	/*********************************************************************
751:                 	 * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
752:                 	 *
753:                 	 * PreCondition:    chn    - a valid DMA channel
754:                 	 *                  d, s   - valid memory pointer
755:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
756:                 	 *
757:                 	 * Input:           d     - address where to deposit the result
758:                 	 *                  s     - source buffer pointer
759:                 	 *                  n     - number of bytes in the pointer
760:                 	 *                  chn   - the DMA channel to use
761:                 	 *                  chPri - the desired channel priority
762:                 	 * 
763:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
764:                 	 *                  an DmaTxferRes error code  otherwise
765:                 	 *
766:                 	 * Side Effects:    None
767:                 	 *
768:                 	 * Overview:        The function is a helper that calculates the IP checksum of a memory block.
769:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
770:                 	 *
771:                 	 *
772:                 	 * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
773:                 	 *                  - No transfer is done, just the checksum is calculated.
774:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
775:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
776:                 	 *                  - The checksum type is switched to IP checksum.
777:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
778:                 	 *                  
779:                 	 * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
780:                 	 ********************************************************************/
781:                 	 DmaTxferRes	DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
782:                 
783:                 	// High level Special Function Module (SFM) functions
784:                 
785:                 	/*********************************************************************
786:                 	 * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                 	 *
788:                 	 * PreCondition:    cType, bitO, rMode - valid values
789:                 	 *
790:                 	 * Input:           cType - checksum type to be calculated: CRC or IP Checksum
791:                 	 *                  bitO  - the bit order to be used MSb or LSb first
792:                 	 *                  rMode - the reordering mode of the bytes when calculating the checksum 
793:                 	 *
794:                 	 * Output:          None
795:                 	 *
796:                 	 * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
797:                 	 *
798:                 	 * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
799:                 	 *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
800:                 	 *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first) 
801:                 	 *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
802:                 	 *                      All these values affect the way the checksum is calculated.
803:                 	 *
804:                 	 * Note:            None
805:                 	 *
806:                 	 * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
807:                 	 ********************************************************************/
808:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
809:                 	{
810:                 		DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
811:                 		DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
812:                 	}
813:                 
814:                 	/*********************************************************************
815:                 	 * Function:        void DmaSfmTxferReorder(int enable)
816:                 	 *
817:                 	 * PreCondition:    None
818:                 	 *
819:                 	 * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
820:                 	 *
821:                 	 * Output:          None
822:                 	 *
823:                 	 * Side Effects:    None
824:                 	 *
825:                 	 * Overview:        The function configures the data transfer re-ordering of the SFM module.
826:                 	 *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
827:                 	 *                  Otherwise the data is written to the destination un-modified.
828:                 	 *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
829:                 	 *                  
830:                 	 *
831:                 	 * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
832:                 	 *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
833:                 	 *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
834:                 	 *                    Un-aligned transfers are not supported (undefined behavior)!
835:                 	 *
836:                 	 * Example:         DmaSfmTxferReorder();
837:                 	 ********************************************************************/
838:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
839:                 	{
840:                 		DCRCCONCLR=_DCRCCON_WBO_MASK;
841:                 		DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
842:                 	}
843:                 
844:                 
845:                 	 /*********************************************************************
846:                 	 * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
847:                 	 *
848:                 	 * PreCondition:    pLen   - valid polynomial length within 1-32
849:                 	 *
850:                 	 * Input:           polynomial	- the layout of the CRC generator
851:                 	 *                  pLen        - the length of the CRC generator polynomial
852:                 	 *                  seed        - the initial seed of the CRC generator
853:                 	 *
854:                 	 * Output:          None
855:                 	 *
856:                 	 * Side Effects:    None
857:                 	 *
858:                 	 * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
859:                 	 *                  - the length of the CRC generator polynomial, pLen;
860:                 	 *                  - the function sets the layout of the shift stages that take place in the CRC generation.
861:                 	 *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
862:                 	 *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
863:                 	 *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
864:                 	 *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
865:                 	 *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
866:                 	 *                  - the function sets the seed of the CRC generator. This is the initial data present in the
867:                 	 *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
868:                 	 *
869:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
870:                 	 *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
871:                 	 *                    Upon the transfer completion the calculated CRC is stored at the destination address.
872:                 	 *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
873:                 	 *                    the CrcResult() function.
874:                 	 *                  - The CRC module should be configured before enabled.
875:                 	 *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
876:                 	 *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
877:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
878:                 	 *
879:                 	 * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
880:                 	 ********************************************************************/
881:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
882:                 	{
883:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
884:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
885:                 		DCRCDATA=seed;
886:                 		DCRCXOR=polynomial;
887:                 	}
888:                 	
889:                 	#define DmaCrcConfigure	DmaSfmCrcConfigure	// PIC32_3xx backward compatibility name
890:                 
891:                 
892:                 	/*********************************************************************
893:                 	 * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
894:                 	 *
895:                 	 * PreCondition:    chn	   - valid DMA channel
896:                 	 *
897:                 	 * Input:           chn         - the DMA channel to be attached to the checksum module.
898:                 	 *                  appendMode	- if TRUE the data passed to the checksum generator is not transferred to destination
899:                 	 *                                but it's written to the destination address when the block transfer is complete.
900:                 	 *                              - if FALSE the data is transferred normally while the checksum is calculated.
901:                 	 *                                The checksum will be available using the DmaSfmChecksum function.
902:                 	 *
903:                 	 * Output:          None
904:                 	 *
905:                 	 * Side Effects:    None
906:                 	 *
907:                 	 * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
908:                 	 *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
909:                 	 *                  is complete, the checksum result is available in the checksum data register.
910:                 	 *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
911:                 
912:                 	 *
913:                 	 * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
914:                 	 * 
915:                 	 * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
916:                 	 ********************************************************************/
917:                 	void			DmaSfmAttachChannel(DmaChannel chn, int appendMode);
918:                 	#define			CrcAttachChannel	DmaSfmAttachChannel		// PIC32_3xx backward compatibility name	
919:                 
920:                 	/*********************************************************************
921:                 	 * Function:        unsigned int DmaSfmChecksum(void)
922:                 	 *
923:                 	 * PreCondition:    None
924:                 	 *
925:                 	 * Input:			None
926:                 	 *
927:                 	 * Output:          the current value of the checksum generator.
928:                 	 *
929:                 	 * Side Effects:    None
930:                 	 *
931:                 	 * Overview:		The function returns the calculated checksum value.
932:                 	 *
933:                 	 * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
934:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
935:                 	 *
936:                 	 * Example:         unsigned int myChk=DmaSfmChecksum();
937:                 	 ********************************************************************/
938:                 	extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
939:                 	{
940:                 		return DCRCDATA;
941:                 	}
942:                 	#define		CrcResult	DmaSfmChecksum		// PIC32_3xx backward compatibility name
943:                 	#define		DmaCrcGetValue	DmaSfmChecksum		// PIC32_3xx backward compatibility name 
944:                 
945:                 
946:                 	/*********************************************************************
947:                 	 * Function:        void DmaSfmSetSeed(unsigned int seed)
948:                 	 *
949:                 	 * PreCondition:    None
950:                 	 *
951:                 	 * Input:           seed	- the initial seed of the checksum generator
952:                 	 *
953:                 	 * Output:          None
954:                 	 *
955:                 	 * Side Effects:    None
956:                 	 *
957:                 	 * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
958:                 	 *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
959:                 	 *
960:                 	 * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
961:                 	 *
962:                 	 * Example:         DmaSfmSetSeed(0xffffffff);
963:                 	 ********************************************************************/
964:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
965:                 	{
966:                 		DCRCDATA=seed;
967:                 	}
968:                 	#define		DmaCrcSetSeed	DmaSfmSetSeed		// PIC32_3xx backward compatibility name
969:                 
970:                 	 
971:                 /*********************  end of high level functions ****************************************/
972:                 
973:                 	// low level definitions for the API functions
974:                 
975:                 
976:                 	typedef struct
977:                 	{
978:                 		union
979:                 		{
980:                 			struct
981:                 			{
982:                 				unsigned int chn:	3;		// last active DMA channel
983:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
984:                 			};
985:                 			unsigned int	w;						// word access
986:                 		}lastAccess;
987:                 		void*	lastAddress;		// most recent DMA address
988:                 	}DmaStatus;			// DMA controller status
989:                 
990:                 	typedef enum
991:                 	{
992:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
993:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
994:                 		//
995:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
996:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
997:                 
998:                 
999:                 
1000:                
1001:                	typedef enum
1002:                	{
1003:                		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
1004:                		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
1005:                        // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
1006:                        // the start and abort IRQ signals
1007:                		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
1008:                
1009:                
1010:                        // compiler use only field
1011:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1012:                	}DmaEvCtrlFlags;	/*DMA channel event control fields accessible as flags also
1013:                	                	  part of DmaEvCtrlFlags:
1014:                	                	*/
1015:                	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1016:                	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1017:                
1018:                	// DMA channel event control as a structure:
1019:                	#define	DmaEvCtrl	__DCH0ECONbits_t
1020:                
1021:                
1022:                
1023:                
1024:                	typedef enum
1025:                	{
1026:                		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
1027:                		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
1028:                		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
1029:                		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
1030:                		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
1031:                        // use the DMA_CTL_PRI() below for selecting the DMA
1032:                        // channel priority
1033:                	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
1034:                	// also part of DmaChnCtrlFlags:
1035:                	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1036:                
1037:                	// DMA channel control as a structure:
1038:                	#define	DmaChnCtrl  	__DCH0CONbits_t
1039:                
1040:                	typedef struct
1041:                	{
1042:                		void*	vSrcAdd;		// source of the DMA transfer, virtual
1043:                		void*	vDstAdd;		// destination of the DMA transfer, virtual
1044:                		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1045:                		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1046:                		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1047:                	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
1048:                
1049:                
1050:                	/********************** low level DMA channel functions *******************************/
1051:                
1052:                
1053:                
1054:                	// Global DMA controller functions
1055:                
1056:                	/*********************************************************************
1057:                	 * Function:        void DmaEnable(int enable)
1058:                	 *
1059:                	 * PreCondition:    None
1060:                	 *
1061:                	 * Input:           enable - boolean to enable/disable the DMA controller
1062:                	 *
1063:                	 * Output:          None
1064:                	 *
1065:                	 * Side Effects:    None
1066:                	 *
1067:                	 * Overview:       The function enables/disables the DMA controller.
1068:                	 *
1069:                	 * Note:           None.
1070:                	 *
1071:                	 * Example:        DmaEnable(1);
1072:                	 ********************************************************************/
1073:                	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1074:                	{
1075:                		if(enable)
1076:                		{
1077:                			DMACONSET=_DMACON_ON_MASK;
1078:                		}
1079:                		else
1080:                		{
1081:                			DMACONCLR=_DMACON_ON_MASK;
1082:                			while(DMACONbits.ON);		// wait to take effect
1083:                		}
1084:                	}
1085:                
1086:                	/*********************************************************************
1087:                	 * Function:        void DmaReset(void)
1088:                	 *
1089:                	 * PreCondition:    None
1090:                	 *
1091:                	 * Input:		None
1092:                	 *
1093:                	 * Output:          None
1094:                	 *
1095:                	 * Side Effects:    None
1096:                	 *
1097:                	 * Overview:        The function resets the DMA controller.
1098:                	 *
1099:                	 * Note:            None.
1100:                	 *
1101:                	 * Example:        DmaReset();
1102:                	 ********************************************************************/
1103:                	#define            DmaReset()	DmaEnable(0)
1104:                
1105:                
1106:                	/*********************************************************************
1107:                	 * Function:        int DmaSuspend(void)
1108:                	 *
1109:                	 * PreCondition:    None
1110:                	 *
1111:                	 * Input:		None
1112:                	 *
1113:                	 * Output:          true if the DMA was previously suspended, false otherwise
1114:                	 *
1115:                	 *
1116:                	 * Side Effects:    None
1117:                	 *
1118:                	 * Overview:        The function suspends the DMA controller.
1119:                	 *
1120:                	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1121:                	 *                  I.e. the function has to wait for the suspension to take place!
1122:                	 *
1123:                	 * Example:         int susp=DmaSuspend();
1124:                	 ********************************************************************/
1125:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1126:                	{
1127:                		int suspSt;
1128:                		if(!(suspSt=DMACONbits.SUSPEND))
9D002C14  3C02BF88   LUI V0, -16504
9D002C18  8C423000   LW V0, 12288(V0)
9D002C1C  7C420300   EXT V0, V0, 12, 1
9D002C20  304200FF   ANDI V0, V0, 255
9D002C24  AFC2002C   SW V0, 44(FP)
9D002C28  8FC2002C   LW V0, 44(FP)
9D002C2C  14400009   BNE V0, ZERO, 0x9D002C54
9D002C30  00000000   NOP
9D002CE8  3C02BF88   LUI V0, -16504
9D002CEC  8C423000   LW V0, 12288(V0)
9D002CF0  7C420300   EXT V0, V0, 12, 1
9D002CF4  304200FF   ANDI V0, V0, 255
9D002CF8  AFC20038   SW V0, 56(FP)
9D002CFC  8FC20038   LW V0, 56(FP)
9D002D00  1440000E   BNE V0, ZERO, 0x9D002D3C
9D002D04  00000000   NOP
1129:                		{
1130:                			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D002C34  3C02BF88   LUI V0, -16504
9D002C38  24031000   ADDIU V1, ZERO, 4096
9D002C3C  AC433008   SW V1, 12296(V0)
9D002D08  3C02BF88   LUI V0, -16504
9D002D0C  24031000   ADDIU V1, ZERO, 4096
9D002D10  AC433008   SW V1, 12296(V0)
1131:                			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9D002C40  3C02BF88   LUI V0, -16504
9D002C44  8C423000   LW V0, 12288(V0)
9D002C48  30420800   ANDI V0, V0, 2048
9D002C4C  1440FFFC   BNE V0, ZERO, 0x9D002C40
9D002C50  00000000   NOP
9D002D14  3C02BF88   LUI V0, -16504
9D002D18  8C423000   LW V0, 12288(V0)
9D002D1C  30420800   ANDI V0, V0, 2048
9D002D20  1440FFFC   BNE V0, ZERO, 0x9D002D14
9D002D24  00000000   NOP
9D002D28  0B400B4F   J 0x9D002D3C
9D002D2C  00000000   NOP
1132:                		}
1133:                		return suspSt;
9D002C54  8FC2002C   LW V0, 44(FP)
1134:                	}
1135:                
1136:                
1137:                
1138:                	/*********************************************************************
1139:                	 * Function:        void DmaResume(int susp)
1140:                	 *
1141:                	 * PreCondition:    None
1142:                	 *
1143:                	 * Input:		the desired DMA suspended state.
1144:                	 *
1145:                	 * Output:          None
1146:                	 *
1147:                	 * Side Effects:    None
1148:                	 *
1149:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1150:                	 *
1151:                	 * Note:            None.
1152:                	 *
1153:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1154:                	 ********************************************************************/
1155:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1156:                	{
1157:                		if(susp)
9D002CDC  8FC20034   LW V0, 52(FP)
9D002CE0  10400013   BEQ V0, ZERO, 0x9D002D30
9D002CE4  00000000   NOP
1158:                		{
1159:                			DmaSuspend();
1160:                		}
1161:                		else
1162:                		{
1163:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D002D30  3C02BF88   LUI V0, -16504
9D002D34  24031000   ADDIU V1, ZERO, 4096
9D002D38  AC433004   SW V1, 12292(V0)
1164:                		}
1165:                	}
1166:                
1167:                	/*********************************************************************
1168:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1169:                	 *
1170:                	 * PreCondition:    pStat	- valid pointer
1171:                	 *
1172:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1173:                	 * 							status, carrying the following info:
1174:                	 * 								- chn:	the last active DMA channel
1175:                	 * 								- rdOp: the last DMA operation, read/write
1176:                	 * 								- lastAddress: the most recent DMA address
1177:                	 *
1178:                	 * Output:          None
1179:                	 *
1180:                	 * Side Effects:    None
1181:                	 *
1182:                	 * Overview:		The function updates the info for the current DMA controller status.
1183:                	 * 					It updates the last DMA: operation, channel used and address.
1184:                	 *
1185:                	 * Note:            None.
1186:                	 *
1187:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1188:                	 ********************************************************************/
1189:                	 void			DmaGetStatus(DmaStatus* pStat);
1190:                
1191:                	/*********************************************************************
1192:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1193:                	 *
1194:                	 * PreCondition:    None
1195:                	 *
1196:                	 * Input:           gFlags - flags to be set, having the following fields:
1197:                	 * 			- DMA_GFLG_SUSPEND: DMA controller operation suspend
1198:                	 * 			- DMA_GFLG_ON: DMA controller enabled/desabled
1199:                	 * 			- DMA_GFLG_ALL_FLAGS: all flags
1200:                	 *
1201:                	 * Output:          None
1202:                	 *
1203:                	 * Side Effects:    None
1204:                	 *
1205:                	 * Overview:        The function affects the global behavior of the DMA controller.
1206:                	 *                  It sets the specified flags. Any flag that is set in the gFlags will be
1207:                	 *                  enabled, the other flags won't be touched.
1208:                	 *
1209:                	 * Note:            None.
1210:                	 *
1211:                	 * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1212:                	 ********************************************************************/
1213:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1214:                	{
1215:                		DMACONSET=gFlags;
1216:                	}
1217:                
1218:                	/*********************************************************************
1219:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1220:                	 *
1221:                	 * PreCondition:    None
1222:                	 *
1223:                	 * Input:           gFlags - flags to be cleared, having the following fields:
1224:                	 *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1225:                	 *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1226:                	 *                               - DMA_GFLG_ALL_FLAGS: all flags
1227:                	 *
1228:                	 * Output:          None
1229:                	 *
1230:                	 * Side Effects:    None
1231:                	 *
1232:                	 * Overview:        The function affects the global behavior of the DMA controller.
1233:                	 *                  It clears the specified flags. Any flag that is set in the gFlags will be
1234:                	 *                  cleared, the other flags won't be touched.
1235:                	 *
1236:                	 * Note:            None.
1237:                	 *
1238:                	 * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1239:                	 ********************************************************************/
1240:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1241:                	{
1242:                		DMACONCLR=gFlags;
1243:                	}
1244:                
1245:                
1246:                	/*********************************************************************
1247:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1248:                	 *
1249:                	 * PreCondition:    None
1250:                	 *
1251:                	 * Input:           gFlags - flags to be set, having the following fields:
1252:                	 *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1253:                	 *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1254:                	 *                                 - DMA_GFLG_ALL_FLAGS: all flags
1255:                	 *
1256:                	 * Output:          None
1257:                	 *
1258:                	 * Side Effects:    None
1259:                	 *
1260:                	 * Overview:        The function affects the global behavior of the DMA controller.
1261:                	 *                  It forces the flags to have the specified gFlags value.
1262:                	 *
1263:                	 * Note:            None.
1264:                	 *
1265:                	 * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1266:                	 ********************************************************************/
1267:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1268:                	{
1269:                		DMACON=gFlags;
1270:                	}
1271:                
1272:                	/*********************************************************************
1273:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1274:                	 *
1275:                	 * PreCondition:    None
1276:                	 *
1277:                	 * Input:           None
1278:                	 *
1279:                	 * Output:          The current DMA controller flags settings.
1280:                	 *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1281:                	 *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1282:                	 *
1283:                	 * Side Effects:    None
1284:                	 *
1285:                	 * Overview:        The function returns the global flags of the DMA controller.
1286:                	 *
1287:                	 * Note:            None.
1288:                	 *
1289:                	 * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1290:                	 ********************************************************************/
1291:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1292:                	{
1293:                		return (DmaGlblFlags)DMACON;
1294:                	}
1295:                
1296:                
1297:                	/*********************************************************************
1298:                	 * Function:        int DmaGetMaxTxferSize(void)
1299:                	 *
1300:                	 * PreCondition:    None
1301:                	 *
1302:                	 * Input:           None
1303:                	 *
1304:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1305:                	 *
1306:                	 * Side Effects:    None
1307:                	 *
1308:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1309:                	 *
1310:                	 * Note:            Revision dependant.
1311:                	 *
1312:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1313:                	 ********************************************************************/
1314:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1315:                	{
1316:                		return 65536;
1317:                	}
1318:                
1319:                	// Direct Channel control functions
1320:                
1321:                	typedef enum
1322:                	{
1323:                		DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1324:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1325:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1326:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),		// DMA channel is chained to higher channel
1327:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,			// events detection enabled while channel off
1328:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,	            // DMA channel is enabled after open
1329:                		DMA_CONFIG_MATCH	= 0x80000000,                   // DMA channel stops on match
1330:                	}DmaConfigFlags;	// flags for the channel configuration
1331:                
1332:                
1333:                
1334:                	/*********************************************************************
1335:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1336:                	 *
1337:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1338:                	 *
1339:                	 * Input:           chn    - channel to be configured in the DMA controller
1340:                	 *                  chPri  - the priority given to the channel, 0-3
1341:                	 *                  cFlags - orred flags specifying the configuration:
1342:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1343:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1344:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1345:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1346:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1347:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1348:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1349:                	 *
1350:                	 *
1351:                	 *
1352:                	 * Output:          None
1353:                	 *
1354:                	 * Side Effects:    None
1355:                	 *
1356:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1357:                	 *
1358:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1359:                	 *                  The channel is just configured.
1360:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1361:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1362:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1363:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1364:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1365:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1366:                	 *
1367:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1368:                	 ********************************************************************/
1369:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1370:                
1371:                
1372:                	/*********************************************************************
1373:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1374:                	 *
1375:                	 * PreCondition:    chn	- valid DMA channel
1376:                	 *
1377:                	 * Input:			chn		- DMA channel number
1378:                	 *
1379:                	 * Output:          Current channel source pointer.
1380:                	 *
1381:                	 * Side Effects:    None
1382:                	 *
1383:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1384:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1385:                	 *
1386:                	 * Note:            None
1387:                	 *
1388:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1389:                	 ********************************************************************/
1390:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1391:                
1392:                	/*********************************************************************
1393:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1394:                	 *
1395:                	 * PreCondition:    chn	- valid DMA channel
1396:                	 *
1397:                	 * Input:			chn		- DMA channel number
1398:                	 *
1399:                	 * Output:          Current channel destination pointer.
1400:                	 *
1401:                	 * Side Effects:    None
1402:                	 *
1403:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1404:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1405:                	 *
1406:                	 * Note:            None
1407:                	 *
1408:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1409:                	 ********************************************************************/
1410:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1411:                
1412:                	/*********************************************************************
1413:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1414:                	 *
1415:                	 * PreCondition:    chn	- valid DMA channel
1416:                	 *
1417:                	 * Input:			chn		- DMA channel number
1418:                	 *
1419:                	 * Output:          Current channel transfer pointer.
1420:                	 *
1421:                	 * Side Effects:    None
1422:                	 *
1423:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1424:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1425:                	 *
1426:                	 * Note:            None
1427:                	 *
1428:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1429:                	 ********************************************************************/
1430:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1431:                
1432:                
1433:                
1434:                	/*********************************************************************
1435:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1436:                	 *
1437:                	 * PreCondition:    chn	- valid DMA channel
1438:                	 *
1439:                	 * Input:			chn			- DMA channel number
1440:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1441:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1442:                	 * 										- SIRQEN: enable/disable the start IRQ action
1443:                	 * 										- PATEN: enable/disable the pattern match and abort
1444:                	 * 									or any of the DmaEvCtrlFlags:
1445:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1446:                	 *
1447:                	 *
1448:                	 * Output:          None
1449:                	 *
1450:                	 * Side Effects:    None
1451:                	 *
1452:                	 * Overview:		The function sets the events that start and abort the transfer
1453:                	 * 					for the selected DMA channel.
1454:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1455:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1456:                	 *
1457:                	 * Note:            None.
1458:                	 *
1459:                	 * Example:			either:
1460:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1461:                	 * 					or:
1462:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1463:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1464:                	 *
1465:                	 ********************************************************************/
1466:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1467:                
1468:                
1469:                	/*********************************************************************
1470:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1471:                	 *
1472:                	 * PreCondition:    chn	- valid DMA channel
1473:                	 *
1474:                	 * Input:			chn			- DMA channel number
1475:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1476:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1477:                	 * 										- SIRQEN: enable/disable the start IRQ action
1478:                	 * 										- PATEN: enable/disable the pattern match and abort
1479:                	 * 									or any of the DmaEvCtrlFlags:
1480:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1481:                	 *
1482:                	 *
1483:                	 * Output:          None
1484:                	 *
1485:                	 * Side Effects:    None
1486:                	 *
1487:                	 * Overview:		The function clears the events that start and abort the transfer
1488:                	 * 					for the selected DMA channel.
1489:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1490:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1491:                	 *
1492:                	 * Note:            None.
1493:                	 *
1494:                	 * Example:			either:
1495:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1496:                	 * 					or:
1497:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1498:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1499:                	 *
1500:                	 ********************************************************************/
1501:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1502:                
1503:                
1504:                
1505:                	/*********************************************************************
1506:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1507:                	 *
1508:                	 * PreCondition:    chn	- valid DMA channel
1509:                	 *
1510:                	 * Input:			chn			- DMA channel number
1511:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1512:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1513:                	 * 										- SIRQEN: enable/disable the start IRQ action
1514:                	 * 										- PATEN: enable/disable the pattern match and abort
1515:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1516:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1517:                	 * 									or any of the DmaEvCtrlFlags:
1518:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1519:                	 *
1520:                	 *
1521:                	 * Output:          None
1522:                	 *
1523:                	 * Side Effects:    None
1524:                	 *
1525:                	 * Overview:		The function writes the events that start and abort the transfer
1526:                	 * 					for the selected DMA channel.
1527:                	 *
1528:                	 * Note:            None.
1529:                	 *
1530:                	 * Example:			either:
1531:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1532:                	 * 					or:
1533:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1534:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1535:                	 *
1536:                	 ********************************************************************/
1537:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1538:                
1539:                
1540:                
1541:                	/*********************************************************************
1542:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1543:                	 *
1544:                	 * PreCondition:    chn	- valid DMA channel
1545:                	 *
1546:                	 * Input:			chn			- DMA channel number
1547:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1548:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1549:                	 * 										- SIRQEN: enable/disable the start IRQ action
1550:                	 * 										- PATEN: enable/disable the pattern match and abort
1551:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1552:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1553:                	 * 									or any of the DmaEvCtrlFlags:
1554:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1555:                	 *
1556:                	 *
1557:                	 * Output:          None
1558:                	 *
1559:                	 * Side Effects:    None
1560:                	 *
1561:                	 * Overview:		The function sets the events that start and abort the transfer
1562:                	 * 					for the selected DMA channel.
1563:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1564:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1565:                	 *
1566:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1567:                	 *
1568:                	 * Example:			either:
1569:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1570:                	 * 					or:
1571:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1572:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1573:                	 *
1574:                	 ********************************************************************/
1575:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1576:                
1577:                
1578:                	/*********************************************************************
1579:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1580:                	 *
1581:                	 * PreCondition:    chn	- valid DMA channel
1582:                	 *
1583:                	 * Input:			chn		- DMA channel number
1584:                	 *
1585:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1586:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1587:                	 * 							- SIRQEN: enable/disable the start IRQ action
1588:                	 * 							- PATEN: enable/disable the pattern match and abort
1589:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1590:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1591:                	 * 						or any of the DmaEvCtrlFlags:
1592:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1593:                	 *
1594:                	 *
1595:                	 * Side Effects:    None
1596:                	 *
1597:                	 * Overview:		The function retrieves the events that start and abort the transfer
1598:                	 * 					for the selected DMA channel.
1599:                	 *
1600:                	 * Note:            None.
1601:                	 *
1602:                	 * Example:			either:
1603:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1604:                	 * 					or:
1605:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1606:                	 *
1607:                	 ********************************************************************/
1608:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1609:                
1610:                
1611:                	/*********************************************************************
1612:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1613:                	 *
1614:                	 * PreCondition:    chn	- valid DMA channel
1615:                	 *
1616:                	 * Input:			chn			- DMA channel number
1617:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1618:                	 * 										- autoEn: enable/disable the automatic mode
1619:                	 * 										- chainEn: enable/disable channel chaining
1620:                	 * 										- detectEn: enable/disable events detection when channel disabled
1621:                	 * 										- chEn: enable/disable channel functionality
1622:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1623:                	 * 									or any of the DmaChnCtrlFlags flags:
1624:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1625:                	 *
1626:                	 * Output:          None
1627:                	 *
1628:                	 * Side Effects:    None
1629:                	 *
1630:                	 * Overview:		The function sets the selected DMA channel control flags:
1631:                	 * 					the chaining or auto mode, and events detection.
1632:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1633:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1634:                	 *
1635:                	 * Note:            None.
1636:                	 *
1637:                	 * Example:			either:
1638:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1639:                	 * 					or:
1640:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1641:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1642:                	 *
1643:                	 ********************************************************************/
1644:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1645:                
1646:                	/*********************************************************************
1647:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1648:                	 *
1649:                	 * PreCondition:    chn	- valid DMA channel
1650:                	 *
1651:                	 * Input:			chn			- DMA channel number
1652:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1653:                	 * 										- autoEn: enable/disable the automatic mode
1654:                	 * 										- chainEn: enable/disable channel chaining
1655:                	 * 										- detectEn: enable/disable events detection when channel disabled
1656:                	 * 										- chEn: enable/disable channel functionality
1657:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1658:                	 * 									or any of the DmaChnCtrlFlags flags:
1659:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1660:                	 *
1661:                	 * Output:          None
1662:                	 *
1663:                	 * Side Effects:    None
1664:                	 *
1665:                	 * Overview:		The function clears the selected DMA channel control flags:
1666:                	 * 					the chaining or auto mode and events detection.
1667:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1668:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1669:                	 *
1670:                	 * Note:            None.
1671:                	 *
1672:                	 * Example:			either:
1673:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1674:                	 * 					or:
1675:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1676:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1677:                	 *
1678:                	 ********************************************************************/
1679:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1680:                
1681:                	/*********************************************************************
1682:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1683:                	 *
1684:                	 * PreCondition:    chn	- valid DMA channel
1685:                	 *
1686:                	 * Input:			chn			- DMA channel number
1687:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1688:                	 * 										- chPri: channel priority 0-3
1689:                	 * 										- autoEn: enable/disable the automatic mode
1690:                	 * 										- chainEn: enable/disable channel chaining
1691:                	 * 										- detectEn: enable/disable events detection when channel disabled
1692:                	 * 										- chEn: enable/disable channel functionality
1693:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1694:                	 * 									or any of the DmaChnCtrlFlags flags:
1695:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1696:                	 *
1697:                	 * Output:          None
1698:                	 *
1699:                	 * Side Effects:    None
1700:                	 *
1701:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1702:                	 * 					the channel priority, chaining mode or auto and events detection.
1703:                	 *
1704:                	 * Note:            None.
1705:                	 *
1706:                	 * Example:			either:
1707:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1708:                	 * 					or:
1709:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1710:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1711:                	 *
1712:                	 ********************************************************************/
1713:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1714:                
1715:                	/*********************************************************************
1716:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1717:                	 *
1718:                	 * PreCondition:    chn	- valid DMA channel
1719:                	 *
1720:                	 * Input:	    chn		- DMA channel number
1721:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1722:                	 * 						- chPri: channel priority 0-3
1723:                	 * 						- autoEn: enable/disable the automatic mode
1724:                	 * 						- chainEn: enable/disable channel chaining
1725:                	 * 						- detectEn: enable/disable events detection when channel disabled
1726:                	 * 						- chEn: enable/disable channel functionality
1727:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1728:                	 * 					or any of the DmaChnCtrlFlags flags:
1729:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1730:                	 *
1731:                	 * Output:          None
1732:                	 *
1733:                	 * Side Effects:    None
1734:                	 *
1735:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1736:                	 * 					the channel priority, chaining mode or auto and events detection.
1737:                	 *
1738:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1739:                	 *
1740:                	 * Example:         either:
1741:                	 *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1742:                	 *                  or:
1743:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1744:                	 * 			DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1745:                	 *
1746:                	 ********************************************************************/
1747:                	#define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1748:                
1749:                	/*********************************************************************
1750:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1751:                	 *
1752:                	 * PreCondition:    chn	- valid DMA channel
1753:                	 *
1754:                	 * Input:			chn			- DMA channel number
1755:                	 *
1756:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1757:                	 * 							- chPri: channel priority 0-3
1758:                	 * 							- autoEn: enable/disable the automatic mode
1759:                	 * 							- chainEn: enable/disable channel chaining
1760:                	 * 							- detectEn: enable/disable events detection when channel disabled
1761:                	 * 							- chEn: enable/disable channel functionality
1762:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1763:                	 *						or any of the DmaChnCtrlFlags flags:
1764:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1765:                	 *
1766:                	 * Side Effects:    None
1767:                	 *
1768:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1769:                	 * 					including the channel enable/disable status, the channel priority,
1770:                	 * 					chaining mode, auto mode and events detection.
1771:                	 *
1772:                	 * Note:            None.
1773:                	 *
1774:                	 * Example:			either:
1775:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1776:                	 * 					or:
1777:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1778:                	 *
1779:                	 ********************************************************************/
1780:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1781:                
1782:                
1783:                	/*********************************************************************
1784:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1785:                	 *
1786:                	 * PreCondition:    chn	- valid DMA channel
1787:                	 *
1788:                	 * Input:			chn		- DMA channel number
1789:                	 *
1790:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1791:                	 *
1792:                	 * Side Effects:    None
1793:                	 *
1794:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1795:                	 *
1796:                	 * Note:            None.
1797:                	 *
1798:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1799:                	 *
1800:                	 ********************************************************************/
1801:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1802:                
1803:                	/*********************************************************************
1804:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1805:                	 *
1806:                	 * PreCondition:    chn		- valid DMA channel
1807:                	 * 					pTxCtrl	- valid pointer
1808:                	 *
1809:                	 * Input:			chn			- DMA channel number
1810:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1811:                	 * 								- vSrcAdd: source of the DMA transfer
1812:                	 * 								- vDstAdd: destination of the DMA transfer
1813:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1814:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1815:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1816:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1817:                	 *
1818:                	 * Output:          None
1819:                	 *
1820:                	 * Side Effects:    None
1821:                	 *
1822:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1823:                	 * 					the source and the destination addresses.
1824:                	 * 					It also retrieves the source and destination lengths
1825:                	 * 					and the number of bytes	transferred per event.
1826:                	 *
1827:                	 * Note:            None
1828:                	 *
1829:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1830:                	 ********************************************************************/
1831:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1832:                
1833:                	// Low level checksum functions
1834:                
1835:                	/*********************************************************************
1836:                	 * Function:        void DmaSfmEnable(int enable)
1837:                	 *
1838:                	 * PreCondition:    None
1839:                	 *
1840:                	 * Input:           enable _ boolean to enable/disable the SFM functionality
1841:                	 *
1842:                	 * Output:          None
1843:                	 *
1844:                	 * Side Effects:    None
1845:                	 *
1846:                	 * Overview:        The function enables/diables the checksum module functionality.
1847:                	 *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1848:                	 *
1849:                	 * Note:            The SFM module should be properly configured before enabled.
1850:                	 *
1851:                	 * Example:         DmaSfmEnable(1);
1852:                	 ********************************************************************/
1853:                	extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1854:                	{
1855:                		if(enable)
1856:                		{
1857:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1858:                		}
1859:                		else
1860:                		{
1861:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1862:                		}
1863:                	}
1864:                	#define DmaCrcEnable	DmaSfmEnable		// PIC32_3xx backward compatibility
1865:                
1866:                
1867:                	/*********************************************************************
1868:                	 * Function:        int DmaSfmGetEnable(void)
1869:                	 *
1870:                	 * PreCondition:    None
1871:                	 *
1872:                	 * Input:			None
1873:                	 *
1874:                	 * Output:          TRUE, if the SFM module is enabled
1875:                	 * 		    FALSE otherwise
1876:                	 *
1877:                	 * Side Effects:    None
1878:                	 *
1879:                	 * Overview:		The function returns the SFM module enabling status.
1880:                	 *
1881:                	 * Note:            None
1882:                	 *
1883:                	 * Example:	    int isSfmEnabled=DmaSfmGetEnable();
1884:                	 ********************************************************************/
1885:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1886:                	{
1887:                		return DCRCCONbits.CRCEN!=0;
1888:                	}
1889:                	#define		DmaCrcGetEnable 	DmaSfmGetEnable		// PIC32_3xx backward compatibility
1890:                
1891:                
1892:                	/*********************************************************************
1893:                	 * Function:        void DmaSfmAppendEnable(int enable)
1894:                	 *
1895:                	 * PreCondition:    None
1896:                	 *
1897:                	 * Input:           enable _ boolean to enable/disable the SFM append mode
1898:                	 *
1899:                	 * Output:          None
1900:                	 *
1901:                	 * Side Effects:    None
1902:                	 *
1903:                	 * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1904:                	 *                  the source data but does not write it to the destination address. The data it's just passed
1905:                	 *                  to the checksum generator for CRC/IP checksum calculation.
1906:                	 *                  When the block transfer is completed, the checksum result is written to the
1907:                	 *                  DMA channel destination address.
1908:                	 *
1909:                	 * Note:            The SFM module should be properly configured before enabled.
1910:                	 *
1911:                	 * Example:         DmaSfmAppendModeEnable(TRUE);
1912:                	 ********************************************************************/
1913:                	extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1914:                	{
1915:                		if(enable)
1916:                		{
1917:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1918:                		}
1919:                		else
1920:                		{
1921:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1922:                		}
1923:                	}
1924:                	#define		DmaCrcAppendModeEnable	DmaSfmAppendEnable	// PIC32_3xx backward compatibility
1925:                
1926:                
1927:                	/*********************************************************************
1928:                	 * Function:        int DmaSfmGetAppendMode(void)
1929:                	 *
1930:                	 * PreCondition:    None
1931:                	 *
1932:                	 * Input:           None
1933:                	 *
1934:                	 * Output:          TRUE, if the SFM append mode is enabled
1935:                	 *                  FALSE otherwise
1936:                	 *
1937:                	 * Side Effects:    None
1938:                	 *
1939:                	 * Overview:        The function returns the SFM module enabling status.
1940:                	 *
1941:                	 * Note:            None
1942:                	 *
1943:                	 * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1944:                	 ********************************************************************/
1945:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1946:                	{
1947:                		return DCRCCONbits.CRCAPP!=0;
1948:                	}
1949:                	#define	DmaCrcGetAppendMode	DmaSfmGetAppendMode		// PIC32_3xx backward compatibility
1950:                
1951:                
1952:                	/*********************************************************************
1953:                	 * Function:        void DmaSfmSetAttach(DmaChannel chn)
1954:                	 *
1955:                	 * PreCondition:    chn		- valid DMA channel
1956:                	 *
1957:                	 * Input:           chn	- the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1958:                	 *
1959:                	 * Output:          None
1960:                	 *
1961:                	 * Side Effects:    None
1962:                	 *
1963:                	 * Overview:        The function directly attaches a DMA channel to the SFM module.
1964:                	 *
1965:                	 * Note:            None
1966:                	 *
1967:                	 * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1968:                	 ********************************************************************/
1969:                	extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1970:                	{
1971:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1972:                		DCRCCONSET=chn;
1973:                	}
1974:                	#define		DmaCrcSetAttach		DmaSfmSetAttach		// PIC32_3xx backward compatibility
1975:                
1976:                
1977:                	/*********************************************************************
1978:                	 * Function:        DmaChannel DmaSfmGetAttach(void)
1979:                	 *
1980:                	 * PreCondition:    None
1981:                	 *
1982:                	 * Input:           None
1983:                	 *
1984:                	 * Output:          the DMA channel that is currently attached to the CRC module
1985:                	 *
1986:                	 * Side Effects:    None
1987:                	 *
1988:                	 * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1989:                	 *
1990:                	 * Note:            None
1991:                	 *
1992:                	 * Example:         DmaChannel chn=DmaSfmGetAttach();
1993:                	 ********************************************************************/
1994:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1995:                	{
1996:                		return (DmaChannel)DCRCCONbits.CRCCH;
1997:                	}
1998:                	#define		DmaCrcGetAttach		DmaSfmGetAttach		// PIC32_3xx backward compatibility
1999:                
2000:                	/*********************************************************************
2001:                	 * Function:        void DmaCrcSetPLen(int pLen)
2002:                	 *
2003:                	 * PreCondition:    pLen - valid polynomial length within 1-32
2004:                	 *
2005:                	 * Input:           pLen	- the length of the CRC generator polynomial
2006:                	 *
2007:                	 * Output:          None
2008:                	 *
2009:                	 * Side Effects:    None
2010:                	 *
2011:                	 * Overview:        The length of the CRC generator polynomial is set as being pLen;
2012:                	 *
2013:                	 * Note:            None
2014:                	 *
2015:                	 * Example:         DmaCrcSetPLen(32);
2016:                	 ********************************************************************/
2017:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2018:                	{
2019:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
2020:                		DCRCCONSET=(pLen)-1;
2021:                	}
2022:                
2023:                	/*********************************************************************
2024:                	 * Function:        int DmaCrcGetPLen(void)
2025:                	 *
2026:                	 * PreCondition:    None
2027:                	 *
2028:                	 * Input:           None
2029:                	 *
2030:                	 * Output:          the length of the CRC generator polynomial
2031:                	 *
2032:                	 * Side Effects:    None
2033:                	 *
2034:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
2035:                	 *                  It's always a number between 1 and 32.
2036:                	 *
2037:                	 * Note:            None
2038:                	 *
2039:                	 * Example:         int polyLen=DmaCrcGetPLen();
2040:                	 ********************************************************************/
2041:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2042:                	{
2043:                		return	DCRCCONbits.PLEN+1; 
2044:                	}
2045:                
2046:                	/*********************************************************************
2047:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2048:                	 *
2049:                	 * PreCondition:    None
2050:                	 *
2051:                	 * Input:           feedback - the layout of the CRC generator
2052:                	 *
2053:                	 * Output:          None
2054:                	 *
2055:                	 * Side Effects:    None
2056:                	 *
2057:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2058:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2059:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2060:                	 *
2061:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2062:                	 *
2063:                	 * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2064:                	 ********************************************************************/
2065:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2066:                	{
2067:                		DCRCXOR=feedback;
2068:                	}
2069:                
2070:                
2071:                	/*********************************************************************
2072:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2073:                	 *
2074:                	 * PreCondition:    None
2075:                	 *
2076:                	 * Input:           None
2077:                	 *
2078:                	 * Output:          the current layout of the CRC generator
2079:                	 *
2080:                	 * Side Effects:    None
2081:                	 *
2082:                	 * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2083:                	 *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2084:                	 *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2085:                	 *
2086:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2087:                	 *
2088:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
2089:                	 ********************************************************************/
2090:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2091:                	{
2092:                		return DCRCXOR;
2093:                	}
2094:                
2095:                
2096:                
2097:                	// Channel test/debug and special functions
2098:                
2099:                	/*********************************************************************
2100:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2101:                	 *
2102:                	 * PreCondition:    chn	- valid DMA channel
2103:                	 *
2104:                	 * Input:			chn		- DMA channel number
2105:                	 * 					eFlags	- event flags with the following significance:
2106:                	 * 								- DMA_EV_ERR: address error event
2107:                	 * 								- DMA_EV_ABORT: transfer abort event
2108:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2109:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2110:                	 * 								- DMA_EV_DST_HALF: destination half event
2111:                	 * 								- DMA_EV_DST_FULL: destination full event
2112:                	 * 								- DMA_EV_SRC_HALF: source half event
2113:                	 * 								- DMA_EV_SRC_FULL: source full event
2114:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2115:                	 *
2116:                	 * Output:          None
2117:                	 *
2118:                	 * Side Effects:    None
2119:                	 *
2120:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2121:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2122:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2123:                	 *
2124:                	 * Note:            This is intended as a channel test function.
2125:                	 *
2126:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2127:                	 ********************************************************************/
2128:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2129:                
2130:                	/*********************************************************************
2131:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2132:                	 *
2133:                	 * PreCondition:    chn	- valid DMA channel
2134:                	 *
2135:                	 * Input:			chn		- DMA channel number
2136:                	 * 					eFlags	- event flags with the following significance:
2137:                	 * 								- DMA_EV_ERR: address error event
2138:                	 * 								- DMA_EV_ABORT: transfer abort event
2139:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2140:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2141:                	 * 								- DMA_EV_DST_HALF: destination half event
2142:                	 * 								- DMA_EV_DST_FULL: destination full event
2143:                	 * 								- DMA_EV_SRC_HALF: source half event
2144:                	 * 								- DMA_EV_SRC_FULL: source full event
2145:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2146:                	 *
2147:                	 * Output:          None
2148:                	 *
2149:                	 * Side Effects:    None
2150:                	 *
2151:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2152:                	 * 					The channel event flags are forced to the eFlags value.
2153:                	 *
2154:                	 * Note:            This is intended as a channel test function.
2155:                	 *
2156:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2157:                	 ********************************************************************/
2158:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2159:                
2160:                
2161:                	/********************************************************************
2162:                	 * Include legacy DMA functions
2163:                	 * New projects should not use them!
2164:                	 * Note that interrupt functions are no longer provided.
2165:                	 * The functions in the int.h should be used instead.
2166:                	 ********************************************************************/
2167:                	#ifndef _PLIB_DISABLE_LEGACY
2168:                		#include <peripheral/legacy/dma_legacy.h>
2169:                	#endif
2170:                
2171:                
2172:                #else
2173:                	#undef _DMA_CHANNELS		// no DMA channels
2174:                #endif	// _DMAC0
2175:                
2176:                #endif /*_DMA_H_*/
2177:                
2178:                
---  C:/Users/ben.danametrics/Desktop/NexOS/Project/PIC32_Context_Switch.S  -----------------------------
                                                  1:     #include <xc.h>
                                                  2:     #include <sys/asm.h>
                                                  3:     
                                                  4:     	.equ		TASK_CONTEXT_SIZE_IN_BYTES,		140
                                                  5:     
                                                  6:     	.set		nomips16
                                                  7:      	.set		noreorder
                                                  8:     	.set 		noat
                                                  9:     	.global 	GetGP
                                                  10:    
                                                  11:    	.ent		GetGP
                                                  12:    
                                                  13:    GetGP:
                                                  14:    	
9D0035D0  03801021   ADDU V0, GP, ZERO            15:    	addu  v0, gp, zero
9D0035D4  03E00008   JR RA                        16:    	jr ra
9D0035D8  00000000   NOP                          17:    	nop
                                                  18:    
                                                  19:    	.end 		GetGP
                                                  20:    
                                                  21:    	.set		nomips16
                                                  22:     	.set		noreorder
                                                  23:    	.set 		noat
                                                  24:    	.global 	GetSP
                                                  25:    
                                                  26:    	.ent		GetSP
                                                  27:    
                                                  28:    GetSP:
                                                  29:    	
9D0035DC  03A01021   ADDU V0, SP, ZERO            30:    	addu  v0, sp, zero
9D0035E0  03E00008   JR RA                        31:    	jr ra
9D0035E4  00000000   NOP                          32:    	nop
                                                  33:    
                                                  34:    	.end 		GetSP
                                                  35:    
                                                  36:    
                                                  37:    	.extern		NextTask
                                                  38:    	.global		ContextSwitch
                                                  39:    	.set		nomips16
                                                  40:     	.set		noreorder
                                                  41:    	.set 		noat
                                                  42:     	.ent		ContextSwitch
                                                  43:    
                                                  44:    /*
                                                  45:    	131 instructions per context switch on NextTaskJustIterate
                                                  46:    */
                                                  47:    
                                                  48:    ContextSwitch:
                                                  49:    	
9D0035E8  23BDFF74   ADDI SP, SP, -140            50:    	addi $29, $29, -140	 /* Make room for the context of the currently running task */	
                                                  51:    
                                                  52:    	/*
                                                  53:    		Save k1 and k0 so we can use them as temporaries in saving and manipulating some of the
                                                  54:    		CP0 Registers.
                                                  55:    	*/
9D0035EC  AFBB0024   SW K1, 36(SP)                56:    	sw k1, 36(sp)
                                                  57:    
9D0035F0  AFBA0020   SW K0, 32(SP)                58:    	sw k0, 32(sp)
                                                  59:    
9D0035F4  401B7000   MFC0 K1, EPC                 60:    	mfc0 k1, _CP0_EPC
9D0035F8  AFBB0010   SW K1, 16(SP)                61:    	sw k1, 16(sp)
                                                  62:    	
9D0035FC  401B6000   MFC0 K1, Status              63:    	mfc0 k1, _CP0_STATUS
9D003600  AFBB000C   SW K1, 12(SP)                64:    	sw k1, 12(sp)
                                                  65:    
                                                  66:    	/*
                                                  67:    		Save all the GPR's onto the stack
                                                  68:    	*/
9D003604  AFA10088   SW AT, 136(SP)               69:    	sw $1, 136(sp)
9D003608  AFA20084   SW V0, 132(SP)               70:    	sw v0, 132(sp)
9D00360C  AFA30080   SW V1, 128(SP)               71:    	sw v1, 128(sp)
9D003610  AFA4007C   SW A0, 124(SP)               72:    	sw a0, 124(sp)
9D003614  AFA50078   SW A1, 120(SP)               73:    	sw a1, 120(sp)
9D003618  AFA60074   SW A2, 116(SP)               74:    	sw a2, 116(sp)
9D00361C  AFA70070   SW A3, 112(SP)               75:    	sw a3, 112(sp)
9D003620  AFA8006C   SW T0, 108(SP)               76:    	sw t0, 108(sp)
9D003624  AFA90068   SW T1, 104(SP)               77:    	sw t1, 104(sp)
9D003628  AFAA0064   SW T2, 100(SP)               78:    	sw t2, 100(sp)
9D00362C  AFAB0060   SW T3, 96(SP)                79:    	sw t3, 96(sp)
9D003630  AFAC005C   SW T4, 92(SP)                80:    	sw t4, 92(sp)
9D003634  AFAD0058   SW T5, 88(SP)                81:    	sw t5, 88(sp)
9D003638  AFAE0054   SW T6, 84(SP)                82:    	sw t6, 84(sp)
9D00363C  AFAF0050   SW T7, 80(SP)                83:    	sw t7, 80(sp) 
9D003640  AFB0004C   SW S0, 76(SP)                84:    	sw s0, 76(sp)
9D003644  AFB10048   SW S1, 72(SP)                85:    	sw s1, 72(sp)
9D003648  AFB20044   SW S2, 68(SP)                86:    	sw s2, 68(sp)
9D00364C  AFB30040   SW S3, 64(SP)                87:    	sw s3, 64(sp)
9D003650  AFB4003C   SW S4, 60(SP)                88:    	sw s4, 60(sp)
9D003654  AFB50038   SW S5, 56(SP)                89:    	sw s5, 56(sp)
9D003658  AFB60034   SW S6, 52(SP)                90:    	sw s6, 52(sp)
9D00365C  AFB70030   SW S7, 48(SP)                91:    	sw s7, 48(sp)
9D003660  AFB8002C   SW T8, 44(SP)                92:    	sw t8, 44(sp)
9D003664  AFB90028   SW T9, 40(SP)                93:    	sw t9, 40(sp)
9D003668  AFBC001C   SW GP, 28(SP)                94:    	sw gp, 28(sp)
9D00366C  AFBE0018   SW FP, 24(SP)                95:    	sw fp, 24(sp)
9D003670  AFBF0014   SW RA, 20(SP)                96:    	sw ra, 20(sp)
                                                  97:    	
9D003674  0000D010   MFHI K0                      98:    	mfhi k0
9D003678  AFBA0008   SW K0, 8(SP)                 99:    	sw k0, 8(sp)
                                                  100:   	
9D00367C  0000D012   MFLO K0                      101:   	mflo k0
9D003680  AFBA0004   SW K0, 4(SP)                 102:   	sw k0, 4(sp)
                                                  103:   	
9D003684  03A02021   ADDU A0, SP, ZERO            104:   	move a0, sp /* Move the stack pointer to the register for value passing in C */
                                                  105:   
9D003688  0F400170   JAL 0x9D0005C0               106:   	jal OS_NextTask	/* go to switch task */
9D00368C  00000000   NOP                          107:   	nop
                                                  108:   	
                                                  109:   	/* now begin to restore context */
                                                  110:   	
                                                  111:   	
9D003690  0040E821   ADDU SP, V0, ZERO            112:   	move sp, v0		/* restore the sp, Microchip C32 Compiler Guide says v0,v1 are used to return values */
                                                  113:   	
                                                  114:   	/* Now restore registers */
                                                  115:   	
9D003694  8FBA0004   LW K0, 4(SP)                 116:   	lw k0, 4(sp) 
9D003698  03400013   MTLO K0                      117:   	mtlo k0
                                                  118:   	
9D00369C  8FBA0008   LW K0, 8(SP)                 119:   	lw k0, 8(sp)
9D0036A0  03400011   MTHI K0                      120:   	mthi k0
                                                  121:   	
9D0036A4  8FBA0010   LW K0, 16(SP)                122:   	lw k0, 16(sp)
9D0036A8  409A7000   MTC0 K0, EPC                 123:   	mtc0 k0, _CP0_EPC
                                                  124:   	
9D0036AC  8FBF0014   LW RA, 20(SP)                125:   	lw ra, 20(sp)
9D0036B0  8FBE0018   LW FP, 24(SP)                126:   	lw fp, 24(sp)
9D0036B4  8FBC001C   LW GP, 28(SP)                127:   	lw gp, 28(sp)
9D0036B8  8FBA0020   LW K0, 32(SP)                128:   	lw k0, 32(sp)
9D0036BC  8FBB0024   LW K1, 36(SP)                129:   	lw k1, 36(sp)
9D0036C0  8FB90028   LW T9, 40(SP)                130:   	lw t9, 40(sp)
9D0036C4  8FB8002C   LW T8, 44(SP)                131:   	lw t8, 44(sp)
9D0036C8  8FB70030   LW S7, 48(SP)                132:   	lw s7, 48(sp)
9D0036CC  8FB60034   LW S6, 52(SP)                133:   	lw s6, 52(sp)
9D0036D0  8FB50038   LW S5, 56(SP)                134:   	lw s5, 56(sp)
9D0036D4  8FB4003C   LW S4, 60(SP)                135:   	lw s4, 60(sp)
9D0036D8  8FB30040   LW S3, 64(SP)                136:   	lw s3, 64(sp)
9D0036DC  8FB20044   LW S2, 68(SP)                137:   	lw s2, 68(sp)
9D0036E0  8FB10048   LW S1, 72(SP)                138:   	lw s1, 72(sp)
9D0036E4  8FB0004C   LW S0, 76(SP)                139:   	lw s0, 76(sp)
9D0036E8  8FAF0050   LW T7, 80(SP)                140:   	lw t7, 80(sp)
9D0036EC  8FAE0054   LW T6, 84(SP)                141:   	lw t6, 84(sp)
9D0036F0  8FAD0058   LW T5, 88(SP)                142:   	lw t5, 88(sp)
9D0036F4  8FAC005C   LW T4, 92(SP)                143:   	lw t4, 92(sp)
9D0036F8  8FAB0060   LW T3, 96(SP)                144:   	lw t3, 96(sp)
9D0036FC  8FAA0064   LW T2, 100(SP)               145:   	lw t2, 100(sp)
9D003700  8FA90068   LW T1, 104(SP)               146:   	lw t1, 104(sp)
9D003704  8FA8006C   LW T0, 108(SP)               147:   	lw t0, 108(sp)
9D003708  8FA70070   LW A3, 112(SP)               148:   	lw a3, 112(sp)
9D00370C  8FA60074   LW A2, 116(SP)               149:   	lw a2, 116(sp)
9D003710  8FA50078   LW A1, 120(SP)               150:   	lw a1, 120(sp)
9D003714  8FA4007C   LW A0, 124(SP)               151:   	lw a0, 124(sp)
9D003718  8FA30080   LW V1, 128(SP)               152:   	lw v1, 128(sp)
9D00371C  8FA20084   LW V0, 132(SP)               153:   	lw v0, 132(sp)
9D003720  8FA10088   LW AT, 136(SP)               154:   	lw $1, 136(sp)
                                                  155:   
9D003724  8FBA000C   LW K0, 12(SP)                156:   	lw k0, 12(sp)
9D003728  409A6000   MTC0 K0, Status              157:   	mtc0 k0, _CP0_STATUS
                                                  158:   
9D00372C  23BD008C   ADDI SP, SP, 140             159:   	addi $29, $29, 140 /* Return stack to previous position */
                                                  160:   
9D003730  42000018   ERET                         161:   	eret /* Return from exception */
9D003734  00000000   NOP                          162:   	nop
                                                  163:   	
                                                  164:   	.end ContextSwitch
                                                  165:   
                                                  166:   
                                                  167:   
                                                  168:   	.global OS_StartFirstTask
                                                  169:   
                                                  170:   	.ent OS_StartFirstTask
                                                  171:   
                                                  172:   OS_StartFirstTask:
                                                  173:   
9D003738  0080E821   ADDU SP, A0, ZERO            174:   	move sp, a0		/* restore the sp, Microchip C Compiler Guide says v0,v1 are used to return values */
                                                  175:   	
                                                  176:   	/* Now restore registers */
                                                  177:   	
9D00373C  8FBA0004   LW K0, 4(SP)                 178:   	lw k0, 4(sp) 
9D003740  03400013   MTLO K0                      179:   	mtlo k0
                                                  180:   	
9D003744  8FBA0008   LW K0, 8(SP)                 181:   	lw k0, 8(sp)
9D003748  03400011   MTHI K0                      182:   	mthi k0
                                                  183:   	
9D00374C  8FBA0010   LW K0, 16(SP)                184:   	lw k0, 16(sp)
9D003750  409A7000   MTC0 K0, EPC                 185:   	mtc0 k0, _CP0_EPC
                                                  186:   
9D003754  8FBF0014   LW RA, 20(SP)                187:   	lw $31, 20(sp)
9D003758  8FBE0018   LW FP, 24(SP)                188:   	lw $30, 24(sp)
9D00375C  8FBC001C   LW GP, 28(SP)                189:   	lw $28, 28(sp)
9D003760  8FBB0020   LW K1, 32(SP)                190:   	lw $27, 32(sp)
9D003764  8FBA0024   LW K0, 36(SP)                191:   	lw $26, 36(sp)
9D003768  8FB90028   LW T9, 40(SP)                192:   	lw $25, 40(sp)
9D00376C  8FB8002C   LW T8, 44(SP)                193:   	lw $24, 44(sp)
9D003770  8FB70030   LW S7, 48(SP)                194:   	lw $23, 48(sp)
9D003774  8FB60034   LW S6, 52(SP)                195:   	lw $22, 52(sp)
9D003778  8FB50038   LW S5, 56(SP)                196:   	lw $21, 56(sp)
9D00377C  8FB4003C   LW S4, 60(SP)                197:   	lw $20, 60(sp)
9D003780  8FB30040   LW S3, 64(SP)                198:   	lw $19, 64(sp)
9D003784  8FB20044   LW S2, 68(SP)                199:   	lw $18, 68(sp)
9D003788  8FB10048   LW S1, 72(SP)                200:   	lw $17, 72(sp)
9D00378C  8FB0004C   LW S0, 76(SP)                201:   	lw $16, 76(sp)
9D003790  8FAF0050   LW T7, 80(SP)                202:   	lw $15, 80(sp)
9D003794  8FAE0054   LW T6, 84(SP)                203:   	lw $14, 84(sp)
9D003798  8FAD0058   LW T5, 88(SP)                204:   	lw $13, 88(sp)
9D00379C  8FAC005C   LW T4, 92(SP)                205:   	lw $12, 92(sp)
9D0037A0  8FAB0060   LW T3, 96(SP)                206:   	lw $11, 96(sp)
9D0037A4  8FAA0064   LW T2, 100(SP)               207:   	lw $10, 100(sp)
9D0037A8  8FA90068   LW T1, 104(SP)               208:   	lw $9, 104(sp)
9D0037AC  8FA8006C   LW T0, 108(SP)               209:   	lw $8, 108(sp)
9D0037B0  8FA70070   LW A3, 112(SP)               210:   	lw $7, 112(sp)
9D0037B4  8FA60074   LW A2, 116(SP)               211:   	lw $6, 116(sp)
9D0037B8  8FA50078   LW A1, 120(SP)               212:   	lw $5, 120(sp)
9D0037BC  8FA4007C   LW A0, 124(SP)               213:   	lw $4, 124(sp)
9D0037C0  8FA30080   LW V1, 128(SP)               214:   	lw $3, 128(sp)
9D0037C4  8FA20084   LW V0, 132(SP)               215:   	lw $2, 132(sp)
9D0037C8  8FA10088   LW AT, 136(SP)               216:   	lw $1, 136(sp)
                                                  217:   	
9D0037CC  8FBA000C   LW K0, 12(SP)                218:   	lw k0, 12(sp)
9D0037D0  409A6000   MTC0 K0, Status              219:   	mtc0 k0, _CP0_STATUS
                                                  220:   
9D0037D4  23BD008C   ADDI SP, SP, 140             221:   	addi $29, $29, 140 /* Return stack to previous position */
                                                  222:   
9D0037D8  42000018   ERET                         223:   	eret /* Return from exception */
9D0037DC  00000000   NOP                          224:   	nop
                                                  225:   
                                                  226:   	.end OS_StartFirstTask
                                                  227:   	
